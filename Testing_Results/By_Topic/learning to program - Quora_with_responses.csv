Authors,Time,Questions,Answers,api_response,originality_score
Deepak Sharma,4y,How quickly can you draw?,"Hey guys! Deepak here and I am a sketch artist from punjab . Recently I have drawn one of a very famous quoran @Smita Mishra . It took me more than 35+ hours to draw. Basically I draw hyper realistic sketches so realism takes time.

Reference Photo

2 hours

4 hours

6 hours

10 hours

15 hours

25 hours

35 hours

Thank you for reading.

Your comments are precious, so please do not forget to comment.

For more, visit my profile.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/qaij538p1edb2xno', 'title': 'How quickly can you draw?', 'score': {'original': 0.8775, 'ai': 0.1225}, 'blocks': [{'text': 'Hey guys! Deepak here and I am a sketch artist from punjab . Recently I have drawn one of a very famous quoran @Smita Mishra . It took me more than 35+ hours to draw. Basically I draw hyper realistic sketches so realism takes time.\n\nReference Photo\n\n2 hours\n\n4 hours\n\n6 hours\n\n10 hours\n\n15 hours\n\n25 hours\n\n35 hours\n\nThank you for reading.\n\nYour comments are precious, so please do not forget to comment.\n\nFor more, visit my profile.', 'result': {'fake': 0.1225, 'real': 0.8775}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983999, 'subscription': 0, 'content': 'Hey guys! Deepak here and I am a sketch artist from punjab . Recently I have drawn one of a very famous quoran @Smita Mishra . It took me more than 35+ hours to draw. Basically I draw hyper realistic sketches so realism takes time.\n\nReference Photo\n\n2 hours\n\n4 hours\n\n6 hours\n\n10 hours\n\n15 hours\n\n25 hours\n\n35 hours\n\nThank you for reading.\n\nYour comments are precious, so please do not forget to comment.\n\nFor more, visit my profile.', 'aiModelVersion': '1'}",0.8775
Kalyani Samoju,Updated 3y,What is something you've learned in the last month?,"I have learnt something new

here it goes “WHY WE MIX ASHES OF DEAD PEOPLE IN RIVERS?”

The scientific reason behind this is

Belief on immersing ashes of dead ones to the river that relates to science. The water from the holy Ganga river and the other holy rivers is used extremely to irrigate large area of land along the river.

Since the bones are rich in phosphates their ashes increase the phosphate level in the water. Phosphates are essential ingredients for irrigating lands and growing grains. Ultimately, the elements of the body return to nature after death is achieved.

This will enrich fields and fertility of soil and increases crop production level

Image credits:google","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/zqbu1tvo620i7xmp', 'title': ""What is something you've learned in the last month?"", 'score': {'original': 0.9985, 'ai': 0.0015}, 'blocks': [{'text': 'I have learnt something new\n\nhere it goes “WHY WE MIX ASHES OF DEAD PEOPLE IN RIVERS?”\n\nThe scientific reason behind this is\n\nBelief on immersing ashes of dead ones to the river that relates to science. The water from the holy Ganga river and the other holy rivers is used extremely to irrigate large area of land along the river.\n\nSince the bones are rich in phosphates their ashes increase the phosphate level in the water. Phosphates are essential ingredients for irrigating lands and growing grains. Ultimately, the elements of the body return to nature after death is achieved.\n\nThis will enrich fields and fertility of soil and increases crop production level\n\nImage credits:google', 'result': {'fake': 0.0015, 'real': 0.9985}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983997, 'subscription': 0, 'content': 'I have learnt something new\n\nhere it goes “WHY WE MIX ASHES OF DEAD PEOPLE IN RIVERS?”\n\nThe scientific reason behind this is\n\nBelief on immersing ashes of dead ones to the river that relates to science. The water from the holy Ganga river and the other holy rivers is used extremely to irrigate large area of land along the river.\n\nSince the bones are rich in phosphates their ashes increase the phosphate level in the water. Phosphates are essential ingredients for irrigating lands and growing grains. Ultimately, the elements of the body return to nature after death is achieved.\n\nThis will enrich fields and fertility of soil and increases crop production level\n\nImage credits:google', 'aiModelVersion': '1'}",0.9985
Mauvia Modi,Updated 6y,"If Python is slow compared to other languages, then why are we still using it?","This is the fastest car in the world:

The Bugatti Veyron Super Sport -- 267.81 mph (431.072 kph).

This is the bestselling car in the world:

The Toyota Corolla — 117 mph (188 kph)

The Toyota is Python. It is more common because it's user friendly, easy to use, easy to understand, pretty but practical and it gets the job done.

The Buggati is like C/C++/typically 'fast' languages — if you know what you are doing, you can get where you want at record speed. But first, you need to practice, set up a race course, fine tune it until your head hurts and have a ton of fuel in the tank.

Hope that answers your question!

Edit: Thanks Sumant Sonu for small correction in comments.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/x467rg2vs01cjkdu', 'title': 'If Python is slow compared to other languages, then why are we still using it?', 'score': {'original': 0.9943, 'ai': 0.0057}, 'blocks': [{'text': ""This is the fastest car in the world:\n\nThe Bugatti Veyron Super Sport -- 267.81 mph (431.072 kph).\n\nThis is the bestselling car in the world:\n\nThe Toyota Corolla — 117 mph (188 kph)\n\nThe Toyota is Python. It is more common because it's user friendly, easy to use, easy to understand, pretty but practical and it gets the job done.\n\nThe Buggati is like C/C++/typically 'fast' languages — if you know what you are doing, you can get where you want at record speed. But first, you need to practice, set up a race course, fine tune it until your head hurts and have a ton of fuel in the tank.\n\nHope that answers your question!\n\nEdit: Thanks Sumant Sonu for small correction in comments."", 'result': {'fake': 0.0057, 'real': 0.9943}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983995, 'subscription': 0, 'content': ""This is the fastest car in the world:\n\nThe Bugatti Veyron Super Sport -- 267.81 mph (431.072 kph).\n\nThis is the bestselling car in the world:\n\nThe Toyota Corolla — 117 mph (188 kph)\n\nThe Toyota is Python. It is more common because it's user friendly, easy to use, easy to understand, pretty but practical and it gets the job done.\n\nThe Buggati is like C/C++/typically 'fast' languages — if you know what you are doing, you can get where you want at record speed. But first, you need to practice, set up a race course, fine tune it until your head hurts and have a ton of fuel in the tank.\n\nHope that answers your question!\n\nEdit: Thanks Sumant Sonu for small correction in comments."", 'aiModelVersion': '1'}",0.9943
Andrei Cimbru,Updated 7y,What life lesson did you learn the hard way?,"Hold yourself to higher standards and live accordingly

On Friendship: I used to be very introverted and had a closed group of friends. They were very popular and I felt privileged to hang out with them. But I was also picked on the most. When meeting strangers, my ""friends"" would make lame comments about me so that it would seem that they are very cool and that they are doing me a favor for hanging out with me. Every time I started working on myself, on my goals, on expressing my dreams and the hard work I put in everyday they would feel threatened and made sure to do something about it to put me down again. My life changed immensely once I ditched them and basically started again from zero. Be around people that care about you and where you can provide two way growth
On Love: Ignoring the little things that bother you will add up in the end. When the bubble bursts you realize you hate each other so much and you don't even realize why anymore. But you are also so invested that it breaks you in half not having that person in your life ever again. Sex is great. Communication and vulnerability are better. Trust is key. If that is not present then you are just making each other miserable. Move on. Learn to love yourself again. And start over wiser.
On Confidence: I used to be very shy. I can't tell you how many opportunities I have missed because I was afraid of ""asking"" or ""upsetting"". I always thought if I just show up it will be enough. Opportunity will find me. That is not true. Stop waiting for stuff to happen and make it happen. Ask that girl out, ask for that raise, apply for that job, create that project you always wanted, go on that trip you always wanted, speak when you believe you have something to say, make that phone call. You will get slammed back down more than you could handle sometimes, but it will also help you reach places you never thought possible.
On Being Alone: I have so many regrets about people that are not present anymore in my life that I can't call. I suck at following up with people. I lived in 5 countries but always ended up alone because I was too busy to see what the people I left behind are doing once in a while. Grab your phone, look up that person you haven't talked in a while, send a Whats App message ""Hey, I've been thinking about you lately. How is your life?"". Your life will enhance immensely.
On Life (or Death): My parents were at out of town one day. I was alone at home. My aunt and uncle were visiting and in the evening she calls me that my uncle is puking blood. He had liver cancer. I wanted to call the ambulance but it was kinda in the air that this was it. Earlier that week the doctor told him he had 3 months left. My uncle was still conscious so he asks me this incredible task: ""Drive me to my hometown back to the house were I grew up, I want to die there"". I was 19. I complied. I can't tell you how many thoughts were rushing through my mind while driving on the highway with my uncle on the back seat with a bucket puking and growling. 40 miles later we get at his house and I help my aunt lay him down in bed. While she rushes to get some clean clothes my uncles calls me and whispers in my ear something. He told me his regrets and asked me to not do the same. I had to go back home to get the car to my parents who rushed back in town with the train. On the way back I stopped on the side of the road and cried for a good 15 minutes. Later that night he passed away. Take what you want from this story. I learned that time catches up with us to fast to have regrets and doubts and be stuck inside our heads. It changed me.
On Health: On working out. Walk, run, lift, do something. Not for the rock hard abs and the beach body but for your piece of mind. It teaches you discipline, it releases endorfins, it enhances your brain activity. I'm trying to catch up now after skipping physical education classes most of my life, drinking and smoking heavily. You can also change. On eating. Make sure you put in the right fuel in your body. I'm not saying to go full paleo, but start small, one coke can less per day and more greens on your plate. My proportions are 35% protein, 40% healthy carbs, 25% healthy fats.

""Mens sana in corpore sano""

On Being Liked: I used to be everyone's pet. Trying to be liked by as many people as possible. Girls, teachers, bosses, readers, colleagues, employees. I was a prisoner of everyone's opinion about me. The fact is some people will hate your work either way, some people will judge you either way, some people will expect for you to solve all their problems and hate if you can't. The moment you start giving in to everyone's opinion is the moment you stop being authentic. And people sense when you are fake. And then they like you even less. Don't be afraid to shake the apple tree a bit to see what fruits remain after.
On Parents: Your parents will give you advice that is outdated. Advice that is bad for you. They do it because they love you and want you to be safe. Don't fight them. Don't judge them. Nod your head and then do what your heart says. Call them and tell them how much you love them. One day you will be in their shoes doing the same thing. But they might not be around anymore.
On Being Vulnerable: I wish I did it more. Nobody likes that perfect, no problems, amazing Facebook-life, I'm-better-than-you person. It's fake. Everyone has their ups and downs. Everyone is trying to get by. Everyone has something to offer to the world.

For me, today it's this post.

Consider sharing this answer with someone you care about.

Follow me on Quora to keep updated with answers.

If you connected with my writing RuleYourWay
 for my private email list.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/582sjuytqilbg7pd', 'title': 'What life lesson did you learn the hard way?', 'score': {'original': 0.76443333333333, 'ai': 0.23556666666667}, 'blocks': [{'text': 'Hold yourself to higher standards and live accordingly\n\nOn Friendship: I used to be very introverted and had a closed group of friends. They were very popular and I felt privileged to hang out with them. But I was also picked on the most. When meeting strangers, my ""friends"" would make lame comments about me so that it would seem that they are very cool and that they are doing me a favor for hanging out with me. Every time I started working on myself, on my goals, on expressing my dreams and the hard work I put in everyday they would feel threatened and made sure to do something about it to put me down again. My life changed immensely once I ditched them and basically started again from zero. Be around people that care about you and where you can provide two way growth\nOn Love: Ignoring the little things that bother you will add up in the end. When the bubble bursts you realize you hate each other so much and you don\'t even realize why anymore. But you are also so invested that it breaks you in half not having that person in your life ever again. Sex is great. Communication and vulnerability are better. Trust is key. If that is not present then you are just making each other miserable. Move on. Learn to love yourself again. And start over wiser.\nOn Confidence: I used to be very shy. I can\'t tell you how many opportunities I have missed because I was afraid of ""asking"" or ""upsetting"". I always thought if I just show up it will be enough. Opportunity will find me. That is not true. Stop waiting for stuff to happen and make it happen. Ask that girl out, ask for that raise, apply for that job, create that project you always wanted, go on that trip you always wanted, speak when you believe you have something to say, make that phone call. You will get slammed back down more than you could handle sometimes, but it will also help you reach places you never thought possible.\nOn Being Alone: I have so many regrets about people that are not present anymore in my life that I can\'t call. I suck at following up with people. I lived in 5 countries but always ended up alone because I was too busy to see what the people I left behind are doing once in a while. Grab your phone, look up that person you haven\'t talked in a while, send a Whats App message ""Hey, I\'ve been thinking about you lately. How is your life?"". Your life will enhance immensely.\nOn Life (or Death): My parents were at out of town one day. I was alone at home. My aunt and uncle were visiting and in the evening she calls me that my uncle is puking blood. He had liver cancer. I wanted to call the ambulance but it was kinda in the air that this was it. Earlier that week the doctor told him he had 3 months left. My', 'result': {'fake': 0.4327, 'real': 0.5673}, 'status': 'success'}, {'text': 'uncle was still conscious so he asks me this incredible task: ""Drive me to my hometown back to the house were I grew up, I want to die there"". I was 19. I complied. I can\'t tell you how many thoughts were rushing through my mind while driving on the highway with my uncle on the back seat with a bucket puking and growling. 40 miles later we get at his house and I help my aunt lay him down in bed. While she rushes to get some clean clothes my uncles calls me and whispers in my ear something. He told me his regrets and asked me to not do the same. I had to go back home to get the car to my parents who rushed back in town with the train. On the way back I stopped on the side of the road and cried for a good 15 minutes. Later that night he passed away. Take what you want from this story. I learned that time catches up with us to fast to have regrets and doubts and be stuck inside our heads. It changed me.\nOn Health: On working out. Walk, run, lift, do something. Not for the rock hard abs and the beach body but for your piece of mind. It teaches you discipline, it releases endorfins, it enhances your brain activity. I\'m trying to catch up now after skipping physical education classes most of my life, drinking and smoking heavily. You can also change. On eating. Make sure you put in the right fuel in your body. I\'m not saying to go full paleo, but start small, one coke can less per day and more greens on your plate. My proportions are 35% protein, 40% healthy carbs, 25% healthy fats.\n\n""Mens sana in corpore sano""\n\nOn Being Liked: I used to be everyone\'s pet. Trying to be liked by as many people as possible. Girls, teachers, bosses, readers, colleagues, employees. I was a prisoner of everyone\'s opinion about me. The fact is some people will hate your work either way, some people will judge you either way, some people will expect for you to solve all their problems and hate if you can\'t. The moment you start giving in to everyone\'s opinion is the moment you stop being authentic. And people sense when you are fake. And then they like you even less. Don\'t be afraid to shake the apple tree a bit to see what fruits remain after.\nOn Parents: Your parents will give you advice that is outdated. Advice that is bad for you. They do it because they love you and want you to be safe. Don\'t fight them. Don\'t judge them. Nod your head and then do what your heart says. Call them and tell them how much you love them. One day you will be in their shoes doing the same thing. But they might not be around anymore.\nOn Being Vulnerable: I wish I did it more. Nobody likes that perfect, no problems, amazing Facebook-life, I\'m-better-than-you person. It\'s fake. Everyone has their ups and', 'result': {'fake': 0.0231, 'real': 0.9769}, 'status': 'success'}, {'text': ""downs. Everyone is trying to get by. Everyone has something to offer to the world.\n\nFor me, today it's this post.\n\nConsider sharing this answer with someone you care about.\n\nFollow me on Quora to keep updated with answers.\n\nIf you connected with my writing RuleYourWay\n for my private email list."", 'result': {'fake': 0.9152, 'real': 0.0848}, 'status': 'success'}], 'credits_used': 11, 'credits': 1983984, 'subscription': 0, 'content': 'Hold yourself to higher standards and live accordingly\n\nOn Friendship: I used to be very introverted and had a closed group of friends. They were very popular and I felt privileged to hang out with them. But I was also picked on the most. When meeting strangers, my ""friends"" would make lame comments about me so that it would seem that they are very cool and that they are doing me a favor for hanging out with me. Every time I started working on myself, on my goals, on expressing my dreams and the hard work I put in everyday they would feel threatened and made sure to do something about it to put me down again. My life changed immensely once I ditched them and basically started again from zero. Be around people that care about you and where you can provide two way growth\nOn Love: Ignoring the little things that bother you will add up in the end. When the bubble bursts you realize you hate each other so much and you don\'t even realize why anymore. But you are also so invested that it breaks you in half not having that person in your life ever again. Sex is great. Communication and vulnerability are better. Trust is key. If that is not present then you are just making each other miserable. Move on. Learn to love yourself again. And start over wiser.\nOn Confidence: I used to be very shy. I can\'t tell you how many opportunities I have missed because I was afraid of ""asking"" or ""upsetting"". I always thought if I just show up it will be enough. Opportunity will find me. That is not true. Stop waiting for stuff to happen and make it happen. Ask that girl out, ask for that raise, apply for that job, create that project you always wanted, go on that trip you always wanted, speak when you believe you have something to say, make that phone call. You will get slammed back down more than you could handle sometimes, but it will also help you reach places you never thought possible.\nOn Being Alone: I have so many regrets about people that are not present anymore in my life that I can\'t call. I suck at following up with people. I lived in 5 countries but always ended up alone because I was too busy to see what the people I left behind are doing once in a while. Grab your phone, look up that person you haven\'t talked in a while, send a Whats App message ""Hey, I\'ve been thinking about you lately. How is your life?"". Your life will enhance immensely.\nOn Life (or Death): My parents were at out of town one day. I was alone at home. My aunt and uncle were visiting and in the evening she calls me that my uncle is puking blood. He had liver cancer. I wanted to call the ambulance but it was kinda in the air that this was it. Earlier that week the doctor told him he had 3 months left. My uncle was still conscious so he asks me this incredible task: ""Drive me to my hometown back to the house were I grew up, I want to die there"". I was 19. I complied. I can\'t tell you how many thoughts were rushing through my mind while driving on the highway with my uncle on the back seat with a bucket puking and growling. 40 miles later we get at his house and I help my aunt lay him down in bed. While she rushes to get some clean clothes my uncles calls me and whispers in my ear something. He told me his regrets and asked me to not do the same. I had to go back home to get the car to my parents who rushed back in town with the train. On the way back I stopped on the side of the road and cried for a good 15 minutes. Later that night he passed away. Take what you want from this story. I learned that time catches up with us to fast to have regrets and doubts and be stuck inside our heads. It changed me.\nOn Health: On working out. Walk, run, lift, do something. Not for the rock hard abs and the beach body but for your piece of mind. It teaches you discipline, it releases endorfins, it enhances your brain activity. I\'m trying to catch up now after skipping physical education classes most of my life, drinking and smoking heavily. You can also change. On eating. Make sure you put in the right fuel in your body. I\'m not saying to go full paleo, but start small, one coke can less per day and more greens on your plate. My proportions are 35% protein, 40% healthy carbs, 25% healthy fats.\n\n""Mens sana in corpore sano""\n\nOn Being Liked: I used to be everyone\'s pet. Trying to be liked by as many people as possible. Girls, teachers, bosses, readers, colleagues, employees. I was a prisoner of everyone\'s opinion about me. The fact is some people will hate your work either way, some people will judge you either way, some people will expect for you to solve all their problems and hate if you can\'t. The moment you start giving in to everyone\'s opinion is the moment you stop being authentic. And people sense when you are fake. And then they like you even less. Don\'t be afraid to shake the apple tree a bit to see what fruits remain after.\nOn Parents: Your parents will give you advice that is outdated. Advice that is bad for you. They do it because they love you and want you to be safe. Don\'t fight them. Don\'t judge them. Nod your head and then do what your heart says. Call them and tell them how much you love them. One day you will be in their shoes doing the same thing. But they might not be around anymore.\nOn Being Vulnerable: I wish I did it more. Nobody likes that perfect, no problems, amazing Facebook-life, I\'m-better-than-you person. It\'s fake. Everyone has their ups and downs. Everyone is trying to get by. Everyone has something to offer to the world.\n\nFor me, today it\'s this post.\n\nConsider sharing this answer with someone you care about.\n\nFollow me on Quora to keep updated with answers.\n\nIf you connected with my writing RuleYourWay\n for my private email list.', 'aiModelVersion': '1'}",0.76443333333333
Abhishek Kumar,Updated 9y,How are students in Indian colleges taught programming?,"In a computer lab exam, I got a question to print the leaf nodes of a tree. I wrote a code which was running good.

Teacher said ""it's so small.""

So, I inserted few commented lines here and there... and called the teacher.

He said - ""Now its good, you get ten out of ten.""","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/qhe248oaiwtl69ug', 'title': 'How are students in Indian colleges taught programming?', 'score': {'original': 0.9984, 'ai': 0.0016}, 'blocks': [{'text': 'In a computer lab exam, I got a question to print the leaf nodes of a tree. I wrote a code which was running good.\n\nTeacher said ""it\'s so small.""\n\nSo, I inserted few commented lines here and there... and called the teacher.\n\nHe said - ""Now its good, you get ten out of ten.""', 'result': {'fake': 0.0105, 'real': 0.9895}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983983, 'subscription': 0, 'content': 'In a computer lab exam, I got a question to print the leaf nodes of a tree. I wrote a code which was running good.\n\nTeacher said ""it\'s so small.""\n\nSo, I inserted few commented lines here and there... and called the teacher.\n\nHe said - ""Now its good, you get ten out of ten.""', 'aiModelVersion': '1'}",0.9984
Neman Ashraf,Updated 6y,What life lesson did you learn the hard way?,"PTM - Parent teacher meetings.

I never thought much of it. Usually if my daughter told me to come to her school for that, I’d say yes but wouldn’t go. Or pass this to my wife.

So… once Fatima came to me and showed her school diary where it was written in bold that Principal would like to have a word with me.

I could see it is because I missed today’s PTM.

I went to the principal’s office the next day and introduced myself. She offered me a seat. Her personality was screaming that she was an iron lady.

It appears that you have missed the last two meetings. Why is that?

Ma’am, I apologize for that. My job routine is hectic and usually it can be hard for me to make time. I am a cop.

I was hoping this introduction and my soothing posture will melt her heart like a hot knife through butter.

But it didn’t, of course.

So… that’s your excuse? You made time today because I sent out a warning. But yesterday you couldn’t. Are you telling me you cannot attend a 10 minute session with your child’s teacher once a month?

You’re right. I will be more attentive from here on.

Sure, you should. It’s your responsibility as a parent to learn about your daughter’s academic activities and progress from her teacher. Such negligence won’t go unnoticed here, Mister.

Couldn’t agree more. And I thank you for this much needed briefing.

I left her office and noticed a few other “culprits” waiting for their turn to go inside. Good luck, folks!

I know she is right. I cannot be that negligent. From then onwards I am the first one to arrive on such calls and it’s fun too. Brings back the memories of my own days at school. Fatima couldn’t be happier.

Credit goes to the Iron Lady.

One enthusiastic father right here.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/oaz0wc4ndv729lgi', 'title': 'What life lesson did you learn the hard way?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'PTM - Parent teacher meetings.\n\nI never thought much of it. Usually if my daughter told me to come to her school for that, I’d say yes but wouldn’t go. Or pass this to my wife.\n\nSo… once Fatima came to me and showed her school diary where it was written in bold that Principal would like to have a word with me.\n\nI could see it is because I missed today’s PTM.\n\nI went to the principal’s office the next day and introduced myself. She offered me a seat. Her personality was screaming that she was an iron lady.\n\nIt appears that you have missed the last two meetings. Why is that?\n\nMa’am, I apologize for that. My job routine is hectic and usually it can be hard for me to make time. I am a cop.\n\nI was hoping this introduction and my soothing posture will melt her heart like a hot knife through butter.\n\nBut it didn’t, of course.\n\nSo… that’s your excuse? You made time today because I sent out a warning. But yesterday you couldn’t. Are you telling me you cannot attend a 10 minute session with your child’s teacher once a month?\n\nYou’re right. I will be more attentive from here on.\n\nSure, you should. It’s your responsibility as a parent to learn about your daughter’s academic activities and progress from her teacher. Such negligence won’t go unnoticed here, Mister.\n\nCouldn’t agree more. And I thank you for this much needed briefing.\n\nI left her office and noticed a few other “culprits” waiting for their turn to go inside. Good luck, folks!\n\nI know she is right. I cannot be that negligent. From then onwards I am the first one to arrive on such calls and it’s fun too. Brings back the memories of my own days at school. Fatima couldn’t be happier.\n\nCredit goes to the Iron Lady.\n\nOne enthusiastic father right here.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983979, 'subscription': 0, 'content': 'PTM - Parent teacher meetings.\n\nI never thought much of it. Usually if my daughter told me to come to her school for that, I’d say yes but wouldn’t go. Or pass this to my wife.\n\nSo… once Fatima came to me and showed her school diary where it was written in bold that Principal would like to have a word with me.\n\nI could see it is because I missed today’s PTM.\n\nI went to the principal’s office the next day and introduced myself. She offered me a seat. Her personality was screaming that she was an iron lady.\n\nIt appears that you have missed the last two meetings. Why is that?\n\nMa’am, I apologize for that. My job routine is hectic and usually it can be hard for me to make time. I am a cop.\n\nI was hoping this introduction and my soothing posture will melt her heart like a hot knife through butter.\n\nBut it didn’t, of course.\n\nSo… that’s your excuse? You made time today because I sent out a warning. But yesterday you couldn’t. Are you telling me you cannot attend a 10 minute session with your child’s teacher once a month?\n\nYou’re right. I will be more attentive from here on.\n\nSure, you should. It’s your responsibility as a parent to learn about your daughter’s academic activities and progress from her teacher. Such negligence won’t go unnoticed here, Mister.\n\nCouldn’t agree more. And I thank you for this much needed briefing.\n\nI left her office and noticed a few other “culprits” waiting for their turn to go inside. Good luck, folks!\n\nI know she is right. I cannot be that negligent. From then onwards I am the first one to arrive on such calls and it’s fun too. Brings back the memories of my own days at school. Fatima couldn’t be happier.\n\nCredit goes to the Iron Lady.\n\nOne enthusiastic father right here.', 'aiModelVersion': '1'}",0.9998
Andrew Bromage,4y,What are some things about coding that you learned from good programmers around you?,"The most important lesson in any programmer's career is the first time they have to fix a bug or add a feature to something they wrote over six months ago. Until that moment happens, everything you learn about coding style and quality is theoretical. This should be an exercise in any computer science or software engineering course. A large part of a programmer's career is subsequently spent finding and developing tools and techniques to make this less painful.
Learn a programming language every year. Pick one as different as possible to what you already know.
Everything in this profession involves a tradeoff. I mean everything. If you've ever wondered why you had to learn all those algorithms and data structures that you will maybe use 10% of in your life, it's for that reason: it's supposed to train your brain into thinking about tradeoffs.
A programmer is a professional problem solver. Software is one of the tools with which to solve problems, but it's far from the only one.
APIs could be as big as a programming language's standard library to as small as the interface to a single function. Either way, designing them is hard but made much easier by writing the usage code first. Good API design is the best kind of optimisation because you can replace inefficient code with efficient code easily.
Before feeding your program to the compiler, manually check the intent. Syntax (and type correctness, in a statically typed language) will be checked for you.
When starting out, keep a notebook by your desk and write in pen every bug you found in your code, what caused it, and how you fixed it. After a year, you won't need the notebook any more.
Performance always matters, but “performance” is not one single thing, and the kind of performance that matters the most will differ from program to program. Nevertheless, every millisecond that your program doesn’t burn is a millisecond that the machine can be doing something else, or can spend in low power mode. This goes double if the program is powered by a battery, and triple if the program is scaled in a cluster or cloud where you could potentially save whole machines.
Never outsource your inconvence onto a paying customer. They’re paying you to solve their problems.
All programs have real-time constraints. If your program takes three months to calculate the monthly payroll, it's useless.
Shortcuts, IDEs and so on are a huge timesaver. Learn to use them well. On the other hand, they are not indispensable and you should never forget how to work without them. You will thank me when you have to debug something over a laggy SSH connection.
Maintaining unit tests has a cost. Not only do you need to keep them up to date, they put an economic limit on how much you can modify the code that they purportedly test.
Complex logic is inevitable. If it's at all possible to fit it on one screen, do that. If you are tempted to split it across files/modules/classes, see advice #1.
Further to that point: think very hard before you write a base class. There is a very good chance that what you're about to do isn't worth it.
Trendy technologies come and go, but the craft of programming is eternal.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/fli1r4wkdgeayoz8', 'title': 'What are some things about coding that you learned from good programmers around you?', 'score': {'original': 0.8147, 'ai': 0.1853}, 'blocks': [{'text': ""The most important lesson in any programmer's career is the first time they have to fix a bug or add a feature to something they wrote over six months ago. Until that moment happens, everything you learn about coding style and quality is theoretical. This should be an exercise in any computer science or software engineering course. A large part of a programmer's career is subsequently spent finding and developing tools and techniques to make this less painful.\nLearn a programming language every year. Pick one as different as possible to what you already know.\nEverything in this profession involves a tradeoff. I mean everything. If you've ever wondered why you had to learn all those algorithms and data structures that you will maybe use 10% of in your life, it's for that reason: it's supposed to train your brain into thinking about tradeoffs.\nA programmer is a professional problem solver. Software is one of the tools with which to solve problems, but it's far from the only one.\nAPIs could be as big as a programming language's standard library to as small as the interface to a single function. Either way, designing them is hard but made much easier by writing the usage code first. Good API design is the best kind of optimisation because you can replace inefficient code with efficient code easily.\nBefore feeding your program to the compiler, manually check the intent. Syntax (and type correctness, in a statically typed language) will be checked for you.\nWhen starting out, keep a notebook by your desk and write in pen every bug you found in your code, what caused it, and how you fixed it. After a year, you won't need the notebook any more.\nPerformance always matters, but “performance” is not one single thing, and the kind of performance that matters the most will differ from program to program. Nevertheless, every millisecond that your program doesn’t burn is a millisecond that the machine can be doing something else, or can spend in low power mode. This goes double if the program is powered by a battery, and triple if the program is scaled in a cluster or cloud where you could potentially save whole machines.\nNever outsource your inconvence onto a paying customer. They’re paying you to solve their problems.\nAll programs have real-time constraints. If your program takes three months to calculate the monthly payroll, it's useless.\nShortcuts, IDEs and so on are a huge timesaver. Learn to use them well. On the other hand, they are not indispensable and you should never forget how to work without them. You will thank me when you have to debug something over a laggy SSH connection.\nMaintaining unit tests has a cost. Not only do you need to keep them up to date, they put an economic limit on how much you can modify the code that they purportedly test.\nComplex logic is inevitable. If it's at all possible to fit it on one screen, do that. If you are tempted to split it across files/modules/classes, see advice #1.\nFurther to that point: think very hard before you write a base class."", 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}, {'text': ""There is a very good chance that what you're about to do isn't worth it.\nTrendy technologies come and go, but the craft of programming is eternal."", 'result': {'fake': 0.9999, 'real': 0.0001}, 'status': 'success'}], 'credits_used': 6, 'credits': 1983973, 'subscription': 0, 'content': ""The most important lesson in any programmer's career is the first time they have to fix a bug or add a feature to something they wrote over six months ago. Until that moment happens, everything you learn about coding style and quality is theoretical. This should be an exercise in any computer science or software engineering course. A large part of a programmer's career is subsequently spent finding and developing tools and techniques to make this less painful.\nLearn a programming language every year. Pick one as different as possible to what you already know.\nEverything in this profession involves a tradeoff. I mean everything. If you've ever wondered why you had to learn all those algorithms and data structures that you will maybe use 10% of in your life, it's for that reason: it's supposed to train your brain into thinking about tradeoffs.\nA programmer is a professional problem solver. Software is one of the tools with which to solve problems, but it's far from the only one.\nAPIs could be as big as a programming language's standard library to as small as the interface to a single function. Either way, designing them is hard but made much easier by writing the usage code first. Good API design is the best kind of optimisation because you can replace inefficient code with efficient code easily.\nBefore feeding your program to the compiler, manually check the intent. Syntax (and type correctness, in a statically typed language) will be checked for you.\nWhen starting out, keep a notebook by your desk and write in pen every bug you found in your code, what caused it, and how you fixed it. After a year, you won't need the notebook any more.\nPerformance always matters, but “performance” is not one single thing, and the kind of performance that matters the most will differ from program to program. Nevertheless, every millisecond that your program doesn’t burn is a millisecond that the machine can be doing something else, or can spend in low power mode. This goes double if the program is powered by a battery, and triple if the program is scaled in a cluster or cloud where you could potentially save whole machines.\nNever outsource your inconvence onto a paying customer. They’re paying you to solve their problems.\nAll programs have real-time constraints. If your program takes three months to calculate the monthly payroll, it's useless.\nShortcuts, IDEs and so on are a huge timesaver. Learn to use them well. On the other hand, they are not indispensable and you should never forget how to work without them. You will thank me when you have to debug something over a laggy SSH connection.\nMaintaining unit tests has a cost. Not only do you need to keep them up to date, they put an economic limit on how much you can modify the code that they purportedly test.\nComplex logic is inevitable. If it's at all possible to fit it on one screen, do that. If you are tempted to split it across files/modules/classes, see advice #1.\nFurther to that point: think very hard before you write a base class. There is a very good chance that what you're about to do isn't worth it.\nTrendy technologies come and go, but the craft of programming is eternal."", 'aiModelVersion': '1'}",0.8147
Peter Hand,6y,Who are the best hackers in history and what programming languages do they use?,"This may not be a popular opinion, but I think the best hackers in history were the people who wrote the common boot sector viruses in the 1990s. Think about it -

It had to be undetectable in normal use;
It had to replicate itself to every disk ever inserted in the machine;
It had to carry out some sort of payload action;
It had to do its job and still boot the PC;
It had to fit completely into 512 bytes.

I disassembled a couple of these, back in the day. One, the Form
 virus, was as common as the common cold - I found it on dozens of computers, including every single machine (and every single floppy disk) at one place I worked. It didn’t do a lot of harm, it just added a progressively increasing delay in keyboard handling and occasionally revealed itself by making an annoying click at every keypress.

The other one I disassembled was the Michelangelo
, so named because it activated on 6th March, the artist’s birthday. On any other date it lay dormant and did nothing but replicate itself, but on that date it would trash your hard disk at bootup.

Both of these pieces of malware, and many others, fit entirely in the 512 byte boot sector. They were - of course - coded in assembler.

Below: the complete code of the Stoned virus, lacking only the ’55 AA’ at the end that would identify it as a genuine boot sector.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/mb0g2d9t8ni4ahc1', 'title': 'Who are the best hackers in history and what programming languages do they use?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'This may not be a popular opinion, but I think the best hackers in history were the people who wrote the common boot sector viruses in the 1990s. Think about it -\n\nIt had to be undetectable in normal use;\nIt had to replicate itself to every disk ever inserted in the machine;\nIt had to carry out some sort of payload action;\nIt had to do its job and still boot the PC;\nIt had to fit completely into 512 bytes.\n\nI disassembled a couple of these, back in the day. One, the Form\n virus, was as common as the common cold - I found it on dozens of computers, including every single machine (and every single floppy disk) at one place I worked. It didn’t do a lot of harm, it just added a progressively increasing delay in keyboard handling and occasionally revealed itself by making an annoying click at every keypress.\n\nThe other one I disassembled was the Michelangelo\n, so named because it activated on 6th March, the artist’s birthday. On any other date it lay dormant and did nothing but replicate itself, but on that date it would trash your hard disk at bootup.\n\nBoth of these pieces of malware, and many others, fit entirely in the 512 byte boot sector. They were - of course - coded in assembler.\n\nBelow: the complete code of the Stoned virus, lacking only the ’55 AA’ at the end that would identify it as a genuine boot sector.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983970, 'subscription': 0, 'content': 'This may not be a popular opinion, but I think the best hackers in history were the people who wrote the common boot sector viruses in the 1990s. Think about it -\n\nIt had to be undetectable in normal use;\nIt had to replicate itself to every disk ever inserted in the machine;\nIt had to carry out some sort of payload action;\nIt had to do its job and still boot the PC;\nIt had to fit completely into 512 bytes.\n\nI disassembled a couple of these, back in the day. One, the Form\n virus, was as common as the common cold - I found it on dozens of computers, including every single machine (and every single floppy disk) at one place I worked. It didn’t do a lot of harm, it just added a progressively increasing delay in keyboard handling and occasionally revealed itself by making an annoying click at every keypress.\n\nThe other one I disassembled was the Michelangelo\n, so named because it activated on 6th March, the artist’s birthday. On any other date it lay dormant and did nothing but replicate itself, but on that date it would trash your hard disk at bootup.\n\nBoth of these pieces of malware, and many others, fit entirely in the 512 byte boot sector. They were - of course - coded in assembler.\n\nBelow: the complete code of the Stoned virus, lacking only the ’55 AA’ at the end that would identify it as a genuine boot sector.', 'aiModelVersion': '1'}",0.9998
Chris Nash,Updated 1y,Can someone be a very good programmer without studying programing in college?,"Absolutely.

The greatest programmer I ever worked with didn’t have a college degree. He wasn’t only better than me, he was better than anyone else I’ve ever worked with before or since. He’s simply amazing.

No degree. He took a few college classes, but it bored him. He didn’t see the point of taking classes to learn things he already knew. He had been programming professionally since he was 14.

To many employers, this speaks volumes (image credit)

And it hurt him. I think he knows volumes more than what college could teach him, but he doesn’t have a piece of paper to prove it. Early in his career, he had trouble landing jobs because no employer wanted to risk taking on someone who didn’t have any credentials to prove he knew what he was doing. Technical interviews aside (if he even got that far), where was his piece of paper?

Now he gets new jobs fairly easily, since he has “Lead Programmer” on every previous position. But early in his career? He had trouble getting potential employers to trust him.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/vxhlaw6q8cyitdz5', 'title': 'Can someone be a very good programmer without studying programing in college?', 'score': {'original': 0.9993, 'ai': 0.0007}, 'blocks': [{'text': 'Absolutely.\n\nThe greatest programmer I ever worked with didn’t have a college degree. He wasn’t only better than me, he was better than anyone else I’ve ever worked with before or since. He’s simply amazing.\n\nNo degree. He took a few college classes, but it bored him. He didn’t see the point of taking classes to learn things he already knew. He had been programming professionally since he was 14.\n\nTo many employers, this speaks volumes (image credit)\n\nAnd it hurt him. I think he knows volumes more than what college could teach him, but he doesn’t have a piece of paper to prove it. Early in his career, he had trouble landing jobs because no employer wanted to risk taking on someone who didn’t have any credentials to prove he knew what he was doing. Technical interviews aside (if he even got that far), where was his piece of paper?\n\nNow he gets new jobs fairly easily, since he has “Lead Programmer” on every previous position. But early in his career? He had trouble getting potential employers to trust him.', 'result': {'fake': 0.0007, 'real': 0.9993}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983968, 'subscription': 0, 'content': 'Absolutely.\n\nThe greatest programmer I ever worked with didn’t have a college degree. He wasn’t only better than me, he was better than anyone else I’ve ever worked with before or since. He’s simply amazing.\n\nNo degree. He took a few college classes, but it bored him. He didn’t see the point of taking classes to learn things he already knew. He had been programming professionally since he was 14.\n\nTo many employers, this speaks volumes (image credit)\n\nAnd it hurt him. I think he knows volumes more than what college could teach him, but he doesn’t have a piece of paper to prove it. Early in his career, he had trouble landing jobs because no employer wanted to risk taking on someone who didn’t have any credentials to prove he knew what he was doing. Technical interviews aside (if he even got that far), where was his piece of paper?\n\nNow he gets new jobs fairly easily, since he has “Lead Programmer” on every previous position. But early in his career? He had trouble getting potential employers to trust him.', 'aiModelVersion': '1'}",0.9993
Håkon Hapnes Strand,5y,What is some badly-written code you wrote when you were beginning to learn programming?,"Looking in my private GitHub repositories, I found an AI I wrote for a board game when I was still just tinkering with programming.

This was the main simulation loop. Or should I say, loops.

Behold, the mother of all nested loops! It goes so many levels deep and includes so many conditionals that it won’t even fit on my tablet screen. I practically had to use the entire alphabet to have enough variable names.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wsm9xy5q3fd6ton7', 'title': 'What is some badly-written code you wrote when you were beginning to learn programming?', 'score': {'original': 0.9743, 'ai': 0.0257}, 'blocks': [{'text': 'Looking in my private GitHub repositories, I found an AI I wrote for a board game when I was still just tinkering with programming.\n\nThis was the main simulation loop. Or should I say, loops.\n\nBehold, the mother of all nested loops! It goes so many levels deep and includes so many conditionals that it won’t even fit on my tablet screen. I practically had to use the entire alphabet to have enough variable names.', 'result': {'fake': 0.0257, 'real': 0.9743}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983967, 'subscription': 0, 'content': 'Looking in my private GitHub repositories, I found an AI I wrote for a board game when I was still just tinkering with programming.\n\nThis was the main simulation loop. Or should I say, loops.\n\nBehold, the mother of all nested loops! It goes so many levels deep and includes so many conditionals that it won’t even fit on my tablet screen. I practically had to use the entire alphabet to have enough variable names.', 'aiModelVersion': '1'}",0.9743
Khalid Cawl,6y,Which programmer do you hire: the one who programs a messy program in three hours or the other who does a well-structured program in twelve?,"When I was doing my internship, we were given a 5 weeks long project. Before making any useful contributions to the company’s systems, we were asked to write a small demo app that would resemble some of the functionalities of their software (a very small subset). I had confidence in myself that I was a fast developer. I wanted to complete every new task as quickly as possible. The other intern (let us call him Fei) was quite slow, he would take a lot of time before writing any code. He would often delete huge chunks of code and rewrite it. Fei seemed to worry less about the deadline. We then had a meeting with the senior developers whereby we were asked to discuss the design of our code. My design was trivial (imagine a few GOD classes that did everything).

Fei’s design, on the other hand, was a thing of beauty. It seemed complicated and I didn’t understand it at the time, but he knew what he was doing. My mentor came to my desk after the meeting and recommended me to discuss with Fei and ask him why he did what he did and how it is different from my design. My mentor asked me how I would change my program if a requirement came that asked to draw shapes that can’t be colored or moved etc. I had learned that it would require a change in nearly every file that I wrote. Fei’s design? He showed me that he just needed to create an interface and plug it in here and there (dependency injection, anyone?).

I learned an important lesson that time. The fast developer will deliver you the requirement you want quickly and it might not even have any bugs. But unless it is a throw-away code, there will certainly be change of requirements. Applying those changes quickly and being able to do regression testing easily is something that will be almost impossible. This developer will leave you a pile of technical debt that will be made even worse by the future programmers of that project (because you are catching a deadline, right?).

Fei had two goals:

1. Write good quality code that is easily understandable

2. Write code that will be easy for others to change

I would hire Fei any day and fire myself.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ycf41qnvhra3k8jt', 'title': 'Which programmer do you hire: the one who programs a messy program in three hours or the other who does a well-structured program in twelve?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'When I was doing my internship, we were given a 5 weeks long project. Before making any useful contributions to the company’s systems, we were asked to write a small demo app that would resemble some of the functionalities of their software (a very small subset). I had confidence in myself that I was a fast developer. I wanted to complete every new task as quickly as possible. The other intern (let us call him Fei) was quite slow, he would take a lot of time before writing any code. He would often delete huge chunks of code and rewrite it. Fei seemed to worry less about the deadline. We then had a meeting with the senior developers whereby we were asked to discuss the design of our code. My design was trivial (imagine a few GOD classes that did everything).\n\nFei’s design, on the other hand, was a thing of beauty. It seemed complicated and I didn’t understand it at the time, but he knew what he was doing. My mentor came to my desk after the meeting and recommended me to discuss with Fei and ask him why he did what he did and how it is different from my design. My mentor asked me how I would change my program if a requirement came that asked to draw shapes that can’t be colored or moved etc. I had learned that it would require a change in nearly every file that I wrote. Fei’s design? He showed me that he just needed to create an interface and plug it in here and there (dependency injection, anyone?).\n\nI learned an important lesson that time. The fast developer will deliver you the requirement you want quickly and it might not even have any bugs. But unless it is a throw-away code, there will certainly be change of requirements. Applying those changes quickly and being able to do regression testing easily is something that will be almost impossible. This developer will leave you a pile of technical debt that will be made even worse by the future programmers of that project (because you are catching a deadline, right?).\n\nFei had two goals:\n\n1. Write good quality code that is easily understandable\n\n2. Write code that will be easy for others to change\n\nI would hire Fei any day and fire myself.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983963, 'subscription': 0, 'content': 'When I was doing my internship, we were given a 5 weeks long project. Before making any useful contributions to the company’s systems, we were asked to write a small demo app that would resemble some of the functionalities of their software (a very small subset). I had confidence in myself that I was a fast developer. I wanted to complete every new task as quickly as possible. The other intern (let us call him Fei) was quite slow, he would take a lot of time before writing any code. He would often delete huge chunks of code and rewrite it. Fei seemed to worry less about the deadline. We then had a meeting with the senior developers whereby we were asked to discuss the design of our code. My design was trivial (imagine a few GOD classes that did everything).\n\nFei’s design, on the other hand, was a thing of beauty. It seemed complicated and I didn’t understand it at the time, but he knew what he was doing. My mentor came to my desk after the meeting and recommended me to discuss with Fei and ask him why he did what he did and how it is different from my design. My mentor asked me how I would change my program if a requirement came that asked to draw shapes that can’t be colored or moved etc. I had learned that it would require a change in nearly every file that I wrote. Fei’s design? He showed me that he just needed to create an interface and plug it in here and there (dependency injection, anyone?).\n\nI learned an important lesson that time. The fast developer will deliver you the requirement you want quickly and it might not even have any bugs. But unless it is a throw-away code, there will certainly be change of requirements. Applying those changes quickly and being able to do regression testing easily is something that will be almost impossible. This developer will leave you a pile of technical debt that will be made even worse by the future programmers of that project (because you are catching a deadline, right?).\n\nFei had two goals:\n\n1. Write good quality code that is easily understandable\n\n2. Write code that will be easy for others to change\n\nI would hire Fei any day and fire myself.', 'aiModelVersion': '1'}",0.9995
Sibasish Ghosh,4y,What are the common mistakes made by beginner competitive programmers?,"Coding without any rough work.
Not solving problems out of your comfort zone and just sticking to easier problems.
Always looking for resources to learn new algorithms but being lazy enough to implement and practice the same.
Not reading the problem statement properly, especially the constraints.
Not reading the editorials.
Reading editorials but copy-pasting the solution without understanding it.
Not reading other’s codes.
Reading other’s code but copy-pasting the solution without understanding it.
Procrastinating rather than working on a problem.
Comparing your failure with other’s success.
Losing hope and cursing yourself that you aren’t made for this sport.

Hope this helps.

Happy Coding.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/nuow12xla0sdbf54', 'title': 'What are the common mistakes made by beginner competitive programmers?', 'score': {'original': 0.0122, 'ai': 0.9878}, 'blocks': [{'text': 'Coding without any rough work.\nNot solving problems out of your comfort zone and just sticking to easier problems.\nAlways looking for resources to learn new algorithms but being lazy enough to implement and practice the same.\nNot reading the problem statement properly, especially the constraints.\nNot reading the editorials.\nReading editorials but copy-pasting the solution without understanding it.\nNot reading other’s codes.\nReading other’s code but copy-pasting the solution without understanding it.\nProcrastinating rather than working on a problem.\nComparing your failure with other’s success.\nLosing hope and cursing yourself that you aren’t made for this sport.\n\nHope this helps.\n\nHappy Coding.', 'result': {'fake': 0.9878, 'real': 0.0122}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983961, 'subscription': 0, 'content': 'Coding without any rough work.\nNot solving problems out of your comfort zone and just sticking to easier problems.\nAlways looking for resources to learn new algorithms but being lazy enough to implement and practice the same.\nNot reading the problem statement properly, especially the constraints.\nNot reading the editorials.\nReading editorials but copy-pasting the solution without understanding it.\nNot reading other’s codes.\nReading other’s code but copy-pasting the solution without understanding it.\nProcrastinating rather than working on a problem.\nComparing your failure with other’s success.\nLosing hope and cursing yourself that you aren’t made for this sport.\n\nHope this helps.\n\nHappy Coding.', 'aiModelVersion': '1'}",0.0122
Reyansh Mishra,5y,"If almost everyone can learn programming for free, why is the salary relatively very high?","I can actually give you perfect analogy for it.

Consider the below image.

Now even if you have not studied civil engineering still you will be able to build it right? Almost anyone with basic knowledge and thinking can build this small little structure?

Now have a look at below image.

Now to build something like above takes a lot of knowledge experience.

So even if you can learn programming all by yourself but being good at it is really hard.

You get paid as a programmer just because of the skill you have doesn’t really matter how you acquired it.

|REY|","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/mw1jahtvce758sbu', 'title': 'If almost everyone can learn programming for free, why is the salary relatively very high?', 'score': {'original': 0.9989, 'ai': 0.0011}, 'blocks': [{'text': 'I can actually give you perfect analogy for it.\n\nConsider the below image.\n\nNow even if you have not studied civil engineering still you will be able to build it right? Almost anyone with basic knowledge and thinking can build this small little structure?\n\nNow have a look at below image.\n\nNow to build something like above takes a lot of knowledge experience.\n\nSo even if you can learn programming all by yourself but being good at it is really hard.\n\nYou get paid as a programmer just because of the skill you have doesn’t really matter how you acquired it.\n\n|REY|', 'result': {'fake': 0.0011, 'real': 0.9989}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983959, 'subscription': 0, 'content': 'I can actually give you perfect analogy for it.\n\nConsider the below image.\n\nNow even if you have not studied civil engineering still you will be able to build it right? Almost anyone with basic knowledge and thinking can build this small little structure?\n\nNow have a look at below image.\n\nNow to build something like above takes a lot of knowledge experience.\n\nSo even if you can learn programming all by yourself but being good at it is really hard.\n\nYou get paid as a programmer just because of the skill you have doesn’t really matter how you acquired it.\n\n|REY|', 'aiModelVersion': '1'}",0.9989
Dushka Zapata,6y,"If you could choose to be fluent in one additional language, what would it be?","Yes, please.

I would love to be fluent in another language, and my choice would be Sanskrit.

There are so many words in that language that I want to have a word for.

I want to greet another by saying “my spirit honors your spirit”. “I recognize the light inside of you because it’s also inside of me”. (Namaste.)

I so often feel happiness for someone else (mudita.)

And it’s so on point to consider that breath is energy; prana.

Knowing Sanskrit and integrating all the beautiful words it offers would shift my consciousness.

Until then, Lokah samastah sukhino bhavantu.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/dafxznr7cy2ov6j5', 'title': 'If you could choose to be fluent in one additional language, what would it be?', 'score': {'original': 0.9986, 'ai': 0.0014}, 'blocks': [{'text': 'Yes, please.\n\nI would love to be fluent in another language, and my choice would be Sanskrit.\n\nThere are so many words in that language that I want to have a word for.\n\nI want to greet another by saying “my spirit honors your spirit”. “I recognize the light inside of you because it’s also inside of me”. (Namaste.)\n\nI so often feel happiness for someone else (mudita.)\n\nAnd it’s so on point to consider that breath is energy; prana.\n\nKnowing Sanskrit and integrating all the beautiful words it offers would shift my consciousness.\n\nUntil then, Lokah samastah sukhino bhavantu.', 'result': {'fake': 0.0014, 'real': 0.9986}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983957, 'subscription': 0, 'content': 'Yes, please.\n\nI would love to be fluent in another language, and my choice would be Sanskrit.\n\nThere are so many words in that language that I want to have a word for.\n\nI want to greet another by saying “my spirit honors your spirit”. “I recognize the light inside of you because it’s also inside of me”. (Namaste.)\n\nI so often feel happiness for someone else (mudita.)\n\nAnd it’s so on point to consider that breath is energy; prana.\n\nKnowing Sanskrit and integrating all the beautiful words it offers would shift my consciousness.\n\nUntil then, Lokah samastah sukhino bhavantu.', 'aiModelVersion': '1'}",0.9986
Dave Voorhis,3y,How long did it take for you to feel like you were no longer a beginner in computer programming?,"I’ve been programming for over forty years, and I’m hoping the “beginner” feeling will pass in a decade or so.

Actually, it kind of comes and goes in waves, like nausea.

I’ll be working on a thing, and I’ll be thinking to myself, oh god, why doesn’t this work? IT’S SO SIMPLE. Why aren’t the foo instances being retrieved from fooContainerPrimary? I’M PUTTING THEM IN RIGHT HERE!!! I must be an idiot. That’s it — I’m an idiot. A useless idiot. A rank beginner, noob, brainless, IDIOT! I shouldn’t even be here. I AM FUCKING USELESS!! I should just get up, leave my laptop behind so someone can have a laptop, and get a job at the coffee shop across the street. Except I’d SUCK AT THAT TOO. Oh god why did I ever think I could be a programmer? I AM WORTHLESS FILTH! I AM SCUM! I AM WORSE THAN WORTHLE-

Oh, wait. The foo instances are in fooContainerSecondary, not fooContainerPrimary. I’ll just change the reference… [*type type type*] …here, and run tests again and…

I AM GOD! I AM THE GOD OF PROGRAMMMING! I ROCK! I ROOOOOCKKK!!!! [*insert vulgar hip-thrust motions here*] UNGH! YEAH! TAKE THAT, CODE! TAKE THAT AND THAT AND THAT! THAT’S ME DOING YOU, CODE! I MAKE OPERATING SYSTEMS IN MY SLEEP! I FART OUT ALGORITHMS! I OWN THIS!!!! I AM TH-

…Oh…

…why isn’t the last test passing?

WHY IS IT NOT WORKING?!?? WHAT KIND OF WORTHLESS, INFANTILE, IDIOTIC FLOORWIPE SCUM WOULDN’T BE ABLE TO GET THIS TRIVIAL BEGINNER CODE WORKING??!? WHY CAN’T I DO THIS??!?? … .. .

And so on.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/zxsmvl0651j94ht2', 'title': 'How long did it take for you to feel like you were no longer a beginner in computer programming?', 'score': {'original': 0.9991, 'ai': 0.0009}, 'blocks': [{'text': 'I’ve been programming for over forty years, and I’m hoping the “beginner” feeling will pass in a decade or so.\n\nActually, it kind of comes and goes in waves, like nausea.\n\nI’ll be working on a thing, and I’ll be thinking to myself, oh god, why doesn’t this work? IT’S SO SIMPLE. Why aren’t the foo instances being retrieved from fooContainerPrimary? I’M PUTTING THEM IN RIGHT HERE!!! I must be an idiot. That’s it — I’m an idiot. A useless idiot. A rank beginner, noob, brainless, IDIOT! I shouldn’t even be here. I AM FUCKING USELESS!! I should just get up, leave my laptop behind so someone can have a laptop, and get a job at the coffee shop across the street. Except I’d SUCK AT THAT TOO. Oh god why did I ever think I could be a programmer? I AM WORTHLESS FILTH! I AM SCUM! I AM WORSE THAN WORTHLE-\n\nOh, wait. The foo instances are in fooContainerSecondary, not fooContainerPrimary. I’ll just change the reference… [*type type type*] …here, and run tests again and…\n\nI AM GOD! I AM THE GOD OF PROGRAMMMING! I ROCK! I ROOOOOCKKK!!!! [*insert vulgar hip-thrust motions here*] UNGH! YEAH! TAKE THAT, CODE! TAKE THAT AND THAT AND THAT! THAT’S ME DOING YOU, CODE! I MAKE OPERATING SYSTEMS IN MY SLEEP! I FART OUT ALGORITHMS! I OWN THIS!!!! I AM TH-\n\n…Oh…\n\n…why isn’t the last test passing?\n\nWHY IS IT NOT WORKING?!?? WHAT KIND OF WORTHLESS, INFANTILE, IDIOTIC FLOORWIPE SCUM WOULDN’T BE ABLE TO GET THIS TRIVIAL BEGINNER CODE WORKING??!? WHY CAN’T I DO THIS??!?? … .. .\n\nAnd so on.', 'result': {'fake': 0.0009, 'real': 0.9991}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983954, 'subscription': 0, 'content': 'I’ve been programming for over forty years, and I’m hoping the “beginner” feeling will pass in a decade or so.\n\nActually, it kind of comes and goes in waves, like nausea.\n\nI’ll be working on a thing, and I’ll be thinking to myself, oh god, why doesn’t this work? IT’S SO SIMPLE. Why aren’t the foo instances being retrieved from fooContainerPrimary? I’M PUTTING THEM IN RIGHT HERE!!! I must be an idiot. That’s it — I’m an idiot. A useless idiot. A rank beginner, noob, brainless, IDIOT! I shouldn’t even be here. I AM FUCKING USELESS!! I should just get up, leave my laptop behind so someone can have a laptop, and get a job at the coffee shop across the street. Except I’d SUCK AT THAT TOO. Oh god why did I ever think I could be a programmer? I AM WORTHLESS FILTH! I AM SCUM! I AM WORSE THAN WORTHLE-\n\nOh, wait. The foo instances are in fooContainerSecondary, not fooContainerPrimary. I’ll just change the reference… [*type type type*] …here, and run tests again and…\n\nI AM GOD! I AM THE GOD OF PROGRAMMMING! I ROCK! I ROOOOOCKKK!!!! [*insert vulgar hip-thrust motions here*] UNGH! YEAH! TAKE THAT, CODE! TAKE THAT AND THAT AND THAT! THAT’S ME DOING YOU, CODE! I MAKE OPERATING SYSTEMS IN MY SLEEP! I FART OUT ALGORITHMS! I OWN THIS!!!! I AM TH-\n\n…Oh…\n\n…why isn’t the last test passing?\n\nWHY IS IT NOT WORKING?!?? WHAT KIND OF WORTHLESS, INFANTILE, IDIOTIC FLOORWIPE SCUM WOULDN’T BE ABLE TO GET THIS TRIVIAL BEGINNER CODE WORKING??!? WHY CAN’T I DO THIS??!?? … .. .\n\nAnd so on.', 'aiModelVersion': '1'}",0.9991
Dmitry Murashenkov,Updated 5y,What's the best code you've seen a professional programmer write? How does it compare to the average programmer?,"Professional programmer’s code:

//Here we address strange issue that was seen on 
//production a few times, but is not reproduced  
//localy. User can be mysteriously logged out after 
//clicking Back button. This seems related to recent 
//changes to redirect scheme upon order confirmation. 
login(currentUser()); 

Average programmer’s code:

//Hotfix - don't ask 
login(currentUser()); 

Professional programmer’s commit message:

Fix memory leak in connection pool 
 
We've seen connections leaking from the pool 
if any query had already been executed through 
it and then exception is thrown. 
 
The root causes was found in ConnectionPool.addExceptionHook() 
method that ignored certain types of exceptions. 

Average programmer’s commit message:

Small fix 

Professional programmer’s test naming:

login_shouldThrowUserNotFoundException_ifUserAbsentInDB() 
login_shouldSetCurrentUser_ifLoginSuccessfull() 
login_shouldRecordAuditMessage_uponUnsuccessfullLogin() 

Average programmer’s test naming:

testLogin1() 
testLogin2() 
testLogin3() 

After first few years of programming, when the urge to put some cool looking construct only you can understand into every block of code wears off, you’ll likely come to the conclusion that these examples are actually the code you want to encounter when opening a new project.

If we look at the apps written by good vs average programmers (not talking about total beginners) the code itself is not that much different, but if small conveniences everywhere allow you to avoid frustration while reading it - it is likely written by a professional.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/hfguydiae4jov82s', 'title': ""What's the best code you've seen a professional programmer write? How does it compare to the average programmer?"", 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': ""Professional programmer’s code:\n\n//Here we address strange issue that was seen on\xa0\n//production a few times, but is not reproduced \xa0\n//localy. User can be mysteriously logged out after\xa0\n//clicking Back button. This seems related to recent\xa0\n//changes to redirect scheme upon order confirmation.\xa0\nlogin(currentUser());\xa0\n\nAverage programmer’s code:\n\n//Hotfix - don't ask\xa0\nlogin(currentUser());\xa0\n\nProfessional programmer’s commit message:\n\nFix memory leak in connection pool\xa0\n\xa0\nWe've seen connections leaking from the pool\xa0\nif any query had already been executed through\xa0\nit and then exception is thrown.\xa0\n\xa0\nThe root causes was found in ConnectionPool.addExceptionHook()\xa0\nmethod that ignored certain types of exceptions.\xa0\n\nAverage programmer’s commit message:\n\nSmall fix\xa0\n\nProfessional programmer’s test naming:\n\nlogin_shouldThrowUserNotFoundException_ifUserAbsentInDB()\xa0\nlogin_shouldSetCurrentUser_ifLoginSuccessfull()\xa0\nlogin_shouldRecordAuditMessage_uponUnsuccessfullLogin()\xa0\n\nAverage programmer’s test naming:\n\ntestLogin1()\xa0\ntestLogin2()\xa0\ntestLogin3()\xa0\n\nAfter first few years of programming, when the urge to put some cool looking construct only you can understand into every block of code wears off, you’ll likely come to the conclusion that these examples are actually the code you want to encounter when opening a new project.\n\nIf we look at the apps written by good vs average programmers (not talking about total beginners) the code itself is not that much different, but if small conveniences everywhere allow you to avoid frustration while reading it - it is likely written by a professional."", 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983951, 'subscription': 0, 'content': ""Professional programmer’s code:\n\n//Here we address strange issue that was seen on\xa0\n//production a few times, but is not reproduced \xa0\n//localy. User can be mysteriously logged out after\xa0\n//clicking Back button. This seems related to recent\xa0\n//changes to redirect scheme upon order confirmation.\xa0\nlogin(currentUser());\xa0\n\nAverage programmer’s code:\n\n//Hotfix - don't ask\xa0\nlogin(currentUser());\xa0\n\nProfessional programmer’s commit message:\n\nFix memory leak in connection pool\xa0\n\xa0\nWe've seen connections leaking from the pool\xa0\nif any query had already been executed through\xa0\nit and then exception is thrown.\xa0\n\xa0\nThe root causes was found in ConnectionPool.addExceptionHook()\xa0\nmethod that ignored certain types of exceptions.\xa0\n\nAverage programmer’s commit message:\n\nSmall fix\xa0\n\nProfessional programmer’s test naming:\n\nlogin_shouldThrowUserNotFoundException_ifUserAbsentInDB()\xa0\nlogin_shouldSetCurrentUser_ifLoginSuccessfull()\xa0\nlogin_shouldRecordAuditMessage_uponUnsuccessfullLogin()\xa0\n\nAverage programmer’s test naming:\n\ntestLogin1()\xa0\ntestLogin2()\xa0\ntestLogin3()\xa0\n\nAfter first few years of programming, when the urge to put some cool looking construct only you can understand into every block of code wears off, you’ll likely come to the conclusion that these examples are actually the code you want to encounter when opening a new project.\n\nIf we look at the apps written by good vs average programmers (not talking about total beginners) the code itself is not that much different, but if small conveniences everywhere allow you to avoid frustration while reading it - it is likely written by a professional."", 'aiModelVersion': '1'}",0.9995
Gavin Thorn,6y,What are some of the most basic things every programmer should know?,"If it's not tested, it doesn't work.
Source control is your friend - make sure you use it.
Just because you wrote it doesn't mean you own it — don't be offended if someone else on your team has to change your code.
Don't reinvent the wheel, library code is there to help.
The fastest code is code that's never executed — look for early outs.
Just because you didn't write it doesn't mean it's crap.
Source code is just a hint to the compiler about what you want to do, it won't necessarily do it (e.g. You might declare a function as inline but the compiler doesn't have to obey).
Code that's hard to understand is hard to maintain.
Code that's hard to maintain is next to useless.
“Whilst I'm editing this file I’ll just…” is a great way to introduce feature creep and bugs.
The neater your code layout, the easier it is to read. The easier it is to read, the easier it is to understand and maintain.
Code is not self documenting. Help others by adding comments to guide them. You may understand it now but what about in 5 years time?
Bad Code can and will come back to haunt you.
There is no such thing as a 5 minute job. It'll always take at least half a day.
Magic numbers are bad.
Constants don't take up storage, they're compile time text substitutions.
Project management will always want you to do twice as much in half the time.
If there is a bug, the user will find it.
A code review is not a criticism.
It's not the quantity of code that matters, it's the quality. Any idiot can bang out 40kloc but that doesn't make it fit for purpose.
The true cost of poorly written code is in the maintenance.
Eat your own dog food — fixing bugs in your own code helps you code better and improves your understanding.
Code rots over time.
If the user didn't ask for a feature, don't add it.
If it's not tested, it doesn't work (yes, I know I've included that twice but it's really important).","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/w5kbnm12rh9xvi63', 'title': 'What are some of the most basic things every programmer should know?', 'score': {'original': 0.9992, 'ai': 0.0008}, 'blocks': [{'text': ""If it's not tested, it doesn't work.\nSource control is your friend - make sure you use it.\nJust because you wrote it doesn't mean you own it — don't be offended if someone else on your team has to change your code.\nDon't reinvent the wheel, library code is there to help.\nThe fastest code is code that's never executed — look for early outs.\nJust because you didn't write it doesn't mean it's crap.\nSource code is just a hint to the compiler about what you want to do, it won't necessarily do it (e.g. You might declare a function as inline but the compiler doesn't have to obey).\nCode that's hard to understand is hard to maintain.\nCode that's hard to maintain is next to useless.\n“Whilst I'm editing this file I’ll just…” is a great way to introduce feature creep and bugs.\nThe neater your code layout, the easier it is to read. The easier it is to read, the easier it is to understand and maintain.\nCode is not self documenting. Help others by adding comments to guide them. You may understand it now but what about in 5 years time?\nBad Code can and will come back to haunt you.\nThere is no such thing as a 5 minute job. It'll always take at least half a day.\nMagic numbers are bad.\nConstants don't take up storage, they're compile time text substitutions.\nProject management will always want you to do twice as much in half the time.\nIf there is a bug, the user will find it.\nA code review is not a criticism.\nIt's not the quantity of code that matters, it's the quality. Any idiot can bang out 40kloc but that doesn't make it fit for purpose.\nThe true cost of poorly written code is in the maintenance.\nEat your own dog food — fixing bugs in your own code helps you code better and improves your understanding.\nCode rots over time.\nIf the user didn't ask for a feature, don't add it.\nIf it's not tested, it doesn't work (yes, I know I've included that twice but it's really important)."", 'result': {'fake': 0.0008, 'real': 0.9992}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983947, 'subscription': 0, 'content': ""If it's not tested, it doesn't work.\nSource control is your friend - make sure you use it.\nJust because you wrote it doesn't mean you own it — don't be offended if someone else on your team has to change your code.\nDon't reinvent the wheel, library code is there to help.\nThe fastest code is code that's never executed — look for early outs.\nJust because you didn't write it doesn't mean it's crap.\nSource code is just a hint to the compiler about what you want to do, it won't necessarily do it (e.g. You might declare a function as inline but the compiler doesn't have to obey).\nCode that's hard to understand is hard to maintain.\nCode that's hard to maintain is next to useless.\n“Whilst I'm editing this file I’ll just…” is a great way to introduce feature creep and bugs.\nThe neater your code layout, the easier it is to read. The easier it is to read, the easier it is to understand and maintain.\nCode is not self documenting. Help others by adding comments to guide them. You may understand it now but what about in 5 years time?\nBad Code can and will come back to haunt you.\nThere is no such thing as a 5 minute job. It'll always take at least half a day.\nMagic numbers are bad.\nConstants don't take up storage, they're compile time text substitutions.\nProject management will always want you to do twice as much in half the time.\nIf there is a bug, the user will find it.\nA code review is not a criticism.\nIt's not the quantity of code that matters, it's the quality. Any idiot can bang out 40kloc but that doesn't make it fit for purpose.\nThe true cost of poorly written code is in the maintenance.\nEat your own dog food — fixing bugs in your own code helps you code better and improves your understanding.\nCode rots over time.\nIf the user didn't ask for a feature, don't add it.\nIf it's not tested, it doesn't work (yes, I know I've included that twice but it's really important)."", 'aiModelVersion': '1'}",0.9992
Dr. Balaji Viswanathan,4y,"If almost everyone can learn programming for free, why is the salary relatively very high?","If almost everyone can run, why is Usain Bolt so highly paid?

If almost everyone can paint, why is Picasso so highly valued?

Highly paid programmers are like top notch athletes and artists — they have a mastery over their skill.

When I got into college I asked a senior a question — now that everyone has a Java book, would programming be commoditized. He said while everyone can learn basic Java syntax, only the very best can convert that syntax & commands to solve a customer problem.

Just as anyone can run, anyone can write a basic program and run:

python myfirstprogram.py 

No one is going to pay someone for that. From there to be able to grow up to build your own unique art, that requires a lot of intelligence, patience, perseverance and practice. People pay high salaries for that.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/j32ts9ywagfmo8eq', 'title': 'If almost everyone can learn programming for free, why is the salary relatively very high?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'If almost everyone can run, why is Usain Bolt so highly paid?\n\nIf almost everyone can paint, why is Picasso so highly valued?\n\nHighly paid programmers are like top notch athletes and artists — they have a mastery over their skill.\n\nWhen I got into college I asked a senior a question — now that everyone has a Java book, would programming be commoditized. He said while everyone can learn basic Java syntax, only the very best can convert that syntax & commands to solve a customer problem.\n\nJust as anyone can run, anyone can write a basic program and run:\n\npython myfirstprogram.py \n\nNo one is going to pay someone for that. From there to be able to grow up to build your own unique art, that requires a lot of intelligence, patience, perseverance and practice. People pay high salaries for that.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983945, 'subscription': 0, 'content': 'If almost everyone can run, why is Usain Bolt so highly paid?\n\nIf almost everyone can paint, why is Picasso so highly valued?\n\nHighly paid programmers are like top notch athletes and artists — they have a mastery over their skill.\n\nWhen I got into college I asked a senior a question — now that everyone has a Java book, would programming be commoditized. He said while everyone can learn basic Java syntax, only the very best can convert that syntax & commands to solve a customer problem.\n\nJust as anyone can run, anyone can write a basic program and run:\n\npython myfirstprogram.py \n\nNo one is going to pay someone for that. From there to be able to grow up to build your own unique art, that requires a lot of intelligence, patience, perseverance and practice. People pay high salaries for that.', 'aiModelVersion': '1'}",0.9996
Harish Shivaraman,9y,What is the best comment in source code that you have ever encountered?,"Go to Flipkart's website right now and right click on the homepage. Select Inspect Element which opens up the Chrome Developer Tool window. Click on ""Console"" and you'll be seeing this :   A closer view :  I find this cool. What do you think  ?","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/xaq8s6j32c0r4geb', 'title': 'What is the best comment in source code that you have ever encountered?', 'score': {'original': 0.9944, 'ai': 0.0056}, 'blocks': [{'text': 'Go to Flipkart\'s website right now and right click on the homepage. Select Inspect Element which opens up the Chrome Developer Tool window. Click on ""Console"" and you\'ll be seeing this :   A closer view :  I find this cool. What do you think  ?', 'result': {'fake': 0.0089, 'real': 0.9911}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983944, 'subscription': 0, 'content': 'Go to Flipkart\'s website right now and right click on the homepage. Select Inspect Element which opens up the Chrome Developer Tool window. Click on ""Console"" and you\'ll be seeing this :   A closer view :  I find this cool. What do you think  ?', 'aiModelVersion': '1'}",0.9944
Richard Muller,Updated 6y,Is coding really boring and hard?,"Coding is the ultimate computer game. It is you vs. the computer. You are trying to enslave it, to get it to do exactly what you want it to do. It resists in every way possible; it is worse than a teenager at finding tiny little minuscule things you didn’t get precisely right and using them to defeat you. Sometimes they hide what they did and it is your struggle to find it and correct it.

Then the ultimate joy: your program runs, and gives an answer that looks right (but it might not be exactly what you expected). You’ve won! You enslaved the computer, if only on this one task. You defeated it! Congratulations! Show your friends. Celebrate.

Coding is certainly hard. But it is never boring.

Time to move on to the next level, and to program something more challenging.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/sndzhvwlbxq3fgp7', 'title': 'Is coding really boring and hard?', 'score': {'original': 0.1565, 'ai': 0.8435}, 'blocks': [{'text': 'Coding is the ultimate computer game. It is you vs. the computer. You are trying to enslave it, to get it to do exactly what you want it to do. It resists in every way possible; it is worse than a teenager at finding tiny little minuscule things you didn’t get precisely right and using them to defeat you. Sometimes they hide what they did and it is your struggle to find it and correct it.\n\nThen the ultimate joy: your program runs, and gives an answer that looks right (but it might not be exactly what you expected). You’ve won! You enslaved the computer, if only on this one task. You defeated it! Congratulations! Show your friends. Celebrate.\n\nCoding is certainly hard. But it is never boring.\n\nTime to move on to the next level, and to program something more challenging.', 'result': {'fake': 0.8435, 'real': 0.1565}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983942, 'subscription': 0, 'content': 'Coding is the ultimate computer game. It is you vs. the computer. You are trying to enslave it, to get it to do exactly what you want it to do. It resists in every way possible; it is worse than a teenager at finding tiny little minuscule things you didn’t get precisely right and using them to defeat you. Sometimes they hide what they did and it is your struggle to find it and correct it.\n\nThen the ultimate joy: your program runs, and gives an answer that looks right (but it might not be exactly what you expected). You’ve won! You enslaved the computer, if only on this one task. You defeated it! Congratulations! Show your friends. Celebrate.\n\nCoding is certainly hard. But it is never boring.\n\nTime to move on to the next level, and to program something more challenging.', 'aiModelVersion': '1'}",0.1565
Andrew McGregor,3y,What happens if I created a pointer in C++ and ran the program but forgot to delete it? Will the pointer occupy a space in the RAM forever? I fear that after running multiple projects and not deleting the pointers afterward my PC will run out of RAM.,"One of the jobs of an operating system is to free up all the resources a program used when it exits.

Exit the program, ALL the memory it was using is reclaimed. If that doesn’t happen, there’s a bug in the operating system, not in your program.

Don’t worry about it for this reason. It’s perfectly OK to allocate things that you are going to keep for the entire life of the program and never deallocate them.

But if you’re writing a server, or anything that you expect to run for a long time… do clean up your memory. Failing to do so is a memory leak, and while it won’t hurt the OS, it can hurt your own program.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/sv2w9z4xqoyhpnmi', 'title': 'What happens if I created a pointer in C++ and ran the program but forgot to delete it? Will the pointer occupy a space in the RAM forever? I fear that after running multiple projects and not deleting the pointers afterward my PC will run out of RAM.', 'score': {'original': 0.9337, 'ai': 0.0663}, 'blocks': [{'text': 'One of the jobs of an operating system is to free up all the resources a program used when it exits.\n\nExit the program, ALL the memory it was using is reclaimed. If that doesn’t happen, there’s a bug in the operating system, not in your program.\n\nDon’t worry about it for this reason. It’s perfectly OK to allocate things that you are going to keep for the entire life of the program and never deallocate them.\n\nBut if you’re writing a server, or anything that you expect to run for a long time… do clean up your memory. Failing to do so is a memory leak, and while it won’t hurt the OS, it can hurt your own program.', 'result': {'fake': 0.0663, 'real': 0.9337}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983940, 'subscription': 0, 'content': 'One of the jobs of an operating system is to free up all the resources a program used when it exits.\n\nExit the program, ALL the memory it was using is reclaimed. If that doesn’t happen, there’s a bug in the operating system, not in your program.\n\nDon’t worry about it for this reason. It’s perfectly OK to allocate things that you are going to keep for the entire life of the program and never deallocate them.\n\nBut if you’re writing a server, or anything that you expect to run for a long time… do clean up your memory. Failing to do so is a memory leak, and while it won’t hurt the OS, it can hurt your own program.', 'aiModelVersion': '1'}",0.9337
Steve Baker,5y,"Why is C++ so much faster than Javascript, but harder to code?","C++ is much faster than JavaScript because:

C++ is a fully compiled language - so there is no runtime parsing of source code and no “just in time” compilation cost.
C++ uses fixed types - so “i=6” means “stick this number into this location in memory” - which is one machine-code instruction. In JavaScript “i” could be a float or an integer or a string or god-alone-knows-what-else - and what it is might have changed between the first time the instruction was run and subsequent times. So every single stupid assignment has to go through who-knows-what overheads of type checking and conversion.
C++ does not use “garbage collection” - which basically requires JavaScript to periodically stop - and look at EVERY reference to an allocated memory block to see if it’s no longer needed. In C++ the programmer tells the system “I’m done with this block of memory now”.

There are other reasons too - but this is enough.

C++ is harder to code for pretty much those same exact reasons.

C++ is compiled - so you can’t just finish typing code and hit “RUN” - first the code has to be compiled and linked - which takes time.
C++ is a strongly typed language - so you have to carefully consider whether something is a string or an integer or whatever - and code accordingly. You have to manually convert between types as needed.
C++ does not use “garbage collection” and if you forget to free up allocated space - or if you do something stupid like freeing it twice - or trying to access it after you free’d it - then you get into a whole world of “interesting bugs” that just cannot happen in JavaScript.

…and there are other reasons here too.

The two languages are designed for ENTIRELY different purposes.

JavaScript was meant for doing VERY simple (eg 10 lines of code) things to HTML documents - “Make this image pop up when I click that button”. C++ was designed for writing compilers, operating systems (Javascript interpreters!) - for “million lines of code” applications like video games, CAD software, browsers, etc.
JavaScript was meant to be easier for novice programmers - it’s actually fairly simple. C++ makes no such pretensions. C++ is by FAR the most complicated language on the planet.
JavaScript helps novices by providing warm, friendly messages. C++ is like leading a blind man through a minefield and then pushing him into an alligator infested swamp! Literally the only error message the C++ system ever gives you is a core dump of your code!
JavaScript has to be bomb-proof…it must be COMPLETELY impossible to write a JavaScript program that breaks out of the sandbox. C++ absolutely allows you to do anything you want to the computer…there is ZERO protection of any kind.

C++ is a powerful, precision tool - intended to be wielded with extreme care by experts. JavaScript is not.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ve5i24kh63ysfnwd', 'title': 'Why is C++ so much faster than Javascript, but harder to code?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'C++ is much faster than JavaScript because:\n\nC++ is a fully compiled language - so there is no runtime parsing of source code and no “just in time” compilation cost.\nC++ uses fixed types - so “i=6” means “stick this number into this location in memory” - which is one machine-code instruction. In JavaScript “i” could be a float or an integer or a string or god-alone-knows-what-else - and what it is might have changed between the first time the instruction was run and subsequent times. So every single stupid assignment has to go through who-knows-what overheads of type checking and conversion.\nC++ does not use “garbage collection” - which basically requires JavaScript to periodically stop - and look at EVERY reference to an allocated memory block to see if it’s no longer needed. In C++ the programmer tells the system “I’m done with this block of memory now”.\n\nThere are other reasons too - but this is enough.\n\nC++ is harder to code for pretty much those same exact reasons.\n\nC++ is compiled - so you can’t just finish typing code and hit “RUN” - first the code has to be compiled and linked - which takes time.\nC++ is a strongly typed language - so you have to carefully consider whether something is a string or an integer or whatever - and code accordingly. You have to manually convert between types as needed.\nC++ does not use “garbage collection” and if you forget to free up allocated space - or if you do something stupid like freeing it twice - or trying to access it after you free’d it - then you get into a whole world of “interesting bugs” that just cannot happen in JavaScript.\n\n…and there are other reasons here too.\n\nThe two languages are designed for ENTIRELY different purposes.\n\nJavaScript was meant for doing VERY simple (eg 10 lines of code) things to HTML documents - “Make this image pop up when I click that button”. C++ was designed for writing compilers, operating systems (Javascript interpreters!) - for “million lines of code” applications like video games, CAD software, browsers, etc.\nJavaScript was meant to be easier for novice programmers - it’s actually fairly simple. C++ makes no such pretensions. C++ is by FAR the most complicated language on the planet.\nJavaScript helps novices by providing warm, friendly messages. C++ is like leading a blind man through a minefield and then pushing him into an alligator infested swamp! Literally the only error message the C++ system ever gives you is a core dump of your code!\nJavaScript has to be bomb-proof…it must be COMPLETELY impossible to write a JavaScript program that breaks out of the sandbox. C++ absolutely allows you to do anything you want to the computer…there is ZERO protection of any kind.\n\nC++ is a powerful, precision tool - intended to be wielded with extreme care by experts. JavaScript is not.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983935, 'subscription': 0, 'content': 'C++ is much faster than JavaScript because:\n\nC++ is a fully compiled language - so there is no runtime parsing of source code and no “just in time” compilation cost.\nC++ uses fixed types - so “i=6” means “stick this number into this location in memory” - which is one machine-code instruction. In JavaScript “i” could be a float or an integer or a string or god-alone-knows-what-else - and what it is might have changed between the first time the instruction was run and subsequent times. So every single stupid assignment has to go through who-knows-what overheads of type checking and conversion.\nC++ does not use “garbage collection” - which basically requires JavaScript to periodically stop - and look at EVERY reference to an allocated memory block to see if it’s no longer needed. In C++ the programmer tells the system “I’m done with this block of memory now”.\n\nThere are other reasons too - but this is enough.\n\nC++ is harder to code for pretty much those same exact reasons.\n\nC++ is compiled - so you can’t just finish typing code and hit “RUN” - first the code has to be compiled and linked - which takes time.\nC++ is a strongly typed language - so you have to carefully consider whether something is a string or an integer or whatever - and code accordingly. You have to manually convert between types as needed.\nC++ does not use “garbage collection” and if you forget to free up allocated space - or if you do something stupid like freeing it twice - or trying to access it after you free’d it - then you get into a whole world of “interesting bugs” that just cannot happen in JavaScript.\n\n…and there are other reasons here too.\n\nThe two languages are designed for ENTIRELY different purposes.\n\nJavaScript was meant for doing VERY simple (eg 10 lines of code) things to HTML documents - “Make this image pop up when I click that button”. C++ was designed for writing compilers, operating systems (Javascript interpreters!) - for “million lines of code” applications like video games, CAD software, browsers, etc.\nJavaScript was meant to be easier for novice programmers - it’s actually fairly simple. C++ makes no such pretensions. C++ is by FAR the most complicated language on the planet.\nJavaScript helps novices by providing warm, friendly messages. C++ is like leading a blind man through a minefield and then pushing him into an alligator infested swamp! Literally the only error message the C++ system ever gives you is a core dump of your code!\nJavaScript has to be bomb-proof…it must be COMPLETELY impossible to write a JavaScript program that breaks out of the sandbox. C++ absolutely allows you to do anything you want to the computer…there is ZERO protection of any kind.\n\nC++ is a powerful, precision tool - intended to be wielded with extreme care by experts. JavaScript is not.', 'aiModelVersion': '1'}",0.9997
Amin Ariana,Updated 8y,How do programming experts learn deep details in programming languages and architectures that you can't find in books and online tutorials?,"We lived in terrible economic times when I turned 4. Kids in my neighborhood rode bicycles in the street and seemed to enjoy each others' company without a second thought spared on how to bike. I wanted to learn. Biking seemed like so much fun. I wanted to be just like them.

So for about two or three years, I asked my mom, dad, uncle, aunt, cousins, friends, and everyone else about all the intricacies of biking. I watched cartoons about biking. Scenes in movies with bikes in them jumped out at me. In the car, I'd ask my dad to slow down when bikers could be watched.

One day I walked into my room. A red bike greeted me with surprise. I ran and hugged my parents; they smiled. Then I took the bike out to practice my years of obsessive learning. I got on the seat, grabbed both handle bars, put my foot on the pedal and ... crashed to the floor!

I knew nothing.

The upset washed over me and I started practicing. You know when I learned how to bike? That same day. Biking doesn't involve logic; it involves muscles.


Years later, the same thing happened with programming. I did a bachelor in Computer Science, but didn't learn how to build a proper application after four years. There just seemed to be too many intricacies; too many questions to ask; too many books to read.

So I got fed up and just installed Visual Studio in Windows (back in the day). A week later, I was OK in C#. A month later, I'd ask questions that wouldn't occur to those who used it for their day job. Six months later, I dumped all my books but one, by just glancing over their tables of content and rejecting them for interest. You don't need books to learn how to bike.


Five years into a C# career, I moved to Silicon Valley for a C# job. The market there didn't like C#, so one of my main concerns became learning an open source language. For a few years I aimlessly bought books on Ruby, Python, etc. and toyed with getting a stable environment up on Windows. Never did it stand up on its own.

When my company turned unstable, I finally decided to put aside my hesitation to spend on a MacBook. They don't sell one in red, or I would have bought it in bicycle red. The first day I installed Ruby on a Mac, I learned about 20% of what I know today. It just happened. In six months, I had a fully working platform built in Ruby. To learn to bike, you just need to go ahead and get the damn bike.

But a fascinating day arrived after two years:


A deep gnarly concurrency bug in some Capybara integration test prevented my code from passing the suite of tests consistently. Flakey test. Sending commits past the continuous integration into production turned into a crapshoot game. The deadline marched closer. For 48 hours I couldn't find my way out of this nightmare; just couldn't! I poured over Stack Overflow, praying for an answer from God to this extremely rare situation.

An odd number of hours into the night, I came across the exact right answer: an irrelevant question posed an adjacent problem; someone gave a partial answer, and a commenter pointed out the corner case causing a testing bug, and how to avoid it.

I wrapped up my bug at 3 am, with one day remaining till the deadline to iterate without flakey tests interrupting. Thank God the other person knew more than I did. I found it only appropriate to go back to upvote and thank the commenter from Stack Overflow. He wrote the comment two years ago, so maybe he wouldn't notice my message of gratitude, I thought. So I checked his name. His name ... mine!


A programmer gets lost in the logical branches of complexity that he himself creates. Deep learning solves by putting the unlearned on the bicycle.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/y8jr6vh9d15wfens', 'title': ""How do programming experts learn deep details in programming languages and architectures that you can't find in books and online tutorials?"", 'score': {'original': 0.2312, 'ai': 0.7688}, 'blocks': [{'text': ""We lived in terrible economic times when I turned 4. Kids in my neighborhood rode bicycles in the street and seemed to enjoy each others' company without a second thought spared on how to bike. I wanted to learn. Biking seemed like so much fun. I wanted to be just like them.\n\nSo for about two or three years, I asked my mom, dad, uncle, aunt, cousins, friends, and everyone else about all the intricacies of biking. I watched cartoons about biking. Scenes in movies with bikes in them jumped out at me. In the car, I'd ask my dad to slow down when bikers could be watched.\n\nOne day I walked into my room. A red bike greeted me with surprise. I ran and hugged my parents; they smiled. Then I took the bike out to practice my years of obsessive learning. I got on the seat, grabbed both handle bars, put my foot on the pedal and ... crashed to the floor!\n\nI knew nothing.\n\nThe upset washed over me and I started practicing. You know when I learned how to bike? That same day. Biking doesn't involve logic; it involves muscles.\n\n\nYears later, the same thing happened with programming. I did a bachelor in Computer Science, but didn't learn how to build a proper application after four years. There just seemed to be too many intricacies; too many questions to ask; too many books to read.\n\nSo I got fed up and just installed Visual Studio in Windows (back in the day). A week later, I was OK in C#. A month later, I'd ask questions that wouldn't occur to those who used it for their day job. Six months later, I dumped all my books but one, by just glancing over their tables of content and rejecting them for interest. You don't need books to learn how to bike.\n\n\nFive years into a C# career, I moved to Silicon Valley for a C# job. The market there didn't like C#, so one of my main concerns became learning an open source language. For a few years I aimlessly bought books on Ruby, Python, etc. and toyed with getting a stable environment up on Windows. Never did it stand up on its own.\n\nWhen my company turned unstable, I finally decided to put aside my hesitation to spend on a MacBook. They don't sell one in red, or I would have bought it in bicycle red. The first day I installed Ruby on a Mac, I learned about 20% of what I know today. It just happened. In six months, I had a fully working platform built in Ruby. To learn to bike, you just need to go ahead and get the damn bike.\n\nBut a fascinating day arrived after two years:\n\n\nA deep gnarly concurrency bug in some Capybara integration test prevented my code from passing the suite of tests consistently. Flakey test. Sending commits past the continuous integration into production turned into a crapshoot game. The deadline marched closer. For 48 hours I couldn't find my way out of this nightmare; just couldn't! I poured over Stack"", 'result': {'fake': 0.7935, 'real': 0.2065}, 'status': 'success'}, {'text': ""Overflow, praying for an answer from God to this extremely rare situation.\n\nAn odd number of hours into the night, I came across the exact right answer: an irrelevant question posed an adjacent problem; someone gave a partial answer, and a commenter pointed out the corner case causing a testing bug, and how to avoid it.\n\nI wrapped up my bug at 3 am, with one day remaining till the deadline to iterate without flakey tests interrupting. Thank God the other person knew more than I did. I found it only appropriate to go back to upvote and thank the commenter from Stack Overflow. He wrote the comment two years ago, so maybe he wouldn't notice my message of gratitude, I thought. So I checked his name. His name ... mine!\n\n\nA programmer gets lost in the logical branches of complexity that he himself creates. Deep learning solves by putting the unlearned on the bicycle."", 'result': {'fake': 0.5086, 'real': 0.4914}, 'status': 'success'}], 'credits_used': 7, 'credits': 1983928, 'subscription': 0, 'content': ""We lived in terrible economic times when I turned 4. Kids in my neighborhood rode bicycles in the street and seemed to enjoy each others' company without a second thought spared on how to bike. I wanted to learn. Biking seemed like so much fun. I wanted to be just like them.\n\nSo for about two or three years, I asked my mom, dad, uncle, aunt, cousins, friends, and everyone else about all the intricacies of biking. I watched cartoons about biking. Scenes in movies with bikes in them jumped out at me. In the car, I'd ask my dad to slow down when bikers could be watched.\n\nOne day I walked into my room. A red bike greeted me with surprise. I ran and hugged my parents; they smiled. Then I took the bike out to practice my years of obsessive learning. I got on the seat, grabbed both handle bars, put my foot on the pedal and ... crashed to the floor!\n\nI knew nothing.\n\nThe upset washed over me and I started practicing. You know when I learned how to bike? That same day. Biking doesn't involve logic; it involves muscles.\n\n\nYears later, the same thing happened with programming. I did a bachelor in Computer Science, but didn't learn how to build a proper application after four years. There just seemed to be too many intricacies; too many questions to ask; too many books to read.\n\nSo I got fed up and just installed Visual Studio in Windows (back in the day). A week later, I was OK in C#. A month later, I'd ask questions that wouldn't occur to those who used it for their day job. Six months later, I dumped all my books but one, by just glancing over their tables of content and rejecting them for interest. You don't need books to learn how to bike.\n\n\nFive years into a C# career, I moved to Silicon Valley for a C# job. The market there didn't like C#, so one of my main concerns became learning an open source language. For a few years I aimlessly bought books on Ruby, Python, etc. and toyed with getting a stable environment up on Windows. Never did it stand up on its own.\n\nWhen my company turned unstable, I finally decided to put aside my hesitation to spend on a MacBook. They don't sell one in red, or I would have bought it in bicycle red. The first day I installed Ruby on a Mac, I learned about 20% of what I know today. It just happened. In six months, I had a fully working platform built in Ruby. To learn to bike, you just need to go ahead and get the damn bike.\n\nBut a fascinating day arrived after two years:\n\n\nA deep gnarly concurrency bug in some Capybara integration test prevented my code from passing the suite of tests consistently. Flakey test. Sending commits past the continuous integration into production turned into a crapshoot game. The deadline marched closer. For 48 hours I couldn't find my way out of this nightmare; just couldn't! I poured over Stack Overflow, praying for an answer from God to this extremely rare situation.\n\nAn odd number of hours into the night, I came across the exact right answer: an irrelevant question posed an adjacent problem; someone gave a partial answer, and a commenter pointed out the corner case causing a testing bug, and how to avoid it.\n\nI wrapped up my bug at 3 am, with one day remaining till the deadline to iterate without flakey tests interrupting. Thank God the other person knew more than I did. I found it only appropriate to go back to upvote and thank the commenter from Stack Overflow. He wrote the comment two years ago, so maybe he wouldn't notice my message of gratitude, I thought. So I checked his name. His name ... mine!\n\n\nA programmer gets lost in the logical branches of complexity that he himself creates. Deep learning solves by putting the unlearned on the bicycle."", 'aiModelVersion': '1'}",0.2312
Steve Johnson,7mo,Why is += used instead of =+ in most programming languages?,"In the B language, and very early C versions, the =+ was used (along with =-, =/, =% and so on). The problem was there was a very common programming error that kept coming up. For example, if we wanted to decrement x by 5, we would write x =- 5; The problem was if we didn’t put the space in after the minus sign, it was x = -5; this was so easy to do and so hard to recognize that Dennis decided we should move from =- to -=, and to make all the assignment ops work that way.

I was a believer from the beginning. And we crafted a process for making the transition easy that we were to use several more times when making major changes in the language:

Add the “new” code and get it working.
When the compiler would accept both =- and -=, we added a warning message for the old operator, something like “Operator =- is deprecated. Use -=”
We made sure that every single use got the same message. This meant that the process was irritating but not fatal. Just having the warning messages caused most users to change
When most of the programs were switched over, we put in an additional message when any old op was found: “Deprecated operator =- will become a fatal error on <date>”
When the date arrived, the old operators drew a data error message like “Operator =- is no longer supported. Use -=”

This process worked for all kinds of changes in the language. It had huge benefits. For one thing, the language designers got a lot of feedback early when things were not right. And users got to feed timely and constructive ideas to Dennis, and, actually, to all of us developers. When a bug was introduced, the previous compiler was available in a known place so there were very few “The compiler is broken, we might as well go home.” days.

This is why it doesn’t make sense to say we were programming B and then switched to C. In most cases the evolution was continual and transparent. It’s more like the baby grew up than that it was a different species…","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/2gj6qxtohkaw3uvz', 'title': 'Why is += used instead of =+ in most programming languages?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'In the B language, and very early C versions, the =+ was used (along with =-, =/, =% and so on). The problem was there was a very common programming error that kept coming up. For example, if we wanted to decrement x by 5, we would write x =- 5; The problem was if we didn’t put the space in after the minus sign, it was x = -5; this was so easy to do and so hard to recognize that Dennis decided we should move from =- to -=, and to make all the assignment ops work that way.\n\nI was a believer from the beginning. And we crafted a process for making the transition easy that we were to use several more times when making major changes in the language:\n\nAdd the “new” code and get it working.\nWhen the compiler would accept both =- and -=, we added a warning message for the old operator, something like “Operator =- is deprecated. Use -=”\nWe made sure that every single use got the same message. This meant that the process was irritating but not fatal. Just having the warning messages caused most users to change\nWhen most of the programs were switched over, we put in an additional message when any old op was found: “Deprecated operator =- will become a fatal error on <date>”\nWhen the date arrived, the old operators drew a data error message like “Operator =- is no longer supported. Use -=”\n\nThis process worked for all kinds of changes in the language. It had huge benefits. For one thing, the language designers got a lot of feedback early when things were not right. And users got to feed timely and constructive ideas to Dennis, and, actually, to all of us developers. When a bug was introduced, the previous compiler was available in a known place so there were very few “The compiler is broken, we might as well go home.” days.\n\nThis is why it doesn’t make sense to say we were programming B and then switched to C. In most cases the evolution was continual and transparent. It’s more like the baby grew up than that it was a different species…', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983924, 'subscription': 0, 'content': 'In the B language, and very early C versions, the =+ was used (along with =-, =/, =% and so on). The problem was there was a very common programming error that kept coming up. For example, if we wanted to decrement x by 5, we would write x =- 5; The problem was if we didn’t put the space in after the minus sign, it was x = -5; this was so easy to do and so hard to recognize that Dennis decided we should move from =- to -=, and to make all the assignment ops work that way.\n\nI was a believer from the beginning. And we crafted a process for making the transition easy that we were to use several more times when making major changes in the language:\n\nAdd the “new” code and get it working.\nWhen the compiler would accept both =- and -=, we added a warning message for the old operator, something like “Operator =- is deprecated. Use -=”\nWe made sure that every single use got the same message. This meant that the process was irritating but not fatal. Just having the warning messages caused most users to change\nWhen most of the programs were switched over, we put in an additional message when any old op was found: “Deprecated operator =- will become a fatal error on <date>”\nWhen the date arrived, the old operators drew a data error message like “Operator =- is no longer supported. Use -=”\n\nThis process worked for all kinds of changes in the language. It had huge benefits. For one thing, the language designers got a lot of feedback early when things were not right. And users got to feed timely and constructive ideas to Dennis, and, actually, to all of us developers. When a bug was introduced, the previous compiler was available in a known place so there were very few “The compiler is broken, we might as well go home.” days.\n\nThis is why it doesn’t make sense to say we were programming B and then switched to C. In most cases the evolution was continual and transparent. It’s more like the baby grew up than that it was a different species…', 'aiModelVersion': '1'}",0.9996
Shiva Mahajan,Updated 9y,"I’m a B.Tech 2nd year EE student. I have little knowledge of C language and basic HTML-CSS. I have a lot of material, but I don't know where to begin, so I haven't touched it. How can I learn coding to be an elite programmer with no one to guide me?","Hi there. I think i can help you in this case.
This is a 5 step formula that i followed and i tell everyone this only whenever someone asks me.
Please note that this asnwer assumes that you want start from scratch.

Step 1: Do CS50. There is a catch though. Do it in less than a month. All standard edition Psets and lectures (and shorts if you require) in less than a month.
Course link : Find Courses

Step 2: Do algorithms course on coursera by Tim Roughgarden offered by stanford university. Do this according to course's pace. Design and analysis of Algorithms : part 1.
Course link: Algorithms: Design and Analysis, Part 1

Step 3: Time to enter the world of competitive coding. Start with codechef and spoj. Do atleast 150-175 easy problems which require basic logic within 2-3 months.
Further steps include step 3 running in parallel. You have to continue practicing on codechef and spoj but slowly raising the level of questions to graphs, DP, segment trees, etc.
Codechef : Programming Competition,Programming Contest,Online Computer Programming

Spoj : Sphere Online Judge (SPOJ)

Problems categories: A2 Online Judge

Step 4: Do algorithms course which is the sequel of course i listed in step 2. Design and analysis of algorithms: part 2. Do it according to course's pace. Remember step 3 runs in parallel. By the time this course ends you should be somewhere around 300 problems old. ( combined on codechef and spoj)

Course link: Algorithms: Design and Analysis, Part 2


Step 5: Start doing practice and contests on Codeforces and topcoder. Try to get in division 1 and more importantly stay there. This step is really important.
Codeforces

topcoder

Also take a look at this just somewhere in the middle of step 3.

IMPORTANT: Data Structures and Algorithms


PROGRAMMING LANGUAGES:

Languages I know: C, C++, Python
Question: How to learn them?
Ans: C is taught in almost every college. To learn c++ and other languages there is a very simple technique. The questions that you solve on all these online judges try to do them in the languages yo want to learn.

Question 2: How to do the above tasks if you don't already know the language?
Ans: Google something like ""How to ______ in python/c++/java/etc""
and if possible look for Stack Overflow
 links. The ____ can be filled with the following:


Take user input
Declare an array
Sort elements
Make a hash table or map
print output.
And whatever you need.


I learnt Python like this and bits of java too. This approach works because once you are done with C language and CS50 you will know all the concepts and you will be at a stage where you will just need to get used to with the syntax of the language and that can be done while practicing on online judges.

This is what i did. I hope this helps you. I don't have a job at google but i have an internship there for the summers of 2015 as I am still in my 3rd year.

Good luck and do your best.

NOTE: ALL THIS INFORMATION COMES FROM MY EXPERIENCE, SO IF ANYBODY FEELS THAT IT IS WRONG OR MISLEADING, I AM SORRY, CAN'T HELP IT.

EDIT 1: Added some details to the answer.

EDIT 2:There is one more thing i want to add. while following these steps, somewhere in the middle you will fall in love with all of this and then you won't have to look for answers on how to proceed. You will move forward on your own and all the good things which you desire will happen on their own. Trust me on that.

EDIT 3: For those wondering how to apply to Google.
Shiva Mahajan's answer to How do I apply for Google internship in India if not from (IIT or NIT). I never see any info about internship in india on Google careers page most of the time?","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/v82b6xol4s7rmua0', 'title': ""I’m a B.Tech 2nd year EE student. I have little knowledge of C language and basic HTML-CSS. I have a lot of material, but I don't know where to begin, so I haven't touched it. How can I learn coding to be an elite programmer with no one to guide me?"", 'score': {'original': 0.97975, 'ai': 0.02025}, 'blocks': [{'text': 'Hi there. I think i can help you in this case.\nThis is a 5 step formula that i followed and i tell everyone this only whenever someone asks me.\nPlease note that this asnwer assumes that you want start from scratch.\n\nStep 1: Do CS50. There is a catch though. Do it in less than a month. All standard edition Psets and lectures (and shorts if you require) in less than a month.\nCourse link : Find Courses\n\nStep 2: Do algorithms course on coursera by Tim Roughgarden offered by stanford university. Do this according to course\'s pace. Design and analysis of Algorithms : part 1.\nCourse link: Algorithms: Design and Analysis, Part 1\n\nStep 3: Time to enter the world of competitive coding. Start with codechef and spoj. Do atleast 150-175 easy problems which require basic logic within 2-3 months.\nFurther steps include step 3 running in parallel. You have to continue practicing on codechef and spoj but slowly raising the level of questions to graphs, DP, segment trees, etc.\nCodechef : Programming Competition,Programming Contest,Online Computer Programming\n\nSpoj : Sphere Online Judge (SPOJ)\n\nProblems categories: A2 Online Judge\n\nStep 4: Do algorithms course which is the sequel of course i listed in step 2. Design and analysis of algorithms: part 2. Do it according to course\'s pace. Remember step 3 runs in parallel. By the time this course ends you should be somewhere around 300 problems old. ( combined on codechef and spoj)\n\nCourse link: Algorithms: Design and Analysis, Part 2\n\n\nStep 5: Start doing practice and contests on Codeforces and topcoder. Try to get in division 1 and more importantly stay there. This step is really important.\nCodeforces\n\ntopcoder\n\nAlso take a look at this just somewhere in the middle of step 3.\n\nIMPORTANT: Data Structures and Algorithms\n\n\nPROGRAMMING LANGUAGES:\n\nLanguages I know: C, C++, Python\nQuestion: How to learn them?\nAns: C is taught in almost every college. To learn c++ and other languages there is a very simple technique. The questions that you solve on all these online judges try to do them in the languages yo want to learn.\n\nQuestion 2: How to do the above tasks if you don\'t already know the language?\nAns: Google something like ""How to ______ in python/c++/java/etc""\nand if possible look for Stack Overflow\n links. The ____ can be filled with the following:\n\n\nTake user input\nDeclare an array\nSort elements\nMake a hash table or map\nprint output.\nAnd whatever you need.\n\n\nI learnt Python like this and bits of java too. This approach works because once you are done with C language and CS50 you will know all the concepts and you will be at a stage where you will just need to get used to with the syntax of the language and that can be done while practicing on online judges.\n\nThis is what i did. I hope this helps you. I don\'t have a job at google but i have an internship there for the summers of 2015 as I am still in my 3rd year.\n\nGood luck and do your best.\n\nNOTE: ALL THIS INFORMATION COMES FROM MY EXPERIENCE, SO IF ANYBODY FEELS THAT IT IS WRONG OR MISLEADING, I AM SORRY, CAN\'T HELP IT.\n\nEDIT 1: Added some details to', 'result': {'fake': 0.698, 'real': 0.302}, 'status': 'success'}, {'text': ""the answer.\n\nEDIT 2:There is one more thing i want to add. while following these steps, somewhere in the middle you will fall in love with all of this and then you won't have to look for answers on how to proceed. You will move forward on your own and all the good things which you desire will happen on their own. Trust me on that.\n\nEDIT 3: For those wondering how to apply to Google.\nShiva Mahajan's answer to How do I apply for Google internship in India if not from (IIT or NIT). I never see any info about internship in india on Google careers page most of the time?"", 'result': {'fake': 0.237, 'real': 0.763}, 'status': 'success'}], 'credits_used': 7, 'credits': 1983917, 'subscription': 0, 'content': 'Hi there. I think i can help you in this case.\nThis is a 5 step formula that i followed and i tell everyone this only whenever someone asks me.\nPlease note that this asnwer assumes that you want start from scratch.\n\nStep 1: Do CS50. There is a catch though. Do it in less than a month. All standard edition Psets and lectures (and shorts if you require) in less than a month.\nCourse link : Find Courses\n\nStep 2: Do algorithms course on coursera by Tim Roughgarden offered by stanford university. Do this according to course\'s pace. Design and analysis of Algorithms : part 1.\nCourse link: Algorithms: Design and Analysis, Part 1\n\nStep 3: Time to enter the world of competitive coding. Start with codechef and spoj. Do atleast 150-175 easy problems which require basic logic within 2-3 months.\nFurther steps include step 3 running in parallel. You have to continue practicing on codechef and spoj but slowly raising the level of questions to graphs, DP, segment trees, etc.\nCodechef : Programming Competition,Programming Contest,Online Computer Programming\n\nSpoj : Sphere Online Judge (SPOJ)\n\nProblems categories: A2 Online Judge\n\nStep 4: Do algorithms course which is the sequel of course i listed in step 2. Design and analysis of algorithms: part 2. Do it according to course\'s pace. Remember step 3 runs in parallel. By the time this course ends you should be somewhere around 300 problems old. ( combined on codechef and spoj)\n\nCourse link: Algorithms: Design and Analysis, Part 2\n\n\nStep 5: Start doing practice and contests on Codeforces and topcoder. Try to get in division 1 and more importantly stay there. This step is really important.\nCodeforces\n\ntopcoder\n\nAlso take a look at this just somewhere in the middle of step 3.\n\nIMPORTANT: Data Structures and Algorithms\n\n\nPROGRAMMING LANGUAGES:\n\nLanguages I know: C, C++, Python\nQuestion: How to learn them?\nAns: C is taught in almost every college. To learn c++ and other languages there is a very simple technique. The questions that you solve on all these online judges try to do them in the languages yo want to learn.\n\nQuestion 2: How to do the above tasks if you don\'t already know the language?\nAns: Google something like ""How to ______ in python/c++/java/etc""\nand if possible look for Stack Overflow\n links. The ____ can be filled with the following:\n\n\nTake user input\nDeclare an array\nSort elements\nMake a hash table or map\nprint output.\nAnd whatever you need.\n\n\nI learnt Python like this and bits of java too. This approach works because once you are done with C language and CS50 you will know all the concepts and you will be at a stage where you will just need to get used to with the syntax of the language and that can be done while practicing on online judges.\n\nThis is what i did. I hope this helps you. I don\'t have a job at google but i have an internship there for the summers of 2015 as I am still in my 3rd year.\n\nGood luck and do your best.\n\nNOTE: ALL THIS INFORMATION COMES FROM MY EXPERIENCE, SO IF ANYBODY FEELS THAT IT IS WRONG OR MISLEADING, I AM SORRY, CAN\'T HELP IT.\n\nEDIT 1: Added some details to the answer.\n\nEDIT 2:There is one more thing i want to add. while following these steps, somewhere in the middle you will fall in love with all of this and then you won\'t have to look for answers on how to proceed. You will move forward on your own and all the good things which you desire will happen on their own. Trust me on that.\n\nEDIT 3: For those wondering how to apply to Google.\nShiva Mahajan\'s answer to How do I apply for Google internship in India if not from (IIT or NIT). I never see any info about internship in india on Google careers page most of the time?', 'aiModelVersion': '1'}",0.97975
Alan Mellor,3y,Programming is very on trend right now. Do you think that if a lot of people start programming careers there will be an excess on supply and it will no longer be rentable?,"Yes, if they start careers, get good and stay good.

Have you any idea how hard it is to get your first job?

Any idea how difficult it is to keep learning and gaining expertise?

It’s really difficult.

It’s quite beyond many people.

The other side of this equation is that software is growing all the time. Everything is software. Marc Andreesen coined the term ‘software is eating the world’ and he was right.

My dream job as a kid was to be the TV repair man. He drove to our house in a van. Took the back off the TV and pulled out failed valves (vacuum tubes) and burnt out resistors. He would go to the back of the van for replacements.

What a cool job!

Now, it’s all code. Every last bit of it.

As is the camera the TV is shot on. And the audio. The editing. The lighting controller. The TV station. The web streaming.

Everything has Software.

Anything that does not have it yet will be replaced.

There is no shortage of work for competent software engineers.

Achieving that goal is another matter.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/y706adhemqn4rwkt', 'title': 'Programming is very on trend right now. Do you think that if a lot of people start programming careers there will be an excess on supply and it will no longer be rentable?', 'score': {'original': 0.9958, 'ai': 0.0042}, 'blocks': [{'text': 'Yes, if they start careers, get good and stay good.\n\nHave you any idea how hard it is to get your first job?\n\nAny idea how difficult it is to keep learning and gaining expertise?\n\nIt’s really difficult.\n\nIt’s quite beyond many people.\n\nThe other side of this equation is that software is growing all the time. Everything is software. Marc Andreesen coined the term ‘software is eating the world’ and he was right.\n\nMy dream job as a kid was to be the TV repair man. He drove to our house in a van. Took the back off the TV and pulled out failed valves (vacuum tubes) and burnt out resistors. He would go to the back of the van for replacements.\n\nWhat a cool job!\n\nNow, it’s all code. Every last bit of it.\n\nAs is the camera the TV is shot on. And the audio. The editing. The lighting controller. The TV station. The web streaming.\n\nEverything has Software.\n\nAnything that does not have it yet will be replaced.\n\nThere is no shortage of work for competent software engineers.\n\nAchieving that goal is another matter.', 'result': {'fake': 0.0042, 'real': 0.9958}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983915, 'subscription': 0, 'content': 'Yes, if they start careers, get good and stay good.\n\nHave you any idea how hard it is to get your first job?\n\nAny idea how difficult it is to keep learning and gaining expertise?\n\nIt’s really difficult.\n\nIt’s quite beyond many people.\n\nThe other side of this equation is that software is growing all the time. Everything is software. Marc Andreesen coined the term ‘software is eating the world’ and he was right.\n\nMy dream job as a kid was to be the TV repair man. He drove to our house in a van. Took the back off the TV and pulled out failed valves (vacuum tubes) and burnt out resistors. He would go to the back of the van for replacements.\n\nWhat a cool job!\n\nNow, it’s all code. Every last bit of it.\n\nAs is the camera the TV is shot on. And the audio. The editing. The lighting controller. The TV station. The web streaming.\n\nEverything has Software.\n\nAnything that does not have it yet will be replaced.\n\nThere is no shortage of work for competent software engineers.\n\nAchieving that goal is another matter.', 'aiModelVersion': '1'}",0.9958
Michelle - MAD PIRATE QUEEN,Updated 1y,What do you most want to learn more about?,"THIS:

Image source: link

I’m not going to believe it until I get it externally confirmed. I **need** someone German, Spanish, Dutch, French, Finnish and Greek to confirm if this internet claim is real or not. Can anyone confirm this?

If it is real… I think it’s one of the greatest things I've ever read that’s really quite helpful in increasing understanding of other cultures. That Greek one and the second French one are really very poetic.

Also, the New Zealand specific version of this is: “I don't give a flying f#ck”. 😃

EDIT: This is blimmin marvellous. We’ve crowd sourced confirmation of the above image and now people are adding similar expressions from around the world! I highly encourage people to read the comments.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/joatx1bqsphn3w60', 'title': 'What do you most want to learn more about?', 'score': {'original': 0.9981, 'ai': 0.0019}, 'blocks': [{'text': ""THIS:\n\nImage source: link\n\nI’m not going to believe it until I get it externally confirmed. I **need** someone German, Spanish, Dutch, French, Finnish and Greek to confirm if this internet claim is real or not. Can anyone confirm this?\n\nIf it is real… I think it’s one of the greatest things I've ever read that’s really quite helpful in increasing understanding of other cultures. That Greek one and the second French one are really very poetic.\n\nAlso, the New Zealand specific version of this is: “I don't give a flying f#ck”. 😃\n\nEDIT: This is blimmin marvellous. We’ve crowd sourced confirmation of the above image and now people are adding similar expressions from around the world! I highly encourage people to read the comments."", 'result': {'fake': 0.0019, 'real': 0.9981}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983913, 'subscription': 0, 'content': ""THIS:\n\nImage source: link\n\nI’m not going to believe it until I get it externally confirmed. I **need** someone German, Spanish, Dutch, French, Finnish and Greek to confirm if this internet claim is real or not. Can anyone confirm this?\n\nIf it is real… I think it’s one of the greatest things I've ever read that’s really quite helpful in increasing understanding of other cultures. That Greek one and the second French one are really very poetic.\n\nAlso, the New Zealand specific version of this is: “I don't give a flying f#ck”. 😃\n\nEDIT: This is blimmin marvellous. We’ve crowd sourced confirmation of the above image and now people are adding similar expressions from around the world! I highly encourage people to read the comments."", 'aiModelVersion': '1'}",0.9981
Alan Mellor,4y,What are the signs that coding was done by an amateur?,"There aren’t any specifically.

You get three types of code, really

Code that does not work
Code that works but is difficult to read and modify
Code that works and is easy to read and modify

Professionals spend time learning how to do the last one. But sometimes end up with the second.

Generally, amateurs tend to produce the second sort - works but hacky. But there’s no guarantee on this. Sometimes professionals do.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/8qhms4njf1gwvutk', 'title': 'What are the signs that coding was done by an amateur?', 'score': {'original': 0.9939, 'ai': 0.0061}, 'blocks': [{'text': 'There aren’t any specifically.\n\nYou get three types of code, really\n\nCode that does not work\nCode that works but is difficult to read and modify\nCode that works and is easy to read and modify\n\nProfessionals spend time learning how to do the last one. But sometimes end up with the second.\n\nGenerally, amateurs tend to produce the second sort - works but hacky. But there’s no guarantee on this. Sometimes professionals do.', 'result': {'fake': 0.0061, 'real': 0.9939}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983912, 'subscription': 0, 'content': 'There aren’t any specifically.\n\nYou get three types of code, really\n\nCode that does not work\nCode that works but is difficult to read and modify\nCode that works and is easy to read and modify\n\nProfessionals spend time learning how to do the last one. But sometimes end up with the second.\n\nGenerally, amateurs tend to produce the second sort - works but hacky. But there’s no guarantee on this. Sometimes professionals do.', 'aiModelVersion': '1'}",0.9939
D90 R90,3y,How can I check whether a number is odd or even without using if/else or ternary operator in C/C++?,"I AM HERE WITH A CRAZY ASCII SOLUTION 🤗🤗

(NOT USING BITWISE OPERATOR ALSO)

#include <stdio.h> 
int main() 
{ 
	int a; 
	printf(""EnterA Number:""); 
	scanf(""%d"",&a); 
	printf(""%c%c%c"",(a%2)*79,(a%2)*68,(a%2)*68); 
	 
	printf(""%c%c%c%c"",(1-a%2)*69,(1-a%2)*86,(1-a%2)*69,(1-a%2)*78); 
	return 0; 
} 

Here …. ASCII VALUES ARE USED

79 -》 O

68 -》 D

69 -》 E

and ,so on…

if (a%2) == 1 , hence odd, (a%2)*79 would return ‘O'

and… so on.

There (1-a%2) * (any integer) would simply return NULL character/0.

Here … the output

Hope … you have understood me…👍👍👍… UPVOTE PLEASE..","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ic24u8q7yt5bxpo1', 'title': 'How can I check whether a number is odd or even without using if/else or ternary operator in C/C++?', 'score': {'original': 0.9859, 'ai': 0.0141}, 'blocks': [{'text': 'I AM HERE WITH A CRAZY ASCII SOLUTION 🤗🤗\n\n(NOT USING BITWISE OPERATOR ALSO)\n\n#include <stdio.h>\xa0\nint main()\xa0\n{\xa0\n\tint a;\xa0\n\tprintf(""EnterA Number:"");\xa0\n\tscanf(""%d"",&a);\xa0\n\tprintf(""%c%c%c"",(a%2)*79,(a%2)*68,(a%2)*68);\xa0\n\t\xa0\n\tprintf(""%c%c%c%c"",(1-a%2)*69,(1-a%2)*86,(1-a%2)*69,(1-a%2)*78);\xa0\n\treturn 0;\xa0\n}\xa0\n\nHere …. ASCII VALUES ARE USED\n\n79 -》 O\n\n68 -》 D\n\n69 -》 E\n\nand ,so on…\n\nif (a%2) == 1 , hence odd, (a%2)*79 would return ‘O\'\n\nand… so on.\n\nThere (1-a%2) * (any integer) would simply return NULL character/0.\n\nHere … the output\n\nHope … you have understood me…👍👍👍… UPVOTE PLEASE..', 'result': {'fake': 0.0091, 'real': 0.9909}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983911, 'subscription': 0, 'content': 'I AM HERE WITH A CRAZY ASCII SOLUTION 🤗🤗\n\n(NOT USING BITWISE OPERATOR ALSO)\n\n#include <stdio.h>\xa0\nint main()\xa0\n{\xa0\n\tint a;\xa0\n\tprintf(""EnterA Number:"");\xa0\n\tscanf(""%d"",&a);\xa0\n\tprintf(""%c%c%c"",(a%2)*79,(a%2)*68,(a%2)*68);\xa0\n\t\xa0\n\tprintf(""%c%c%c%c"",(1-a%2)*69,(1-a%2)*86,(1-a%2)*69,(1-a%2)*78);\xa0\n\treturn 0;\xa0\n}\xa0\n\nHere …. ASCII VALUES ARE USED\n\n79 -》 O\n\n68 -》 D\n\n69 -》 E\n\nand ,so on…\n\nif (a%2) == 1 , hence odd, (a%2)*79 would return ‘O\'\n\nand… so on.\n\nThere (1-a%2) * (any integer) would simply return NULL character/0.\n\nHere … the output\n\nHope … you have understood me…👍👍👍… UPVOTE PLEASE..', 'aiModelVersion': '1'}",0.9859
Sofia Everly,4y,How different would be the situation of a programmer who has 1 year of experience vs a programmer with 20 years of experience? What is something both face?,I’m a developer with over 20 years of experience. We hired a junior developer with 1.5 years of experience. We worked together for a year. I noticed right away he was struggling. I don’t normally take anyone under my wing but one day he was working on an issue and didn’t know where to start. I heard him ask several people but didn’t really get anywhere so I walked to his cube and asked what he was working on. He explained and communicated his frustration. I smiled and told him where I would start. And then listed 3 steps to help him figure out the problem. He figured it out that day. After that I began mentoring him on front end and back end. I talked him through C# and entity framework. I taught him about bootstrap and how to visualize as he worked. He also learned Angular from me. He taught me new approaches to testing and architecture patterns that he learned at his last job. I forgot what it was like to be excited about learning new things. He called me the Queen. I called him the devkid til I finally learned his name. He made me realize I reached a level as a developer in which I was finally able to give back. It was a good experience for us both.,"{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/7zhpcifdt0nb42kl', 'title': 'How different would be the situation of a programmer who has 1 year of experience vs a programmer with 20 years of experience? What is something both face?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'I’m a developer with over 20 years of experience. We hired a junior developer with 1.5 years of experience. We worked together for a year. I noticed right away he was struggling. I don’t normally take anyone under my wing but one day he was working on an issue and didn’t know where to start. I heard him ask several people but didn’t really get anywhere so I walked to his cube and asked what he was working on. He explained and communicated his frustration. I smiled and told him where I would start. And then listed 3 steps to help him figure out the problem. He figured it out that day. After that I began mentoring him on front end and back end. I talked him through C# and entity framework. I taught him about bootstrap and how to visualize as he worked. He also learned Angular from me. He taught me new approaches to testing and architecture patterns that he learned at his last job. I forgot what it was like to be excited about learning new things. He called me the Queen. I called him the devkid til I finally learned his name. He made me realize I reached a level as a developer in which I was finally able to give back. It was a good experience for us both.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983908, 'subscription': 0, 'content': 'I’m a developer with over 20 years of experience. We hired a junior developer with 1.5 years of experience. We worked together for a year. I noticed right away he was struggling. I don’t normally take anyone under my wing but one day he was working on an issue and didn’t know where to start. I heard him ask several people but didn’t really get anywhere so I walked to his cube and asked what he was working on. He explained and communicated his frustration. I smiled and told him where I would start. And then listed 3 steps to help him figure out the problem. He figured it out that day. After that I began mentoring him on front end and back end. I talked him through C# and entity framework. I taught him about bootstrap and how to visualize as he worked. He also learned Angular from me. He taught me new approaches to testing and architecture patterns that he learned at his last job. I forgot what it was like to be excited about learning new things. He called me the Queen. I called him the devkid til I finally learned his name. He made me realize I reached a level as a developer in which I was finally able to give back. It was a good experience for us both.', 'aiModelVersion': '1'}",0.9997
Anthony Moh,10y,How is competitive programming different from real-life programming?,"You are in the jungle. You have a pocket-knife. Someone asks you to kill a mountain lion. Anyone but a programmer would be asking ""WTF is a MOUNTAIN lion doing in a JUNGLE?!"", but that's not what you have been trained to do as a programmer. You are here to solve problems, not to question them.

Years of training has taught you well. You use your knife to sharpen a stick. You cut vines to lash sharp stones on one end. Maybe you're from a top university, and you've learned to extract essential ingredients from plant and insect life around you to fashion a poison to tip your weapon with.

Convinced that you have an effective and efficient way to kill the lion, you set forth to accomplish your task. Maybe your stick is too short, or your poisons don't work. It's okay - you live to refine your method and try again another day.

Then someone figures out a way to fashion a low-grade explosive from harvesting chemicals in the jungle. Your method of fashioning a spear to kill the lion is now far from the best way to accomplish your task. Nevertheless, it's still a simple way, and will continue to be taught in schools. Every lion-killer will be taught how to build his tools from scratch.

That's ""real-life"" programming.

In competitive programming, you start out with the same resources (a pocket-knife), except you have 2 minutes to kill the lion.

As a beginner, you will stare at the lion and do nothing.

Soon, you learn that if you kill a squirrel, sometimes the judge thinks it's a lion and you're good to go.

A more experienced programmer just keeps stabbing the lion and hopes that the lion dies in time. Soon, you learn that there are certain spots on a lion that are damage immune. You learn to not even bother stabbing those spots. Sometimes, the lion doesn't expose those spots, so you get really good at killing squirrels.

And then, to be a great competitive programmer, you need to be able to do two things.

First, you must learn how to find the lion's critical point and kill it in one swift stroke.

Second, you must learn how to be so handy with your knife that you can fashion a sharp stick in 1 minute, and spend the next minute stabbing the lion to death.

But never ever will you be able to have enough time to fashion an explosive to take the lion out.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/nmd2rl6o3t7yjb9s', 'title': 'How is competitive programming different from real-life programming?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'You are in the jungle. You have a pocket-knife. Someone asks you to kill a mountain lion. Anyone but a programmer would be asking ""WTF is a MOUNTAIN lion doing in a JUNGLE?!"", but that\'s not what you have been trained to do as a programmer. You are here to solve problems, not to question them.\n\nYears of training has taught you well. You use your knife to sharpen a stick. You cut vines to lash sharp stones on one end. Maybe you\'re from a top university, and you\'ve learned to extract essential ingredients from plant and insect life around you to fashion a poison to tip your weapon with.\n\nConvinced that you have an effective and efficient way to kill the lion, you set forth to accomplish your task. Maybe your stick is too short, or your poisons don\'t work. It\'s okay - you live to refine your method and try again another day.\n\nThen someone figures out a way to fashion a low-grade explosive from harvesting chemicals in the jungle. Your method of fashioning a spear to kill the lion is now far from the best way to accomplish your task. Nevertheless, it\'s still a simple way, and will continue to be taught in schools. Every lion-killer will be taught how to build his tools from scratch.\n\nThat\'s ""real-life"" programming.\n\nIn competitive programming, you start out with the same resources (a pocket-knife), except you have 2 minutes to kill the lion.\n\nAs a beginner, you will stare at the lion and do nothing.\n\nSoon, you learn that if you kill a squirrel, sometimes the judge thinks it\'s a lion and you\'re good to go.\n\nA more experienced programmer just keeps stabbing the lion and hopes that the lion dies in time. Soon, you learn that there are certain spots on a lion that are damage immune. You learn to not even bother stabbing those spots. Sometimes, the lion doesn\'t expose those spots, so you get really good at killing squirrels.\n\nAnd then, to be a great competitive programmer, you need to be able to do two things.\n\nFirst, you must learn how to find the lion\'s critical point and kill it in one swift stroke.\n\nSecond, you must learn how to be so handy with your knife that you can fashion a sharp stick in 1 minute, and spend the next minute stabbing the lion to death.\n\nBut never ever will you be able to have enough time to fashion an explosive to take the lion out.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983903, 'subscription': 0, 'content': 'You are in the jungle. You have a pocket-knife. Someone asks you to kill a mountain lion. Anyone but a programmer would be asking ""WTF is a MOUNTAIN lion doing in a JUNGLE?!"", but that\'s not what you have been trained to do as a programmer. You are here to solve problems, not to question them.\n\nYears of training has taught you well. You use your knife to sharpen a stick. You cut vines to lash sharp stones on one end. Maybe you\'re from a top university, and you\'ve learned to extract essential ingredients from plant and insect life around you to fashion a poison to tip your weapon with.\n\nConvinced that you have an effective and efficient way to kill the lion, you set forth to accomplish your task. Maybe your stick is too short, or your poisons don\'t work. It\'s okay - you live to refine your method and try again another day.\n\nThen someone figures out a way to fashion a low-grade explosive from harvesting chemicals in the jungle. Your method of fashioning a spear to kill the lion is now far from the best way to accomplish your task. Nevertheless, it\'s still a simple way, and will continue to be taught in schools. Every lion-killer will be taught how to build his tools from scratch.\n\nThat\'s ""real-life"" programming.\n\nIn competitive programming, you start out with the same resources (a pocket-knife), except you have 2 minutes to kill the lion.\n\nAs a beginner, you will stare at the lion and do nothing.\n\nSoon, you learn that if you kill a squirrel, sometimes the judge thinks it\'s a lion and you\'re good to go.\n\nA more experienced programmer just keeps stabbing the lion and hopes that the lion dies in time. Soon, you learn that there are certain spots on a lion that are damage immune. You learn to not even bother stabbing those spots. Sometimes, the lion doesn\'t expose those spots, so you get really good at killing squirrels.\n\nAnd then, to be a great competitive programmer, you need to be able to do two things.\n\nFirst, you must learn how to find the lion\'s critical point and kill it in one swift stroke.\n\nSecond, you must learn how to be so handy with your knife that you can fashion a sharp stick in 1 minute, and spend the next minute stabbing the lion to death.\n\nBut never ever will you be able to have enough time to fashion an explosive to take the lion out.', 'aiModelVersion': '1'}",0.9998
John Reese,6y,What are some great truths of computer programming?,"Here is the big one, as far as I'm concerned:

If you're battling an inexplicable bug, and you find yourself saying, “This doesn't make any sense!”, then this is a sign that you are making an invalid assumption about what's on. It could be you're in a different environment than you thought you were in, or that your variable names are correct so you don't need to check them, or that you're connected to a different database. It's often something that seems unimportant, so you tend to overlook it as you search for a solution.

The first thing to do is to ask, What assumptions am I making? Go through the list, check them all, even the ones that seem stupid.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/bscwu091ldf4z67x', 'title': 'What are some great truths of computer programming?', 'score': {'original': 0.0042, 'ai': 0.9958}, 'blocks': [{'text': ""Here is the big one, as far as I'm concerned:\n\nIf you're battling an inexplicable bug, and you find yourself saying, “This doesn't make any sense!”, then this is a sign that you are making an invalid assumption about what's on. It could be you're in a different environment than you thought you were in, or that your variable names are correct so you don't need to check them, or that you're connected to a different database. It's often something that seems unimportant, so you tend to overlook it as you search for a solution.\n\nThe first thing to do is to ask, What assumptions am I making? Go through the list, check them all, even the ones that seem stupid."", 'result': {'fake': 0.9958, 'real': 0.0042}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983901, 'subscription': 0, 'content': ""Here is the big one, as far as I'm concerned:\n\nIf you're battling an inexplicable bug, and you find yourself saying, “This doesn't make any sense!”, then this is a sign that you are making an invalid assumption about what's on. It could be you're in a different environment than you thought you were in, or that your variable names are correct so you don't need to check them, or that you're connected to a different database. It's often something that seems unimportant, so you tend to overlook it as you search for a solution.\n\nThe first thing to do is to ask, What assumptions am I making? Go through the list, check them all, even the ones that seem stupid."", 'aiModelVersion': '1'}",0.0042
Dushka Zapata,4y,What life lesson did you learn the hard way?,"My thoughts lie to me.

My feelings are temporary.

My feelings need to be felt.

Discipline, far from punishing, is the highest, truest manifestation of self-love.

Doing only what I’m good at means I never learn anything new.

Familiar does not always equal good.

Love feels safe and is not supposed to hurt.

I don’t have to be useful to deserve love.

It’s necessary to put myself first.

Boundaries are not selfish.

Disappointing others is inevitable.

Most of what hurts does not exist.

Most of what I worry about will not happen.

I am not responsible for managing the emotions or the perceptions of others.

I cannot control, fix, save or improve someone else.

No one can control, fix, save or improve me.

The only person who can help me is me.

A trigger is something to work through and not something to run from.

People who deny my experience are toxic.

How other people behave does not define me. It defines them.

Deep breaths have the power to alter my mental space.

When someone talks about another they are talking about themselves.

Giving advice is an act of ego.

Silence is the antidote to feeling lost.

The more I tell myself I am too busy for yoga the more I need yoga.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/6t81xypo57ukez93', 'title': 'What life lesson did you learn the hard way?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'My thoughts lie to me.\n\nMy feelings are temporary.\n\nMy feelings need to be felt.\n\nDiscipline, far from punishing, is the highest, truest manifestation of self-love.\n\nDoing only what I’m good at means I never learn anything new.\n\nFamiliar does not always equal good.\n\nLove feels safe and is not supposed to hurt.\n\nI don’t have to be useful to deserve love.\n\nIt’s necessary to put myself first.\n\nBoundaries are not selfish.\n\nDisappointing others is inevitable.\n\nMost of what hurts does not exist.\n\nMost of what I worry about will not happen.\n\nI am not responsible for managing the emotions or the perceptions of others.\n\nI cannot control, fix, save or improve someone else.\n\nNo one can control, fix, save or improve me.\n\nThe only person who can help me is me.\n\nA trigger is something to work through and not something to run from.\n\nPeople who deny my experience are toxic.\n\nHow other people behave does not define me. It defines them.\n\nDeep breaths have the power to alter my mental space.\n\nWhen someone talks about another they are talking about themselves.\n\nGiving advice is an act of ego.\n\nSilence is the antidote to feeling lost.\n\nThe more I tell myself I am too busy for yoga the more I need yoga.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983898, 'subscription': 0, 'content': 'My thoughts lie to me.\n\nMy feelings are temporary.\n\nMy feelings need to be felt.\n\nDiscipline, far from punishing, is the highest, truest manifestation of self-love.\n\nDoing only what I’m good at means I never learn anything new.\n\nFamiliar does not always equal good.\n\nLove feels safe and is not supposed to hurt.\n\nI don’t have to be useful to deserve love.\n\nIt’s necessary to put myself first.\n\nBoundaries are not selfish.\n\nDisappointing others is inevitable.\n\nMost of what hurts does not exist.\n\nMost of what I worry about will not happen.\n\nI am not responsible for managing the emotions or the perceptions of others.\n\nI cannot control, fix, save or improve someone else.\n\nNo one can control, fix, save or improve me.\n\nThe only person who can help me is me.\n\nA trigger is something to work through and not something to run from.\n\nPeople who deny my experience are toxic.\n\nHow other people behave does not define me. It defines them.\n\nDeep breaths have the power to alter my mental space.\n\nWhen someone talks about another they are talking about themselves.\n\nGiving advice is an act of ego.\n\nSilence is the antidote to feeling lost.\n\nThe more I tell myself I am too busy for yoga the more I need yoga.', 'aiModelVersion': '1'}",0.9995
Kurt Guntheroth,Updated 3y,“Good programmers write good code. Great programmers write no code. Zen programmers delete code.” Do you have a story about those programmers?,"Yeah, I spent almost ten years deleting code on one project.

The original code was OK when viewed from the 30,000 foot level. It had a threaded structure that made sense, and an awesome automatic server connection protocol.

The problem was, it was C++ code written by a Visual BASIC programmer (I kid you not). This guy literally didn’t understand why you would specialize a class by deriving from it. He was also a copy/paste programmer, so there was only one of six servers where the automatic connection protocol actually worked. The code was a horrific mess of state variables used to define the behavior of objects that were a single global type but should have been a family of derived classes. The multithreaded code was not secured by synchronization primitives, so it blew up all the time. With three users, the servers crashed once or twice a day and were then unavailable until they could be stopped and restarted manually.

Refactoring code is like eating an elephant. You just start at any convenient corner and keep going until you’re done. By the time I left, I had eaten the whole elephant. About 80 percent of the original lines of code had been deleted, and every one of the remaining 20 percent of the original lines had been rewritten. Some modules had been rewritten as many as three times. The software had all functions of the original plus many new ones.

If I do say so myself, the resulting code was beautiful, like a zen garden, and efficient, like a kung fu master. With 100 users, this code was approximately as reliable as the servers on which it ran, so that if there was a crash, it was as likely to be a hardware or O/S problem as a problem with the code.

It was unusual that I got to work with a code base for so long. I think the company kept me on so long because I was the only C++ developer, so if I left, nobody could make changes in the code. It was a tremendous learning experience in refactoring.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/hk5aofem12bpjs8z', 'title': '“Good programmers write good code. Great programmers write no code. Zen programmers delete code.” Do you have a story about those programmers?', 'score': {'original': 0.9991, 'ai': 0.0009}, 'blocks': [{'text': 'Yeah, I spent almost ten years deleting code on one project.\n\nThe original code was OK when viewed from the 30,000 foot level. It had a threaded structure that made sense, and an awesome automatic server connection protocol.\n\nThe problem was, it was C++ code written by a Visual BASIC programmer (I kid you not). This guy literally didn’t understand why you would specialize a class by deriving from it. He was also a copy/paste programmer, so there was only one of six servers where the automatic connection protocol actually worked. The code was a horrific mess of state variables used to define the behavior of objects that were a single global type but should have been a family of derived classes. The multithreaded code was not secured by synchronization primitives, so it blew up all the time. With three users, the servers crashed once or twice a day and were then unavailable until they could be stopped and restarted manually.\n\nRefactoring code is like eating an elephant. You just start at any convenient corner and keep going until you’re done. By the time I left, I had eaten the whole elephant. About 80 percent of the original lines of code had been deleted, and every one of the remaining 20 percent of the original lines had been rewritten. Some modules had been rewritten as many as three times. The software had all functions of the original plus many new ones.\n\nIf I do say so myself, the resulting code was beautiful, like a zen garden, and efficient, like a kung fu master. With 100 users, this code was approximately as reliable as the servers on which it ran, so that if there was a crash, it was as likely to be a hardware or O/S problem as a problem with the code.\n\nIt was unusual that I got to work with a code base for so long. I think the company kept me on so long because I was the only C++ developer, so if I left, nobody could make changes in the code. It was a tremendous learning experience in refactoring.', 'result': {'fake': 0.0009, 'real': 0.9991}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983894, 'subscription': 0, 'content': 'Yeah, I spent almost ten years deleting code on one project.\n\nThe original code was OK when viewed from the 30,000 foot level. It had a threaded structure that made sense, and an awesome automatic server connection protocol.\n\nThe problem was, it was C++ code written by a Visual BASIC programmer (I kid you not). This guy literally didn’t understand why you would specialize a class by deriving from it. He was also a copy/paste programmer, so there was only one of six servers where the automatic connection protocol actually worked. The code was a horrific mess of state variables used to define the behavior of objects that were a single global type but should have been a family of derived classes. The multithreaded code was not secured by synchronization primitives, so it blew up all the time. With three users, the servers crashed once or twice a day and were then unavailable until they could be stopped and restarted manually.\n\nRefactoring code is like eating an elephant. You just start at any convenient corner and keep going until you’re done. By the time I left, I had eaten the whole elephant. About 80 percent of the original lines of code had been deleted, and every one of the remaining 20 percent of the original lines had been rewritten. Some modules had been rewritten as many as three times. The software had all functions of the original plus many new ones.\n\nIf I do say so myself, the resulting code was beautiful, like a zen garden, and efficient, like a kung fu master. With 100 users, this code was approximately as reliable as the servers on which it ran, so that if there was a crash, it was as likely to be a hardware or O/S problem as a problem with the code.\n\nIt was unusual that I got to work with a code base for so long. I think the company kept me on so long because I was the only C++ developer, so if I left, nobody could make changes in the code. It was a tremendous learning experience in refactoring.', 'aiModelVersion': '1'}",0.9991
Alan Mellor,7y,"Now that anyone can learn to code, will it become less lucrative?","They can’t though. And that’s the problem our industry faces.

You forget that what a normal person might be proud of - writing “Hello World” in JavaScript, and getting a personal Bio web page up - are nothing, absolutely nothing like real software.

The scale of effort in writing Windows, Linux, iOS, Google Chrome, Google Search, AWS, Facebook, Hotmail, Outlook … Even writing a dumb phone app. Most people can’t do it.

The barriers to equipment are lower, I agree.

The barrier to thinking is higher.

Software is nothing more than captured, executable thought.

It is getting exponentially harder, in my view.

And even with the whole of the internet available on your smartphone, I observe people ask really basic questions, like “How do I start coding?” on Quora. I love answering, and helping. But … it shows me that a person who will not type a google search query is considering entering our field.

It’s like tying your shoelaces together and asking “When can I race Usain Bolt?”

Forget about coding. Think about how you design a system like Facebook or Netflix or the public telephone network or a mobile base station. How do you support millions, billions of users? How do you guarantee service? Where do you store their data> How do you secure it? What happens if storage fails? How do you bill them? How do you not charge them twice?

None of that is answered by coding. It is very difficult, and it is mission critical.

And people capable of doing it are expensive and scarce.

We genuinely cannot spin up enough of those to keep pace with demand.

As Marc Andreesen (inventor of the browser, partner of VC firm) says, “software is eating the world”.

And it isn’t noddy little bits of scripts that he is talking about.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/nv2xe4gh1ls0y87u', 'title': 'Now that anyone can learn to code, will it become less lucrative?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'They can’t though. And that’s the problem our industry faces.\n\nYou forget that what a normal person might be proud of - writing “Hello World” in JavaScript, and getting a personal Bio web page up - are nothing, absolutely nothing like real software.\n\nThe scale of effort in writing Windows, Linux, iOS, Google Chrome, Google Search, AWS, Facebook, Hotmail, Outlook … Even writing a dumb phone app. Most people can’t do it.\n\nThe barriers to equipment are lower, I agree.\n\nThe barrier to thinking is higher.\n\nSoftware is nothing more than captured, executable thought.\n\nIt is getting exponentially harder, in my view.\n\nAnd even with the whole of the internet available on your smartphone, I observe people ask really basic questions, like “How do I start coding?” on Quora. I love answering, and helping. But … it shows me that a person who will not type a google search query is considering entering our field.\n\nIt’s like tying your shoelaces together and asking “When can I race Usain Bolt?”\n\nForget about coding. Think about how you design a system like Facebook or Netflix or the public telephone network or a mobile base station. How do you support millions, billions of users? How do you guarantee service? Where do you store their data> How do you secure it? What happens if storage fails? How do you bill them? How do you not charge them twice?\n\nNone of that is answered by coding. It is very difficult, and it is mission critical.\n\nAnd people capable of doing it are expensive and scarce.\n\nWe genuinely cannot spin up enough of those to keep pace with demand.\n\nAs Marc Andreesen (inventor of the browser, partner of VC firm) says, “software is eating the world”.\n\nAnd it isn’t noddy little bits of scripts that he is talking about.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983890, 'subscription': 0, 'content': 'They can’t though. And that’s the problem our industry faces.\n\nYou forget that what a normal person might be proud of - writing “Hello World” in JavaScript, and getting a personal Bio web page up - are nothing, absolutely nothing like real software.\n\nThe scale of effort in writing Windows, Linux, iOS, Google Chrome, Google Search, AWS, Facebook, Hotmail, Outlook … Even writing a dumb phone app. Most people can’t do it.\n\nThe barriers to equipment are lower, I agree.\n\nThe barrier to thinking is higher.\n\nSoftware is nothing more than captured, executable thought.\n\nIt is getting exponentially harder, in my view.\n\nAnd even with the whole of the internet available on your smartphone, I observe people ask really basic questions, like “How do I start coding?” on Quora. I love answering, and helping. But … it shows me that a person who will not type a google search query is considering entering our field.\n\nIt’s like tying your shoelaces together and asking “When can I race Usain Bolt?”\n\nForget about coding. Think about how you design a system like Facebook or Netflix or the public telephone network or a mobile base station. How do you support millions, billions of users? How do you guarantee service? Where do you store their data> How do you secure it? What happens if storage fails? How do you bill them? How do you not charge them twice?\n\nNone of that is answered by coding. It is very difficult, and it is mission critical.\n\nAnd people capable of doing it are expensive and scarce.\n\nWe genuinely cannot spin up enough of those to keep pace with demand.\n\nAs Marc Andreesen (inventor of the browser, partner of VC firm) says, “software is eating the world”.\n\nAnd it isn’t noddy little bits of scripts that he is talking about.', 'aiModelVersion': '1'}",0.9998
Anonymous,Updated 7y,How are students in Indian colleges taught programming?,"Scenario in a state university college
5th Semester;
Design and Analysis of Algorithms Lab

Step 1: You enter lab and following is written on white board-
""write a program in C to implement Heap sort"".

Step 2: Everybody makes awkward faces as if they are asked to indulge in some morbid affairs.

Step 3: Faculty of DAA screams that he will not give a single mark in practicals in the end sem if they don't execute the program written on the white board.

Step 4: Everybody babbles some random mocking comment on that faculty.

Step 5: Everybody keeps calm and switches on the PC.

Step 6: Out of 100 minutes lab 20 minutes have passed and nobody has typed more than this
#include<stdio.h>
#include<conio.h>
void main()
{
int a;
clrscr();

getch();
}

Step 7: A few ingenious students(including maggus) try to search google and find the code in the very first link but the teacher screams again ""No body dare to copy code from google"". Others dont even bother to search on google.

Step 8: 20 more minutes pass and still nobody has typed more than this. The maggus pretend as if they are actually programming by copying code from google line by line.

Step 9: Faculty keeps calm and switches on the projector and the code for the same program is displayed.

Step 10: WTF!!the code is same as it is on the very first link on google; even the variables and function names are also same!!Everyone copies that from projector. Some ingeniouses copy paste the whole code (from the same very first link displayed on google search result from which the faculty has copied) in txt file and rename it to c file and paste it in the bin folder. 100 mins pass bell rings and voila you have just made a program of Heap sort.

I feel shame even writing this answer but its harsh reality of our education system.

PS: anonymous because faculty members are on quora. Thank you!","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/hzvl5wce1j8dskgb', 'title': 'How are students in Indian colleges taught programming?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Scenario in a state university college\n5th Semester;\nDesign and Analysis of Algorithms Lab\n\nStep 1: You enter lab and following is written on white board-\n""write a program in C to implement Heap sort"".\n\nStep 2: Everybody makes awkward faces as if they are asked to indulge in some morbid affairs.\n\nStep 3: Faculty of DAA screams that he will not give a single mark in practicals in the end sem if they don\'t execute the program written on the white board.\n\nStep 4: Everybody babbles some random mocking comment on that faculty.\n\nStep 5: Everybody keeps calm and switches on the PC.\n\nStep 6: Out of 100 minutes lab 20 minutes have passed and nobody has typed more than this\n#include<stdio.h>\n#include<conio.h>\nvoid main()\n{\nint a;\nclrscr();\n\ngetch();\n}\n\nStep 7: A few ingenious students(including maggus) try to search google and find the code in the very first link but the teacher screams again ""No body dare to copy code from google"". Others dont even bother to search on google.\n\nStep 8: 20 more minutes pass and still nobody has typed more than this. The maggus pretend as if they are actually programming by copying code from google line by line.\n\nStep 9: Faculty keeps calm and switches on the projector and the code for the same program is displayed.\n\nStep 10: WTF!!the code is same as it is on the very first link on google; even the variables and function names are also same!!Everyone copies that from projector. Some ingeniouses copy paste the whole code (from the same very first link displayed on google search result from which the faculty has copied) in txt file and rename it to c file and paste it in the bin folder. 100 mins pass bell rings and voila you have just made a program of Heap sort.\n\nI feel shame even writing this answer but its harsh reality of our education system.\n\nPS: anonymous because faculty members are on quora. Thank you!', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983886, 'subscription': 0, 'content': 'Scenario in a state university college\n5th Semester;\nDesign and Analysis of Algorithms Lab\n\nStep 1: You enter lab and following is written on white board-\n""write a program in C to implement Heap sort"".\n\nStep 2: Everybody makes awkward faces as if they are asked to indulge in some morbid affairs.\n\nStep 3: Faculty of DAA screams that he will not give a single mark in practicals in the end sem if they don\'t execute the program written on the white board.\n\nStep 4: Everybody babbles some random mocking comment on that faculty.\n\nStep 5: Everybody keeps calm and switches on the PC.\n\nStep 6: Out of 100 minutes lab 20 minutes have passed and nobody has typed more than this\n#include<stdio.h>\n#include<conio.h>\nvoid main()\n{\nint a;\nclrscr();\n\ngetch();\n}\n\nStep 7: A few ingenious students(including maggus) try to search google and find the code in the very first link but the teacher screams again ""No body dare to copy code from google"". Others dont even bother to search on google.\n\nStep 8: 20 more minutes pass and still nobody has typed more than this. The maggus pretend as if they are actually programming by copying code from google line by line.\n\nStep 9: Faculty keeps calm and switches on the projector and the code for the same program is displayed.\n\nStep 10: WTF!!the code is same as it is on the very first link on google; even the variables and function names are also same!!Everyone copies that from projector. Some ingeniouses copy paste the whole code (from the same very first link displayed on google search result from which the faculty has copied) in txt file and rename it to c file and paste it in the bin folder. 100 mins pass bell rings and voila you have just made a program of Heap sort.\n\nI feel shame even writing this answer but its harsh reality of our education system.\n\nPS: anonymous because faculty members are on quora. Thank you!', 'aiModelVersion': '1'}",0.9998
Brock Pan-Yellow,Updated 1y,What is the best thing that you can tell about programming?,"Between me typing this answer, sending it to Quora, and you reading it, do you know how much programming went in to making that all happen? Exactly one Bajillion Engineers contributed in some meaningful way.

An army of engineers built the browser I’m using to type. If you use a different one to read, that’s another army.

There are half a dozen layers between the UI displaying my text and the physical/network layers at the bottom. Each of those layers was built by armies of programmers, battling each other daily.

And what about that fancy device you’re reading this on? Do you know how much programming happens at Intel to make those chips? Or how much programming goes into making the physical tools to make the chips? Or the tools to make those tools? …

We’ve come a long way from this.

That’s a map of every computer on the “net” in 1973.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/yjd8zq650eongs7u', 'title': 'What is the best thing that you can tell about programming?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'Between me typing this answer, sending it to Quora, and you reading it, do you know how much programming went in to making that all happen? Exactly one Bajillion Engineers contributed in some meaningful way.\n\nAn army of engineers built the browser I’m using to type. If you use a different one to read, that’s another army.\n\nThere are half a dozen layers between the UI displaying my text and the physical/network layers at the bottom. Each of those layers was built by armies of programmers, battling each other daily.\n\nAnd what about that fancy device you’re reading this on? Do you know how much programming happens at Intel to make those chips? Or how much programming goes into making the physical tools to make the chips? Or the tools to make those tools? …\n\nWe’ve come a long way from this.\n\nThat’s a map of every computer on the “net” in 1973.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983884, 'subscription': 0, 'content': 'Between me typing this answer, sending it to Quora, and you reading it, do you know how much programming went in to making that all happen? Exactly one Bajillion Engineers contributed in some meaningful way.\n\nAn army of engineers built the browser I’m using to type. If you use a different one to read, that’s another army.\n\nThere are half a dozen layers between the UI displaying my text and the physical/network layers at the bottom. Each of those layers was built by armies of programmers, battling each other daily.\n\nAnd what about that fancy device you’re reading this on? Do you know how much programming happens at Intel to make those chips? Or how much programming goes into making the physical tools to make the chips? Or the tools to make those tools? …\n\nWe’ve come a long way from this.\n\nThat’s a map of every computer on the “net” in 1973.', 'aiModelVersion': '1'}",0.9995
Lionel Yeo,Updated 4y,“Good programmers write good code. Great programmers write no code. Zen programmers delete code.” Do you have a story about those programmers?,"You missed one… the 100X programmers.

The 100X programmer doesn’t program code. He/She programs people. The 100x is so rare, I’ve only seen one in my career. I’ll tell you about one of those people. His name was Nino.

Nino, wasn’t a typical programmer. He was a physics guy. He had previously been a scientist and got bored, retired and returned and did tech. Nino was a self-taught programmer and already late 50s when I worked with him. He did some when he was a physics person, but learn the rest along the way. When he came across something he didn’t know, he would say, “Wow, another new thing to learn!”

Soon he was managing teams.

When he lead a team, he always would say, “That’s a piece of cake.” Even though it looked very difficult. Everything was always a ‘piece of cake’. Or else, he would say, “Hey I learned something today!”

Nino taught me about KISS. Keep it simple stupid. That the smartest people understand the simplest things best. He often would say, “I’m stupid. Write something I can understand.”

It was kinda funny because we all knew he was the smartest person in the room. But it drove us to try to write things that were simple and easy to execute.

Nino never berated anyone. The energy that comes from him quickly energizes a team in the mornings. He was passionate and it showed. When he reviewed code, he didn’t talk about brackets. He would sit down and ask someone whether or not a 7-year-old could understand it. Then he would say, do you think that’s a bit complex, can you make it nicer.

A person reviewed by him was asked to describe how they can make everyone’s life easier and what exactly were they trying to achieve as a developer. He wouldn’t mind spending 2 hours at the start to get your philosophy on what good code should be. ‘mindfulness coding…’

The 100x elevates others to excel and motivates them. He instills work philosophy and code belief. Every problem became a challenge and an adventure. Everyone who worked with him starting thinking how we could make Nino’s job easier. We tried to outdo each other to make it simpler. No matter how much of a genius you are, you are only 1 person. But the 100x is no more person, he is almost a philosophy and that can elevate a 100 programmers to 200x","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/c3786edhjb5i4fuq', 'title': '“Good programmers write good code. Great programmers write no code. Zen programmers delete code.” Do you have a story about those programmers?', 'score': {'original': 0.9988, 'ai': 0.0012}, 'blocks': [{'text': 'You missed one… the 100X programmers.\n\nThe 100X programmer doesn’t program code. He/She programs people. The 100x is so rare, I’ve only seen one in my career. I’ll tell you about one of those people. His name was Nino.\n\nNino, wasn’t a typical programmer. He was a physics guy. He had previously been a scientist and got bored, retired and returned and did tech. Nino was a self-taught programmer and already late 50s when I worked with him. He did some when he was a physics person, but learn the rest along the way. When he came across something he didn’t know, he would say, “Wow, another new thing to learn!”\n\nSoon he was managing teams.\n\nWhen he lead a team, he always would say, “That’s a piece of cake.” Even though it looked very difficult. Everything was always a ‘piece of cake’. Or else, he would say, “Hey I learned something today!”\n\nNino taught me about KISS. Keep it simple stupid. That the smartest people understand the simplest things best. He often would say, “I’m stupid. Write something I can understand.”\n\nIt was kinda funny because we all knew he was the smartest person in the room. But it drove us to try to write things that were simple and easy to execute.\n\nNino never berated anyone. The energy that comes from him quickly energizes a team in the mornings. He was passionate and it showed. When he reviewed code, he didn’t talk about brackets. He would sit down and ask someone whether or not a 7-year-old could understand it. Then he would say, do you think that’s a bit complex, can you make it nicer.\n\nA person reviewed by him was asked to describe how they can make everyone’s life easier and what exactly were they trying to achieve as a developer. He wouldn’t mind spending 2 hours at the start to get your philosophy on what good code should be. ‘mindfulness coding…’\n\nThe 100x elevates others to excel and motivates them. He instills work philosophy and code belief. Every problem became a challenge and an adventure. Everyone who worked with him starting thinking how we could make Nino’s job easier. We tried to outdo each other to make it simpler. No matter how much of a genius you are, you are only 1 person. But the 100x is no more person, he is almost a philosophy and that can elevate a 100 programmers to 200x', 'result': {'fake': 0.0012, 'real': 0.9988}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983879, 'subscription': 0, 'content': 'You missed one… the 100X programmers.\n\nThe 100X programmer doesn’t program code. He/She programs people. The 100x is so rare, I’ve only seen one in my career. I’ll tell you about one of those people. His name was Nino.\n\nNino, wasn’t a typical programmer. He was a physics guy. He had previously been a scientist and got bored, retired and returned and did tech. Nino was a self-taught programmer and already late 50s when I worked with him. He did some when he was a physics person, but learn the rest along the way. When he came across something he didn’t know, he would say, “Wow, another new thing to learn!”\n\nSoon he was managing teams.\n\nWhen he lead a team, he always would say, “That’s a piece of cake.” Even though it looked very difficult. Everything was always a ‘piece of cake’. Or else, he would say, “Hey I learned something today!”\n\nNino taught me about KISS. Keep it simple stupid. That the smartest people understand the simplest things best. He often would say, “I’m stupid. Write something I can understand.”\n\nIt was kinda funny because we all knew he was the smartest person in the room. But it drove us to try to write things that were simple and easy to execute.\n\nNino never berated anyone. The energy that comes from him quickly energizes a team in the mornings. He was passionate and it showed. When he reviewed code, he didn’t talk about brackets. He would sit down and ask someone whether or not a 7-year-old could understand it. Then he would say, do you think that’s a bit complex, can you make it nicer.\n\nA person reviewed by him was asked to describe how they can make everyone’s life easier and what exactly were they trying to achieve as a developer. He wouldn’t mind spending 2 hours at the start to get your philosophy on what good code should be. ‘mindfulness coding…’\n\nThe 100x elevates others to excel and motivates them. He instills work philosophy and code belief. Every problem became a challenge and an adventure. Everyone who worked with him starting thinking how we could make Nino’s job easier. We tried to outdo each other to make it simpler. No matter how much of a genius you are, you are only 1 person. But the 100x is no more person, he is almost a philosophy and that can elevate a 100 programmers to 200x', 'aiModelVersion': '1'}",0.9988
Shriram Krishnamurthi,8y,Does Professor Shriram Krishnamurthi plan to offer his online programming languages course again?,"Thanks for your interest. This is a complicated question.

I archive all my course material online, and this is no exception. Furthermore, unlike Udacity/Coursera/etc., we didn't see why a student must wait for a particular day to do the course. Hence, Joe Politz and I designed the course so that anyone can ""run"" the course for themselves any time they want.

All the assignments come with self-grading binaries, so you can start the course tomorrow if you want, watch the videos on YouTube at your own pace, use the binaries to grade yourself, etc. If you can find a group of friends, you can even work through this as a cohort (which would be more fun).

Go to the Web page (On-Line Offering
) and take the course any time!

This is why the question itself doesn't make much sense for this course as opposed to other MOOC offerings: in some sense, it's always being ""offered"".","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/qs0yulvg1pz7nc39', 'title': 'Does Professor Shriram Krishnamurthi plan to offer his online programming languages course again?', 'score': {'original': 0.9719, 'ai': 0.0281}, 'blocks': [{'text': 'Thanks for your interest. This is a complicated question.\n\nI archive all my course material online, and this is no exception. Furthermore, unlike Udacity/Coursera/etc., we didn\'t see why a student must wait for a particular day to do the course. Hence, Joe Politz and I designed the course so that anyone can ""run"" the course for themselves any time they want.\n\nAll the assignments come with self-grading binaries, so you can start the course tomorrow if you want, watch the videos on YouTube at your own pace, use the binaries to grade yourself, etc. If you can find a group of friends, you can even work through this as a cohort (which would be more fun).\n\nGo to the Web page (On-Line Offering\n) and take the course any time!\n\nThis is why the question itself doesn\'t make much sense for this course as opposed to other MOOC offerings: in some sense, it\'s always being ""offered"".', 'result': {'fake': 0.0776, 'real': 0.9224}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983877, 'subscription': 0, 'content': 'Thanks for your interest. This is a complicated question.\n\nI archive all my course material online, and this is no exception. Furthermore, unlike Udacity/Coursera/etc., we didn\'t see why a student must wait for a particular day to do the course. Hence, Joe Politz and I designed the course so that anyone can ""run"" the course for themselves any time they want.\n\nAll the assignments come with self-grading binaries, so you can start the course tomorrow if you want, watch the videos on YouTube at your own pace, use the binaries to grade yourself, etc. If you can find a group of friends, you can even work through this as a cohort (which would be more fun).\n\nGo to the Web page (On-Line Offering\n) and take the course any time!\n\nThis is why the question itself doesn\'t make much sense for this course as opposed to other MOOC offerings: in some sense, it\'s always being ""offered"".', 'aiModelVersion': '1'}",0.9719
Al Max,Updated 6y,"What programs should I make as a beginner? I already know some C#, and have done many language exercises and puzzles. But never an actual program.","I’m an amateur programmer and still a beginner. So far, I did some programs in C# and actually I’m using them. I tested them quite a lot and I removed all indentified bugs immediately. My advice for other beginner programmers is to make your code as readable as possible and to avoid hacks/tricks. The future you will thank you later. Warning: long post ahead. The programs:

Alarm

Just a countdown timer with a customizable message that it’s displayed when the time is up. It has the option to calculate the time between the current time and a target time. Also you can select the sound source (audio file) and some default options.

Calculator

You could input fairly complex expressions. Based on NCalc library. (Edit) This was actually my very first project in C#. Only a few days difference between this and FileMover (featured below).

Launcher

It’s a lightweight program/various file launcher with autocomplete. It has the option to filter the dropdown menu (e.g. if you want to see the games, only the games will be displayed). It includes an item management window and it’s triggered by global hotkeys (CTRL ~). It seems simple but it’s one of the most complex programs that I did so far.

The main interface:

Autocomplete in action:

Manage Item List window:

Notes

Notes is just a lightweight scratchpad/notes program for storing text snippets temporarily. It has a feature to autosave (backup) the text after a customizable amount of seconds. Also the font, text color, background color, word wrap, window width/height are all customizable.

Backup

My own little backup program. It archives anything selected from the input folder. The archive name contains the current date and time.

Guess the Number

A simple guessing number game.

PicViewer

It’s a lightweight picture viewer with a very minimalist interface. It has a slideshow function. There are shortcuts for every function and the picture browsing could be done with the mouse scrollwheel.

PlaylistConverter

It converts M3U or PLS playlists to TXT, CSV (it’s good for importing playlists in programs like Excel), M3U or PLS. If the input format is indentical to the output, the playlist is skipped from converting.

AudioConverter

This is just a GUI for encoders such as LAME. Still work in progress.

FileRenamer

Utility for quickly renaming files sequentially (e.g. 001.txt, 002.txt, etc). The files that already have the correct name are not renamed again. It can work with Total Commander (when it’s launched from TC, it can detect the current working folder automatically).

BatchProcessing

This is basically a GUI for processing multiple files using BAT files. Instead writing long commands, just drag and drop the files and select the suitable BAT (already edited by you) and let the program process each one of them.

FileNameFixer

It fixes file names, e.g. it removes (official video) from downloaded videos. The list of keywords to be removed is stored in a TXT file, so it’s easy to update.

Also it trims useless spaces, turns _ into spaces, turns [ and ] into ( and ), and it makes the prepositions/articles (at, a, an, the, of, in, on, etc) lowercase e.g. Tears For Fears - Everybody Wants To Rule The World → Tears for Fears - Everybody Wants to Rule the World.

It could be started from command line or added in Windows Explorer’s context menu with a freeware program like FileMenu Tools.

MouseClicker

Just a small program to automate repetitive clicking.

FileMover

My second project in C#. This is a file renamer/mover/copier, a neat way to organize lots of (media) files without renaming and moving them manually.

Input: The listbox control from the top has the list of files to be moved/copied that are added using drag and drop or as program arguments.

Output: The treeview control from the bottom has the target folders (they’re all part of a “root” folder from Settings.txt).

Once the target is selected and the processing is started, the files from the listbox are renamed sequentially and moved/copied to the target folder. If the target folder already has some files in it, the renaming starts from the next number (e.g. the folder has 233 files, the renaming starts at 234).

Also this program could be integrated with Total Commander (browse target folder + add files from TC to the listbox) and XnView (thumbnails from the selected target folder).

I configured it in such a way that it works seamlessly like that: I select the files in Total Commander, I press the F9 key and this program shows up with those files in the listbox. The treeview is already focused so I simply navigate it and press Enter, the files are renamed and moved and the program goes back to tray (only if that Minimize checkbox is selected). I could rename and move lots of files in a few seconds. I strongly believe in eliminating unecessary steps/clicks/key pressed as much as possible.

So far I’ve never heard of a similar program.

Also I did a simple text editor and a Snake game in Javascript/CSS/HTML, plus many other utilities and scripts (e.g. a bookmarklet to turn all text into black, to improve contrast on sites with tiring color palettes).","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/dpjy38t749cvagwb', 'title': 'What programs should I make as a beginner? I already know some C#, and have done many language exercises and puzzles. But never an actual program.', 'score': {'original': 0.9465, 'ai': 0.0535}, 'blocks': [{'text': 'I’m an amateur programmer and still a beginner. So far, I did some programs in C# and actually I’m using them. I tested them quite a lot and I removed all indentified bugs immediately. My advice for other beginner programmers is to make your code as readable as possible and to avoid hacks/tricks. The future you will thank you later. Warning: long post ahead. The programs:\n\nAlarm\n\nJust a countdown timer with a customizable message that it’s displayed when the time is up. It has the option to calculate the time between the current time and a target time. Also you can select the sound source (audio file) and some default options.\n\nCalculator\n\nYou could input fairly complex expressions. Based on NCalc library. (Edit) This was actually my very first project in C#. Only a few days difference between this and FileMover (featured below).\n\nLauncher\n\nIt’s a lightweight program/various file launcher with autocomplete. It has the option to filter the dropdown menu (e.g. if you want to see the games, only the games will be displayed). It includes an item management window and it’s triggered by global hotkeys (CTRL ~). It seems simple but it’s one of the most complex programs that I did so far.\n\nThe main interface:\n\nAutocomplete in action:\n\nManage Item List window:\n\nNotes\n\nNotes is just a lightweight scratchpad/notes program for storing text snippets temporarily. It has a feature to autosave (backup) the text after a customizable amount of seconds. Also the font, text color, background color, word wrap, window width/height are all customizable.\n\nBackup\n\nMy own little backup program. It archives anything selected from the input folder. The archive name contains the current date and time.\n\nGuess the Number\n\nA simple guessing number game.\n\nPicViewer\n\nIt’s a lightweight picture viewer with a very minimalist interface. It has a slideshow function. There are shortcuts for every function and the picture browsing could be done with the mouse scrollwheel.\n\nPlaylistConverter\n\nIt converts M3U or PLS playlists to TXT, CSV (it’s good for importing playlists in programs like Excel), M3U or PLS. If the input format is indentical to the output, the playlist is skipped from converting.\n\nAudioConverter\n\nThis is just a GUI for encoders such as LAME. Still work in progress.\n\nFileRenamer\n\nUtility for quickly renaming files sequentially (e.g. 001.txt, 002.txt, etc). The files that already have the correct name are not renamed again. It can work with Total Commander (when it’s launched from TC, it can detect the current working folder automatically).\n\nBatchProcessing\n\nThis is basically a GUI for processing multiple files using BAT files. Instead writing long commands, just drag and drop the files and select the suitable BAT (already edited by you) and let the program process each one of them.\n\nFileNameFixer\n\nIt fixes file names, e.g. it removes (official video) from downloaded videos. The list of keywords to be removed is stored in a TXT file, so it’s easy to update.\n\nAlso it trims useless spaces, turns _ into spaces, turns [ and ] into ( and ), and it makes the prepositions/articles (at, a, an, the, of, in, on, etc) lowercase e.g. Tears For Fears - Everybody Wants To Rule The World → Tears for Fears - Everybody Wants to Rule the', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}, {'text': 'World.\n\nIt could be started from command line or added in Windows Explorer’s context menu with a freeware program like FileMenu Tools.\n\nMouseClicker\n\nJust a small program to automate repetitive clicking.\n\nFileMover\n\nMy second project in C#. This is a file renamer/mover/copier, a neat way to organize lots of (media) files without renaming and moving them manually.\n\nInput: The listbox control from the top has the list of files to be moved/copied that are added using drag and drop or as program arguments.\n\nOutput: The treeview control from the bottom has the target folders (they’re all part of a “root” folder from Settings.txt).\n\nOnce the target is selected and the processing is started, the files from the listbox are renamed sequentially and moved/copied to the target folder. If the target folder already has some files in it, the renaming starts from the next number (e.g. the folder has 233 files, the renaming starts at 234).\n\nAlso this program could be integrated with Total Commander (browse target folder + add files from TC to the listbox) and XnView (thumbnails from the selected target folder).\n\nI configured it in such a way that it works seamlessly like that: I select the files in Total Commander, I press the F9 key and this program shows up with those files in the listbox. The treeview is already focused so I simply navigate it and press Enter, the files are renamed and moved and the program goes back to tray (only if that Minimize checkbox is selected). I could rename and move lots of files in a few seconds. I strongly believe in eliminating unecessary steps/clicks/key pressed as much as possible.\n\nSo far I’ve never heard of a similar program.\n\nAlso I did a simple text editor and a Snake game in Javascript/CSS/HTML, plus many other utilities and scripts (e.g. a bookmarklet to turn all text into black, to improve contrast on sites with tiring color palettes).', 'result': {'fake': 0.0014, 'real': 0.9986}, 'status': 'success'}], 'credits_used': 9, 'credits': 1983868, 'subscription': 0, 'content': 'I’m an amateur programmer and still a beginner. So far, I did some programs in C# and actually I’m using them. I tested them quite a lot and I removed all indentified bugs immediately. My advice for other beginner programmers is to make your code as readable as possible and to avoid hacks/tricks. The future you will thank you later. Warning: long post ahead. The programs:\n\nAlarm\n\nJust a countdown timer with a customizable message that it’s displayed when the time is up. It has the option to calculate the time between the current time and a target time. Also you can select the sound source (audio file) and some default options.\n\nCalculator\n\nYou could input fairly complex expressions. Based on NCalc library. (Edit) This was actually my very first project in C#. Only a few days difference between this and FileMover (featured below).\n\nLauncher\n\nIt’s a lightweight program/various file launcher with autocomplete. It has the option to filter the dropdown menu (e.g. if you want to see the games, only the games will be displayed). It includes an item management window and it’s triggered by global hotkeys (CTRL ~). It seems simple but it’s one of the most complex programs that I did so far.\n\nThe main interface:\n\nAutocomplete in action:\n\nManage Item List window:\n\nNotes\n\nNotes is just a lightweight scratchpad/notes program for storing text snippets temporarily. It has a feature to autosave (backup) the text after a customizable amount of seconds. Also the font, text color, background color, word wrap, window width/height are all customizable.\n\nBackup\n\nMy own little backup program. It archives anything selected from the input folder. The archive name contains the current date and time.\n\nGuess the Number\n\nA simple guessing number game.\n\nPicViewer\n\nIt’s a lightweight picture viewer with a very minimalist interface. It has a slideshow function. There are shortcuts for every function and the picture browsing could be done with the mouse scrollwheel.\n\nPlaylistConverter\n\nIt converts M3U or PLS playlists to TXT, CSV (it’s good for importing playlists in programs like Excel), M3U or PLS. If the input format is indentical to the output, the playlist is skipped from converting.\n\nAudioConverter\n\nThis is just a GUI for encoders such as LAME. Still work in progress.\n\nFileRenamer\n\nUtility for quickly renaming files sequentially (e.g. 001.txt, 002.txt, etc). The files that already have the correct name are not renamed again. It can work with Total Commander (when it’s launched from TC, it can detect the current working folder automatically).\n\nBatchProcessing\n\nThis is basically a GUI for processing multiple files using BAT files. Instead writing long commands, just drag and drop the files and select the suitable BAT (already edited by you) and let the program process each one of them.\n\nFileNameFixer\n\nIt fixes file names, e.g. it removes (official video) from downloaded videos. The list of keywords to be removed is stored in a TXT file, so it’s easy to update.\n\nAlso it trims useless spaces, turns _ into spaces, turns [ and ] into ( and ), and it makes the prepositions/articles (at, a, an, the, of, in, on, etc) lowercase e.g. Tears For Fears - Everybody Wants To Rule The World → Tears for Fears - Everybody Wants to Rule the World.\n\nIt could be started from command line or added in Windows Explorer’s context menu with a freeware program like FileMenu Tools.\n\nMouseClicker\n\nJust a small program to automate repetitive clicking.\n\nFileMover\n\nMy second project in C#. This is a file renamer/mover/copier, a neat way to organize lots of (media) files without renaming and moving them manually.\n\nInput: The listbox control from the top has the list of files to be moved/copied that are added using drag and drop or as program arguments.\n\nOutput: The treeview control from the bottom has the target folders (they’re all part of a “root” folder from Settings.txt).\n\nOnce the target is selected and the processing is started, the files from the listbox are renamed sequentially and moved/copied to the target folder. If the target folder already has some files in it, the renaming starts from the next number (e.g. the folder has 233 files, the renaming starts at 234).\n\nAlso this program could be integrated with Total Commander (browse target folder + add files from TC to the listbox) and XnView (thumbnails from the selected target folder).\n\nI configured it in such a way that it works seamlessly like that: I select the files in Total Commander, I press the F9 key and this program shows up with those files in the listbox. The treeview is already focused so I simply navigate it and press Enter, the files are renamed and moved and the program goes back to tray (only if that Minimize checkbox is selected). I could rename and move lots of files in a few seconds. I strongly believe in eliminating unecessary steps/clicks/key pressed as much as possible.\n\nSo far I’ve never heard of a similar program.\n\nAlso I did a simple text editor and a Snake game in Javascript/CSS/HTML, plus many other utilities and scripts (e.g. a bookmarklet to turn all text into black, to improve contrast on sites with tiring color palettes).', 'aiModelVersion': '1'}",0.9465
Kurt Guntheroth,4y,What is the most difficult C++ programming project you have ever worked on and can you share your code?,"The most difficult C++ project I ever worked on was embedded software to control a device programmer at Data I/O. Can’t share code because it’s proprietary. There are a bunch of things that made this project hard.

It was my first C++ project, and my first project as lead. I was still trying to figure out C++, back in the early 1990s, before the internet. No Stack Overflow
 to ask questions of, no online cppreference.com
 with complete references for every class. Just me and the Annotated Reference Manual. Fortunately, I had a couple of very gentle, kind colleagues to help me with the C++ questions.
The compiler we were using was a POS, and our team was apparently doing the most sophisticated coding of anyone using this compiler. Every week we found another thing that should have worked, but did not. As team lead, I had to look up chapter and verse in the ARM to prove the compiler was not correct, write up a simple test case so they could repro the bug, and interact with their somewhat grumpy customer service. The effort was worth it though, because our bugs always got high priority since we could prove they were bugs.
The device programmer consisted mostly of this custom VLSI circuit that sequenced changes to voltages on the pins of the device to be programmed. You could be as object oriented as you liked, but there was this one big-ass object in the middle with 200 member functions that you could not refactor because it controlled a single big-ass piece of hardware.
That big-ass VLSI sequencer? There was no comprehensive documentation for it. We had to reverse-engineer our other programmers to figure it out, using old and fragmentary documents, and reading the code. We used this sequencer to be compatible with the programming algorithms from previous programmers, so you would think that its operation would be well understood. Well, you would be incorrect.
Processors were slow back in the day, and performance mattered. Even virtual function calls were a big deal, so they had to be used carefully. Try to imagine a day when a single virtual function call took several microseconds. The horror. The horror.
Oh, and one of the things that didn’t work in this compiler was templates any more complicated than auto_ptr, so no performance help there. No STL either, thank you very much.
We had a split architecture, with a PC controlling a batch of embedded systems in real time. We built the whole architecture so that the decision where to split functionality between the PC and the embedded devices could be changed as needed. It was a great architecture if I do say so myself.
Our marketing department was insane, insisting that our programmer cover every device ever conceived from the latest FPGAs to 35-year-old bipolar PALs. Never mind the fact that anyone wanting to program 35-year-old bipolar PALs already had a programmer. Lots of extra work there, to no benefit.
The company needed this project to take about one calendar year, but we had scheduled out the project at 35 man-years, so there was no way that was going to happen with our ten man team. The software was a year less late than the hardware, so we felt pretty good.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/2swaojd458nxvmpc', 'title': 'What is the most difficult C++ programming project you have ever worked on and can you share your code?', 'score': {'original': 0.44465, 'ai': 0.55535}, 'blocks': [{'text': 'The most difficult C++ project I ever worked on was embedded software to control a device programmer at Data I/O. Can’t share code because it’s proprietary. There are a bunch of things that made this project hard.\n\nIt was my first C++ project, and my first project as lead. I was still trying to figure out C++, back in the early 1990s, before the internet. No Stack Overflow\n to ask questions of, no online cppreference.com\n with complete references for every class. Just me and the Annotated Reference Manual. Fortunately, I had a couple of very gentle, kind colleagues to help me with the C++ questions.\nThe compiler we were using was a POS, and our team was apparently doing the most sophisticated coding of anyone using this compiler. Every week we found another thing that should have worked, but did not. As team lead, I had to look up chapter and verse in the ARM to prove the compiler was not correct, write up a simple test case so they could repro the bug, and interact with their somewhat grumpy customer service. The effort was worth it though, because our bugs always got high priority since we could prove they were bugs.\nThe device programmer consisted mostly of this custom VLSI circuit that sequenced changes to voltages on the pins of the device to be programmed. You could be as object oriented as you liked, but there was this one big-ass object in the middle with 200 member functions that you could not refactor because it controlled a single big-ass piece of hardware.\nThat big-ass VLSI sequencer? There was no comprehensive documentation for it. We had to reverse-engineer our other programmers to figure it out, using old and fragmentary documents, and reading the code. We used this sequencer to be compatible with the programming algorithms from previous programmers, so you would think that its operation would be well understood. Well, you would be incorrect.\nProcessors were slow back in the day, and performance mattered. Even virtual function calls were a big deal, so they had to be used carefully. Try to imagine a day when a single virtual function call took several microseconds. The horror. The horror.\nOh, and one of the things that didn’t work in this compiler was templates any more complicated than auto_ptr, so no performance help there. No STL either, thank you very much.\nWe had a split architecture, with a PC controlling a batch of embedded systems in real time. We built the whole architecture so that the decision where to split functionality between the PC and the embedded devices could be changed as needed. It was a great architecture if I do say so myself.\nOur marketing department was insane, insisting that our programmer cover every device ever conceived from the latest FPGAs to 35-year-old bipolar PALs. Never mind the fact that anyone wanting to program 35-year-old bipolar PALs already had a programmer. Lots of extra work there, to no benefit.\nThe company needed this project to take about one calendar year, but we had scheduled out the project at 35 man-years, so there was', 'result': {'fake': 0.1033, 'real': 0.8967}, 'status': 'success'}, {'text': 'no way that was going to happen with our ten man team. The software was a year less late than the hardware, so we felt pretty good.', 'result': {'fake': 0.9965, 'real': 0.0035}, 'status': 'success'}], 'credits_used': 6, 'credits': 1983862, 'subscription': 0, 'content': 'The most difficult C++ project I ever worked on was embedded software to control a device programmer at Data I/O. Can’t share code because it’s proprietary. There are a bunch of things that made this project hard.\n\nIt was my first C++ project, and my first project as lead. I was still trying to figure out C++, back in the early 1990s, before the internet. No Stack Overflow\n to ask questions of, no online cppreference.com\n with complete references for every class. Just me and the Annotated Reference Manual. Fortunately, I had a couple of very gentle, kind colleagues to help me with the C++ questions.\nThe compiler we were using was a POS, and our team was apparently doing the most sophisticated coding of anyone using this compiler. Every week we found another thing that should have worked, but did not. As team lead, I had to look up chapter and verse in the ARM to prove the compiler was not correct, write up a simple test case so they could repro the bug, and interact with their somewhat grumpy customer service. The effort was worth it though, because our bugs always got high priority since we could prove they were bugs.\nThe device programmer consisted mostly of this custom VLSI circuit that sequenced changes to voltages on the pins of the device to be programmed. You could be as object oriented as you liked, but there was this one big-ass object in the middle with 200 member functions that you could not refactor because it controlled a single big-ass piece of hardware.\nThat big-ass VLSI sequencer? There was no comprehensive documentation for it. We had to reverse-engineer our other programmers to figure it out, using old and fragmentary documents, and reading the code. We used this sequencer to be compatible with the programming algorithms from previous programmers, so you would think that its operation would be well understood. Well, you would be incorrect.\nProcessors were slow back in the day, and performance mattered. Even virtual function calls were a big deal, so they had to be used carefully. Try to imagine a day when a single virtual function call took several microseconds. The horror. The horror.\nOh, and one of the things that didn’t work in this compiler was templates any more complicated than auto_ptr, so no performance help there. No STL either, thank you very much.\nWe had a split architecture, with a PC controlling a batch of embedded systems in real time. We built the whole architecture so that the decision where to split functionality between the PC and the embedded devices could be changed as needed. It was a great architecture if I do say so myself.\nOur marketing department was insane, insisting that our programmer cover every device ever conceived from the latest FPGAs to 35-year-old bipolar PALs. Never mind the fact that anyone wanting to program 35-year-old bipolar PALs already had a programmer. Lots of extra work there, to no benefit.\nThe company needed this project to take about one calendar year, but we had scheduled out the project at 35 man-years, so there was no way that was going to happen with our ten man team. The software was a year less late than the hardware, so we felt pretty good.', 'aiModelVersion': '1'}",0.44465
Tom Crosley,4y,What processor and board do you recommend for learning assembly language?,"Unfortunately, the golden age of assembly language is over — I learned on processors like the 6800, 6809, and the 6502 which were a pleasure to program on.

Then along came the 8080 and 8086, which became the 80x86 series with lots of additional instructions every time the x was incremented.

So I would shy away from learning x86 assembly, even though it is popular, just because it has gotten so complex. And full RISC instruction sets like MIPS and ARM were not meant to be programmed in assembly by hand.

So instead I’m going to recommend the PIC16F series. The PIC16 started out with just 35 instructions. It was later expanded to 49, five of them to better accommodate C compilers, but it is still very easy to learn, and there are many many on-line tutorials available. (By comparison, the original 8086 had something like 115 instructions; the latest ones have several hundred.)

This is the entire instruction set for the PIC16F18855
:

Although you could just use a simulator, there’s nothing better than writing your first embedded firmware program and running it on real hardware and seeing it do something, like blinking an LED using a timer and an I/O pin. In fact programs that do so, whether in assembly or C, are essentially the ‘hello world” of embedded systems.

You can buy a board with this microcontroller on it from microchipDIRECT
 for just $12.

The board has holes for a mikroBUS header, which means you can expand the board with over 450 Click boards
. such as displays, sensors, etc., most costing from $10 to $30.

The compiler and development environment are free — you can either use a web-based platform, or download MPLAB X.

The PIC16F18855, with 14 KB flash and 1KB SRAM, has some really interesting features in addition to the usual peripherals such as 7 timers, UART, 2xSPI, and 2xI2C, ADC, DAC and two comparators:

Four Configurable Logic Cells (CLC): Integrated combinational and sequential logic
Three Complementary Waveform Generators (CWG): Rising and falling edge dead-band control; Full-bridge, half-bridge, 1-channel drive- Multiple signal sources
Five Capture/Compare/PWM (CCP) module: 16-bit resolution for Capture/Compare modes; 10-bit resolution for PWM mode
10-bit PWM: Two 10-bit PWMs
Numerically Controlled Oscillator (NCO): Generates true linear frequency control and increased frequency resolution; Input Clock: 0 Hz < FNCO < 32 MHz; Resolution: FNCO/220
Two Signal Measurement Timers (SMT): 24-bit Signal Measurement Timer; Up to 12 different Acquisition modes
Cyclical Redundancy Check (CRC/SCAN): 16-bit CRC; Scans memory for NVM integrity

The processor on the board is surface mount. However it is also available
 in a 28-pin DIP for $1.45 (in single quantities), which is useful for prototyping on a solderless breadboard.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/zp2aq8irfseh4160', 'title': 'What processor and board do you recommend for learning assembly language?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Unfortunately, the golden age of assembly language is over — I learned on processors like the 6800, 6809, and the 6502 which were a pleasure to program on.\n\nThen along came the 8080 and 8086, which became the 80x86 series with lots of additional instructions every time the x was incremented.\n\nSo I would shy away from learning x86 assembly, even though it is popular, just because it has gotten so complex. And full RISC instruction sets like MIPS and ARM were not meant to be programmed in assembly by hand.\n\nSo instead I’m going to recommend the PIC16F series. The PIC16 started out with just 35 instructions. It was later expanded to 49, five of them to better accommodate C compilers, but it is still very easy to learn, and there are many many on-line tutorials available. (By comparison, the original 8086 had something like 115 instructions; the latest ones have several hundred.)\n\nThis is the entire instruction set for the PIC16F18855\n:\n\nAlthough you could just use a simulator, there’s nothing better than writing your first embedded firmware program and running it on real hardware and seeing it do something, like blinking an LED using a timer and an I/O pin. In fact programs that do so, whether in assembly or C, are essentially the ‘hello world” of embedded systems.\n\nYou can buy a board with this microcontroller on it from microchipDIRECT\n for just $12.\n\nThe board has holes for a mikroBUS header, which means you can expand the board with over 450 Click boards\n. such as displays, sensors, etc., most costing from $10 to $30.\n\nThe compiler and development environment are free — you can either use a web-based platform, or download MPLAB X.\n\nThe PIC16F18855, with 14 KB flash and 1KB SRAM, has some really interesting features in addition to the usual peripherals such as 7 timers, UART, 2xSPI, and 2xI2C, ADC, DAC and two comparators:\n\nFour Configurable Logic Cells (CLC): Integrated combinational and sequential logic\nThree Complementary Waveform Generators (CWG): Rising and falling edge dead-band control; Full-bridge, half-bridge, 1-channel drive- Multiple signal sources\nFive Capture/Compare/PWM (CCP) module: 16-bit resolution for Capture/Compare modes; 10-bit resolution for PWM mode\n10-bit PWM: Two 10-bit PWMs\nNumerically Controlled Oscillator (NCO): Generates true linear frequency control and increased frequency resolution; Input Clock: 0 Hz < FNCO < 32 MHz; Resolution: FNCO/220\nTwo Signal Measurement Timers (SMT): 24-bit Signal Measurement Timer; Up to 12 different Acquisition modes\nCyclical Redundancy Check (CRC/SCAN): 16-bit CRC; Scans memory for NVM integrity\n\nThe processor on the board is surface mount. However it is also available\n in a 28-pin DIP for $1.45 (in single quantities), which is useful for prototyping on a solderless breadboard.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983857, 'subscription': 0, 'content': 'Unfortunately, the golden age of assembly language is over — I learned on processors like the 6800, 6809, and the 6502 which were a pleasure to program on.\n\nThen along came the 8080 and 8086, which became the 80x86 series with lots of additional instructions every time the x was incremented.\n\nSo I would shy away from learning x86 assembly, even though it is popular, just because it has gotten so complex. And full RISC instruction sets like MIPS and ARM were not meant to be programmed in assembly by hand.\n\nSo instead I’m going to recommend the PIC16F series. The PIC16 started out with just 35 instructions. It was later expanded to 49, five of them to better accommodate C compilers, but it is still very easy to learn, and there are many many on-line tutorials available. (By comparison, the original 8086 had something like 115 instructions; the latest ones have several hundred.)\n\nThis is the entire instruction set for the PIC16F18855\n:\n\nAlthough you could just use a simulator, there’s nothing better than writing your first embedded firmware program and running it on real hardware and seeing it do something, like blinking an LED using a timer and an I/O pin. In fact programs that do so, whether in assembly or C, are essentially the ‘hello world” of embedded systems.\n\nYou can buy a board with this microcontroller on it from microchipDIRECT\n for just $12.\n\nThe board has holes for a mikroBUS header, which means you can expand the board with over 450 Click boards\n. such as displays, sensors, etc., most costing from $10 to $30.\n\nThe compiler and development environment are free — you can either use a web-based platform, or download MPLAB X.\n\nThe PIC16F18855, with 14 KB flash and 1KB SRAM, has some really interesting features in addition to the usual peripherals such as 7 timers, UART, 2xSPI, and 2xI2C, ADC, DAC and two comparators:\n\nFour Configurable Logic Cells (CLC): Integrated combinational and sequential logic\nThree Complementary Waveform Generators (CWG): Rising and falling edge dead-band control; Full-bridge, half-bridge, 1-channel drive- Multiple signal sources\nFive Capture/Compare/PWM (CCP) module: 16-bit resolution for Capture/Compare modes; 10-bit resolution for PWM mode\n10-bit PWM: Two 10-bit PWMs\nNumerically Controlled Oscillator (NCO): Generates true linear frequency control and increased frequency resolution; Input Clock: 0 Hz < FNCO < 32 MHz; Resolution: FNCO/220\nTwo Signal Measurement Timers (SMT): 24-bit Signal Measurement Timer; Up to 12 different Acquisition modes\nCyclical Redundancy Check (CRC/SCAN): 16-bit CRC; Scans memory for NVM integrity\n\nThe processor on the board is surface mount. However it is also available\n in a 28-pin DIP for $1.45 (in single quantities), which is useful for prototyping on a solderless breadboard.', 'aiModelVersion': '1'}",0.9998
Steve Baker,2y,"Is there any difference between coding in English, German, Hindi or Chinese? Can a coder go from one location to another irrespective of his or her command of the language?","For MOST programming languages - we don’t change the language key-words depending on the language spoken by the programmer.

So in (say) C++, the reserved words like “for”, “while”, “switch” and so forth are the same in all human languages.

But the variable names and comments might not be.

There are a few languages where the compiler allows keywords in different languages - I recall Algol 68 had that…and there is a Chinese version of Python.

There are a very few languages that are not English-based at all - Linotte, for example:

 BonjourLeMonde: 
   début 
     affiche ""Bonjour le monde !"" 

Then, of course languages that have no reserved words at all - and are therefore free of human language. APL being a classic.

life←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵} 

(“life” being a function name - not a part of the language).

But even when everyone agrees to use “English” - it’s never that simple.

I worked for a while at a game company called “Wargaming” who are owned by a group in Cyprus with the majority of their programming work done in the Ukraine, Russia and the USA.

The company required all employees to be able to speak English and to do programming in English.

However, we found that code from our Ukrainian colleagues was often written with English-style variable names but comments in Ukrainian.

I also worked for a while with a team of French graphics programmers - and while they’d theoretically be writing in English, you’d get odd weird words that didn’t make any sense.

So I saw the word “crenelation” in many places in the code.

That’s a word that for me means:

Clearly that’s not what they were talking about - so I consulted a French/English dictionary - and evidently it means the same thing in French.

EVENTUALLY - I saw “anti-crenelation” - and it was then I realized that this must be a French jargon term meaning “aliasing” - the jaggies you get along hard edges in computer graphics:

You can sort of see how the stair-stepping looks a bit (a TINY bit) like the top of a castle wall…but it’s very far from obvious!

This kind of thing is a linguistic problem goes beyond programming languages because jargon words aren’t generally found in dictionaries.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/v5yjom4n30cahpxk', 'title': 'Is there any difference between coding in English, German, Hindi or Chinese? Can a coder go from one location to another irrespective of his or her command of the language?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'For MOST programming languages - we don’t change the language key-words depending on the language spoken by the programmer.\n\nSo in (say) C++, the reserved words like “for”, “while”, “switch” and so forth are the same in all human languages.\n\nBut the variable names and comments might not be.\n\nThere are a few languages where the compiler allows keywords in different languages - I recall Algol 68 had that…and there is a Chinese version of Python.\n\nThere are a very few languages that are not English-based at all - Linotte, for example:\n\n BonjourLeMonde:\xa0\n   début\xa0\n     affiche ""Bonjour le monde !""\xa0\n\nThen, of course languages that have no reserved words at all - and are therefore free of human language. APL being a classic.\n\nlife←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}\xa0\n\n(“life” being a function name - not a part of the language).\n\nBut even when everyone agrees to use “English” - it’s never that simple.\n\nI worked for a while at a game company called “Wargaming” who are owned by a group in Cyprus with the majority of their programming work done in the Ukraine, Russia and the USA.\n\nThe company required all employees to be able to speak English and to do programming in English.\n\nHowever, we found that code from our Ukrainian colleagues was often written with English-style variable names but comments in Ukrainian.\n\nI also worked for a while with a team of French graphics programmers - and while they’d theoretically be writing in English, you’d get odd weird words that didn’t make any sense.\n\nSo I saw the word “crenelation” in many places in the code.\n\nThat’s a word that for me means:\n\nClearly that’s not what they were talking about - so I consulted a French/English dictionary - and evidently it means the same thing in French.\n\nEVENTUALLY - I saw “anti-crenelation” - and it was then I realized that this must be a French jargon term meaning “aliasing” - the jaggies you get along hard edges in computer graphics:\n\nYou can sort of see how the stair-stepping looks a bit (a TINY bit) like the top of a castle wall…but it’s very far from obvious!\n\nThis kind of thing is a linguistic problem goes beyond programming languages because jargon words aren’t generally found in dictionaries.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983853, 'subscription': 0, 'content': 'For MOST programming languages - we don’t change the language key-words depending on the language spoken by the programmer.\n\nSo in (say) C++, the reserved words like “for”, “while”, “switch” and so forth are the same in all human languages.\n\nBut the variable names and comments might not be.\n\nThere are a few languages where the compiler allows keywords in different languages - I recall Algol 68 had that…and there is a Chinese version of Python.\n\nThere are a very few languages that are not English-based at all - Linotte, for example:\n\n BonjourLeMonde:\xa0\n   début\xa0\n     affiche ""Bonjour le monde !""\xa0\n\nThen, of course languages that have no reserved words at all - and are therefore free of human language. APL being a classic.\n\nlife←{↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵}\xa0\n\n(“life” being a function name - not a part of the language).\n\nBut even when everyone agrees to use “English” - it’s never that simple.\n\nI worked for a while at a game company called “Wargaming” who are owned by a group in Cyprus with the majority of their programming work done in the Ukraine, Russia and the USA.\n\nThe company required all employees to be able to speak English and to do programming in English.\n\nHowever, we found that code from our Ukrainian colleagues was often written with English-style variable names but comments in Ukrainian.\n\nI also worked for a while with a team of French graphics programmers - and while they’d theoretically be writing in English, you’d get odd weird words that didn’t make any sense.\n\nSo I saw the word “crenelation” in many places in the code.\n\nThat’s a word that for me means:\n\nClearly that’s not what they were talking about - so I consulted a French/English dictionary - and evidently it means the same thing in French.\n\nEVENTUALLY - I saw “anti-crenelation” - and it was then I realized that this must be a French jargon term meaning “aliasing” - the jaggies you get along hard edges in computer graphics:\n\nYou can sort of see how the stair-stepping looks a bit (a TINY bit) like the top of a castle wall…but it’s very far from obvious!\n\nThis kind of thing is a linguistic problem goes beyond programming languages because jargon words aren’t generally found in dictionaries.', 'aiModelVersion': '1'}",0.9997
Akshay Agarwal,4y,Which is the best way to learn about stocks?,"Just like driving cannot be learned from reading book or seeing some one driving same goes with the stock market as well. For learning the market you have to be in the stock market. But i can very well tell you the best way of making money and that is by long term investing. As a long term investor you will always make good money and earn dividend as well. Download money control which is a vi...

Access this answer and support the author as a Quora+ subscriber
Access all answers reserved by 
Akshay Agarwal
 for Quora+ subscribers
Access exclusive answers from thousands more participating creators in Quora+
Browse ad‑free and support creators
Start free trial
Learn more","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/rchygw8dszfiuob2', 'title': 'Which is the best way to learn about stocks?', 'score': {'original': 0.9994, 'ai': 0.0006}, 'blocks': [{'text': 'Just like driving cannot be learned from reading book or seeing some one driving same goes with the stock market as well. For learning the market you have to be in the stock market. But i can very well tell you the best way of making money and that is by long term investing. As a long term investor you will always make good money and earn dividend as well. Download money control which is a vi...\n\nAccess this answer and support the author as a Quora+ subscriber\nAccess all answers reserved by \nAkshay Agarwal\n for Quora+ subscribers\nAccess exclusive answers from thousands more participating creators in Quora+\nBrowse ad‑free and support creators\nStart free trial\nLearn more', 'result': {'fake': 0.0006, 'real': 0.9994}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983851, 'subscription': 0, 'content': 'Just like driving cannot be learned from reading book or seeing some one driving same goes with the stock market as well. For learning the market you have to be in the stock market. But i can very well tell you the best way of making money and that is by long term investing. As a long term investor you will always make good money and earn dividend as well. Download money control which is a vi...\n\nAccess this answer and support the author as a Quora+ subscriber\nAccess all answers reserved by \nAkshay Agarwal\n for Quora+ subscribers\nAccess exclusive answers from thousands more participating creators in Quora+\nBrowse ad‑free and support creators\nStart free trial\nLearn more', 'aiModelVersion': '1'}",0.9994
Barry Rountree,6y,Is coding really boring and hard?,"Ever worked in the service industry?

Imagine being on your feet for eight hours interacting with strangers who think they’re entitled to order you around. Now imagine you’re doing this at sub-minimum-wage and you need tips to pay your rent. And then imagine that your career path requires doing this well enough to move to more expensive restaurants where tips are potentially larger and the entitlement issues certainly will be.

When I’m coding I can take breaks whenever I like. I have a huge amount of freedom in the problems I choose and how I choose to solve them. I have a worldwide infrastructure that I can turn to for help. And as I’m relatively senior and work for an employer that has a clue, I have an office to myself with a door I can shut.

Am I bored? Occasionally. Are things hard? From time to time. But compared to most people in the US (and certainly the world), I have an easy, exciting job that pays really well.

I try not to forget that.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/vyl70w1xm8cpkrsi', 'title': 'Is coding really boring and hard?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'Ever worked in the service industry?\n\nImagine being on your feet for eight hours interacting with strangers who think they’re entitled to order you around. Now imagine you’re doing this at sub-minimum-wage and you need tips to pay your rent. And then imagine that your career path requires doing this well enough to move to more expensive restaurants where tips are potentially larger and the entitlement issues certainly will be.\n\nWhen I’m coding I can take breaks whenever I like. I have a huge amount of freedom in the problems I choose and how I choose to solve them. I have a worldwide infrastructure that I can turn to for help. And as I’m relatively senior and work for an employer that has a clue, I have an office to myself with a door I can shut.\n\nAm I bored? Occasionally. Are things hard? From time to time. But compared to most people in the US (and certainly the world), I have an easy, exciting job that pays really well.\n\nI try not to forget that.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983849, 'subscription': 0, 'content': 'Ever worked in the service industry?\n\nImagine being on your feet for eight hours interacting with strangers who think they’re entitled to order you around. Now imagine you’re doing this at sub-minimum-wage and you need tips to pay your rent. And then imagine that your career path requires doing this well enough to move to more expensive restaurants where tips are potentially larger and the entitlement issues certainly will be.\n\nWhen I’m coding I can take breaks whenever I like. I have a huge amount of freedom in the problems I choose and how I choose to solve them. I have a worldwide infrastructure that I can turn to for help. And as I’m relatively senior and work for an employer that has a clue, I have an office to myself with a door I can shut.\n\nAm I bored? Occasionally. Are things hard? From time to time. But compared to most people in the US (and certainly the world), I have an easy, exciting job that pays really well.\n\nI try not to forget that.', 'aiModelVersion': '1'}",0.9997
Prashant Asthana,5y,How do you spot a beginner programmer?,"Can you make an app for sharing pictures, something like a Instagram?

Beginner Programmer

The mobile app will be pretty easy, just need to use some native library to display list of pictures.

And for backend service we can use a Tomcat server for the REST APIs.

Will take a max effort of a month.

(Super confident)

Experienced Programmer

Mobile app will need -

Authentication
Authorization
Caching
Edge cases
Basic functionality
Click stream
Unit test cases
Functional test cases
Automated test cases
Native apps for multiple platforms
Common libraries
Continuous integration and deployment.

Backend will require -

Something equivalent to Graph DB
Multiple micro-services
Security of apis
Pen testing
UTs, Functional test cases
Automated test cases
Auto scaling group
Administration module
Stats module
Cdns
CICD
GEO-LOCATION Compliances

And many more things..

The minimal viable product with minimal very very basic functionality will take atleast 3 months with a team of 6–7 good software engineers, an architect, a manager and a UX guy.

(Still thinking what major things are missing in the list)","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/7081omsz3pa52w6i', 'title': 'How do you spot a beginner programmer?', 'score': {'original': 0.9983, 'ai': 0.0017}, 'blocks': [{'text': 'Can you make an app for sharing pictures, something like a Instagram?\n\nBeginner Programmer\n\nThe mobile app will be pretty easy, just need to use some native library to display list of pictures.\n\nAnd for backend service we can use a Tomcat server for the REST APIs.\n\nWill take a max effort of a month.\n\n(Super confident)\n\nExperienced Programmer\n\nMobile app will need -\n\nAuthentication\nAuthorization\nCaching\nEdge cases\nBasic functionality\nClick stream\nUnit test cases\nFunctional test cases\nAutomated test cases\nNative apps for multiple platforms\nCommon libraries\nContinuous integration and deployment.\n\nBackend will require -\n\nSomething equivalent to Graph DB\nMultiple micro-services\nSecurity of apis\nPen testing\nUTs, Functional test cases\nAutomated test cases\nAuto scaling group\nAdministration module\nStats module\nCdns\nCICD\nGEO-LOCATION Compliances\n\nAnd many more things..\n\nThe minimal viable product with minimal very very basic functionality will take atleast 3 months with a team of 6–7 good software engineers, an architect, a manager and a UX guy.\n\n(Still thinking what major things are missing in the list)', 'result': {'fake': 0.0017, 'real': 0.9983}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983847, 'subscription': 0, 'content': 'Can you make an app for sharing pictures, something like a Instagram?\n\nBeginner Programmer\n\nThe mobile app will be pretty easy, just need to use some native library to display list of pictures.\n\nAnd for backend service we can use a Tomcat server for the REST APIs.\n\nWill take a max effort of a month.\n\n(Super confident)\n\nExperienced Programmer\n\nMobile app will need -\n\nAuthentication\nAuthorization\nCaching\nEdge cases\nBasic functionality\nClick stream\nUnit test cases\nFunctional test cases\nAutomated test cases\nNative apps for multiple platforms\nCommon libraries\nContinuous integration and deployment.\n\nBackend will require -\n\nSomething equivalent to Graph DB\nMultiple micro-services\nSecurity of apis\nPen testing\nUTs, Functional test cases\nAutomated test cases\nAuto scaling group\nAdministration module\nStats module\nCdns\nCICD\nGEO-LOCATION Compliances\n\nAnd many more things..\n\nThe minimal viable product with minimal very very basic functionality will take atleast 3 months with a team of 6–7 good software engineers, an architect, a manager and a UX guy.\n\n(Still thinking what major things are missing in the list)', 'aiModelVersion': '1'}",0.9983
Robin Thomas,Updated 6y,What are some important things that I should know in order to become a good coder?,"Do not think that the more languages you know, the better you will be.
Code. Code. Code! The more you do, the better you can become. Start an open source project. Or contribute to one. Perseverance is the key.
If you are using an IDE, make sure you become well versed in it. Customize it to yield your maximum efficiency. Learn all the keyboard shortcuts. Etch it into muscle memory.
Learn about debugging, version control, and unit tests.
Solve problems for which others are willing to pay. Or build something that might be helpful for some.
Do not try to build an exhaustive memory of all the data structures, algorithms and syntax. It’s more about how you think, rather than what you remember.
You are the average of the people you surround yourselves with. So find good people and mentors to learn from and learn with. Build a feedback loop.
Learn new programming paradigms. If don’t know OOPs, learn OOPs. You don’t know functional programming, learn it. Exposing to such new materials should improve your problem solving capability.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wub46i07t98g1xdl', 'title': 'What are some important things that I should know in order to become a good coder?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'Do not think that the more languages you know, the better you will be.\nCode. Code. Code! The more you do, the better you can become. Start an open source project. Or contribute to one. Perseverance is the key.\nIf you are using an IDE, make sure you become well versed in it. Customize it to yield your maximum efficiency. Learn all the keyboard shortcuts. Etch it into muscle memory.\nLearn about debugging, version control, and unit tests.\nSolve problems for which others are willing to pay. Or build something that might be helpful for some.\nDo not try to build an exhaustive memory of all the data structures, algorithms and syntax. It’s more about how you think, rather than what you remember.\nYou are the average of the people you surround yourselves with. So find good people and mentors to learn from and learn with. Build a feedback loop.\nLearn new programming paradigms. If don’t know OOPs, learn OOPs. You don’t know functional programming, learn it. Exposing to such new materials should improve your problem solving capability.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983845, 'subscription': 0, 'content': 'Do not think that the more languages you know, the better you will be.\nCode. Code. Code! The more you do, the better you can become. Start an open source project. Or contribute to one. Perseverance is the key.\nIf you are using an IDE, make sure you become well versed in it. Customize it to yield your maximum efficiency. Learn all the keyboard shortcuts. Etch it into muscle memory.\nLearn about debugging, version control, and unit tests.\nSolve problems for which others are willing to pay. Or build something that might be helpful for some.\nDo not try to build an exhaustive memory of all the data structures, algorithms and syntax. It’s more about how you think, rather than what you remember.\nYou are the average of the people you surround yourselves with. So find good people and mentors to learn from and learn with. Build a feedback loop.\nLearn new programming paradigms. If don’t know OOPs, learn OOPs. You don’t know functional programming, learn it. Exposing to such new materials should improve your problem solving capability.', 'aiModelVersion': '1'}",0.9995
Divanshu Singh,9y,How are students in Indian colleges taught programming?,"Our teacher has taught to write code like this in C.

void main()
{

}

I got zero in all question of coding in exam because my main function looked like this:


int main(int argc, char *argv[ ])
{

return 0;
}


When I asked teacher about this. She said - ""You don't pay attention in class. This is not what I taught. Don't argue with me or I will fail you in final practical exam.""","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/xh5idk6ounq7tmcb', 'title': 'How are students in Indian colleges taught programming?', 'score': {'original': 0.9951, 'ai': 0.0049}, 'blocks': [{'text': 'Our teacher has taught to write code like this in C.\n\nvoid main()\n{\n\n}\n\nI got zero in all question of coding in exam because my main function looked like this:\n\n\nint main(int argc, char *argv[ ])\n{\n\nreturn 0;\n}\n\n\nWhen I asked teacher about this. She said - ""You don\'t pay attention in class. This is not what I taught. Don\'t argue with me or I will fail you in final practical exam.""', 'result': {'fake': 0.1122, 'real': 0.8878}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983844, 'subscription': 0, 'content': 'Our teacher has taught to write code like this in C.\n\nvoid main()\n{\n\n}\n\nI got zero in all question of coding in exam because my main function looked like this:\n\n\nint main(int argc, char *argv[ ])\n{\n\nreturn 0;\n}\n\n\nWhen I asked teacher about this. She said - ""You don\'t pay attention in class. This is not what I taught. Don\'t argue with me or I will fail you in final practical exam.""', 'aiModelVersion': '1'}",0.9951
Dave Voorhis,Updated 3y,Will no-code make it unnecessary to learn a programming language?,"“No code” or “Low code” systems have been promoted since the 1970’s. Some, like Microsoft Excel (calculations), Crystal Reports (reporting), Tableau (data visualisation) and Labview (lab automation) are very successful within their specialist niches.

But general-purpose “No code” and “Low code” systems have never worked well, and because they’ve never worked well, they’ve never caught on.

The problem is that general-purpose “No code” and “Low code” system vendors misunderstand what makes programming hard and complex.

They think the problem is syntax, specifically text syntax. They think what makes Python or Java or C difficult is writing code as text, and that if they can replace it with something graphical or diagrammatic or templated, it will become much easier.

It won’t and it doesn’t.

The reality is that general-purpose programming is not — or at least very little — about syntax. It’s very much about manipulating the concepts of evaluation, iteration, selection, ordering, state, expressions, procedures, functions, and commands.

It doesn’t matter whether you do that with diagrams or templates or text, the essential complexity lies in manipulating the concepts — in other words, the semantics of programming — and not the syntax.

That’s why general-purpose “No code” systems don’t work. They either leave out crucial concepts or semantics that need to be manipulated, or they make manipulating them slower, more awkward, and actually more complex than using text.

For general-purpose programming, it turns out that text — code — is the most effective way to express intent to a computer. Anything and everything else is slower, more complex, more awkward, and more difficult.

As an example and an analogy, imagine this answer had to be written both as English text (which it is) and as a diagram without words.

Which do you think would be easier to write, the English text version?

Or the diagram version?

Which do you think would be easier to understand?

The same applies to general-purpose programming.

Therefore — to answer your original question — for the foreseeable future, “No Code” will not make it unnecessary to learn a programming language, if you intend to do the general-purpose programming things for which general-purpose programming languages are best.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/rua5qcdz81het3m4', 'title': 'Will no-code make it unnecessary to learn a programming language?', 'score': {'original': 0.9991, 'ai': 0.0009}, 'blocks': [{'text': '“No code” or “Low code” systems have been promoted since the 1970’s. Some, like Microsoft Excel (calculations), Crystal Reports (reporting), Tableau (data visualisation) and Labview (lab automation) are very successful within their specialist niches.\n\nBut general-purpose “No code” and “Low code” systems have never worked well, and because they’ve never worked well, they’ve never caught on.\n\nThe problem is that general-purpose “No code” and “Low code” system vendors misunderstand what makes programming hard and complex.\n\nThey think the problem is syntax, specifically text syntax. They think what makes Python or Java or C difficult is writing code as text, and that if they can replace it with something graphical or diagrammatic or templated, it will become much easier.\n\nIt won’t and it doesn’t.\n\nThe reality is that general-purpose programming is not — or at least very little — about syntax. It’s very much about manipulating the concepts of evaluation, iteration, selection, ordering, state, expressions, procedures, functions, and commands.\n\nIt doesn’t matter whether you do that with diagrams or templates or text, the essential complexity lies in manipulating the concepts — in other words, the semantics of programming — and not the syntax.\n\nThat’s why general-purpose “No code” systems don’t work. They either leave out crucial concepts or semantics that need to be manipulated, or they make manipulating them slower, more awkward, and actually more complex than using text.\n\nFor general-purpose programming, it turns out that text — code — is the most effective way to express intent to a computer. Anything and everything else is slower, more complex, more awkward, and more difficult.\n\nAs an example and an analogy, imagine this answer had to be written both as English text (which it is) and as a diagram without words.\n\nWhich do you think would be easier to write, the English text version?\n\nOr the diagram version?\n\nWhich do you think would be easier to understand?\n\nThe same applies to general-purpose programming.\n\nTherefore — to answer your original question — for the foreseeable future, “No Code” will not make it unnecessary to learn a programming language, if you intend to do the general-purpose programming things for which general-purpose programming languages are best.', 'result': {'fake': 0.0009, 'real': 0.9991}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983840, 'subscription': 0, 'content': '“No code” or “Low code” systems have been promoted since the 1970’s. Some, like Microsoft Excel (calculations), Crystal Reports (reporting), Tableau (data visualisation) and Labview (lab automation) are very successful within their specialist niches.\n\nBut general-purpose “No code” and “Low code” systems have never worked well, and because they’ve never worked well, they’ve never caught on.\n\nThe problem is that general-purpose “No code” and “Low code” system vendors misunderstand what makes programming hard and complex.\n\nThey think the problem is syntax, specifically text syntax. They think what makes Python or Java or C difficult is writing code as text, and that if they can replace it with something graphical or diagrammatic or templated, it will become much easier.\n\nIt won’t and it doesn’t.\n\nThe reality is that general-purpose programming is not — or at least very little — about syntax. It’s very much about manipulating the concepts of evaluation, iteration, selection, ordering, state, expressions, procedures, functions, and commands.\n\nIt doesn’t matter whether you do that with diagrams or templates or text, the essential complexity lies in manipulating the concepts — in other words, the semantics of programming — and not the syntax.\n\nThat’s why general-purpose “No code” systems don’t work. They either leave out crucial concepts or semantics that need to be manipulated, or they make manipulating them slower, more awkward, and actually more complex than using text.\n\nFor general-purpose programming, it turns out that text — code — is the most effective way to express intent to a computer. Anything and everything else is slower, more complex, more awkward, and more difficult.\n\nAs an example and an analogy, imagine this answer had to be written both as English text (which it is) and as a diagram without words.\n\nWhich do you think would be easier to write, the English text version?\n\nOr the diagram version?\n\nWhich do you think would be easier to understand?\n\nThe same applies to general-purpose programming.\n\nTherefore — to answer your original question — for the foreseeable future, “No Code” will not make it unnecessary to learn a programming language, if you intend to do the general-purpose programming things for which general-purpose programming languages are best.', 'aiModelVersion': '1'}",0.9991
Alan Mellor,3y,"What would be my level at programming if I could solve all the problems of ""LeetCode""?","It would be of a kind I don’t really understand.

I’ve never written code as a puzzle. I’ve only ever written code as part of making a thing work. I’ve written games, embedded systems, software tools, half a word processor, banking and tax software, e-commerce.

Each thing brings its own set of challenges that need solving. Some I don’t know how to solve and have to figure it out.

I think the kinds of problems are different from those in coding katas and challenges.

So I wouldn’t know what to think.

Could you write a full application? I wouldn’t be able to know, I don’t think.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/mk93b15qia2gjp4o', 'title': 'What would be my level at programming if I could solve all the problems of ""LeetCode""?', 'score': {'original': 0.0835, 'ai': 0.9165}, 'blocks': [{'text': 'It would be of a kind I don’t really understand.\n\nI’ve never written code as a puzzle. I’ve only ever written code as part of making a thing work. I’ve written games, embedded systems, software tools, half a word processor, banking and tax software, e-commerce.\n\nEach thing brings its own set of challenges that need solving. Some I don’t know how to solve and have to figure it out.\n\nI think the kinds of problems are different from those in coding katas and challenges.\n\nSo I wouldn’t know what to think.\n\nCould you write a full application? I wouldn’t be able to know, I don’t think.', 'result': {'fake': 0.9165, 'real': 0.0835}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983838, 'subscription': 0, 'content': 'It would be of a kind I don’t really understand.\n\nI’ve never written code as a puzzle. I’ve only ever written code as part of making a thing work. I’ve written games, embedded systems, software tools, half a word processor, banking and tax software, e-commerce.\n\nEach thing brings its own set of challenges that need solving. Some I don’t know how to solve and have to figure it out.\n\nI think the kinds of problems are different from those in coding katas and challenges.\n\nSo I wouldn’t know what to think.\n\nCould you write a full application? I wouldn’t be able to know, I don’t think.', 'aiModelVersion': '1'}",0.0835
Brian Bi,8y,What unique rewards are awaiting a programmer who goes through the hardships of mastering C++?,"Hmm. Well, apparently, there's Wall Street. I hear that high frequency trading shops need people who can write C++ code that is both complex and highly efficient, demanding mastery of the language. For example, they might use static polymorphism with templates, instead of runtime polymorphism which suffers from the overhead of virtual function calls. So you could go that route, and make $$$.

I guess I have to stop being modest for a few minutes since I was A2Aed. I would say the knowledge is its own reward. I find it intensely satisfying to understand and take advantage of the arcane details of complex systems (and C++ certainly is one). Besides that, I enjoy the respect I receive on account of being knowledgeable about C++.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ceyjlmdvh81qu4r5', 'title': 'What unique rewards are awaiting a programmer who goes through the hardships of mastering C++?', 'score': {'original': 0.9991, 'ai': 0.0009}, 'blocks': [{'text': ""Hmm. Well, apparently, there's Wall Street. I hear that high frequency trading shops need people who can write C++ code that is both complex and highly efficient, demanding mastery of the language. For example, they might use static polymorphism with templates, instead of runtime polymorphism which suffers from the overhead of virtual function calls. So you could go that route, and make $$$.\n\nI guess I have to stop being modest for a few minutes since I was A2Aed. I would say the knowledge is its own reward. I find it intensely satisfying to understand and take advantage of the arcane details of complex systems (and C++ certainly is one). Besides that, I enjoy the respect I receive on account of being knowledgeable about C++."", 'result': {'fake': 0.0009, 'real': 0.9991}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983836, 'subscription': 0, 'content': ""Hmm. Well, apparently, there's Wall Street. I hear that high frequency trading shops need people who can write C++ code that is both complex and highly efficient, demanding mastery of the language. For example, they might use static polymorphism with templates, instead of runtime polymorphism which suffers from the overhead of virtual function calls. So you could go that route, and make $$$.\n\nI guess I have to stop being modest for a few minutes since I was A2Aed. I would say the knowledge is its own reward. I find it intensely satisfying to understand and take advantage of the arcane details of complex systems (and C++ certainly is one). Besides that, I enjoy the respect I receive on account of being knowledgeable about C++."", 'aiModelVersion': '1'}",0.9991
Alan Kay,Updated 3y,Is there a programming language that uses past and future tense?,"Some very confident (why?) answers here about “no, there aren’t programming languages with past tense”. Or “there isn’t any reason for such a thing”.

But take a look at Lucid, by Wadge and Ashcroft. Its variables are histories of the values, so the various kinds of past tense can be used. Lucid (programming language) - Wikipedia

Also, there have been a number of experiments and proposals for “world-lines” in programming, especially “good old real AI” programming. These go all the way back to John McCarthy’s “Situations, Actions, and Causal Laws” papers in the 60s. A “situation” is a past whole state of a system, and it is reached by a “past tense” operation.

These ideas are important on a number of fronts (for example, think of the many ways that a “general UNDO” at any granularity could vastly help programming and debugging). Both databases (usually) and user interfaces (sometimes) have unlimited undoes and looks at the historical past, but this is also very useful for finer grained programming, AI, etc.

Histories and tenses can be implemented in languages with a decent meta-framework (e.g. Lisp, Smalltalk, etc.). Here is a paper about such an experiment: http://www.vpri.org/pdf/tr2011001_final_worlds.pdf","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/hdxm9knrpczgat7w', 'title': 'Is there a programming language that uses past and future tense?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Some very confident (why?) answers here about “no, there aren’t programming languages with past tense”. Or “there isn’t any reason for such a thing”.\n\nBut take a look at Lucid, by Wadge and Ashcroft. Its variables are histories of the values, so the various kinds of past tense can be used. Lucid (programming language) - Wikipedia\n\nAlso, there have been a number of experiments and proposals for “world-lines” in programming, especially “good old real AI” programming. These go all the way back to John McCarthy’s “Situations, Actions, and Causal Laws” papers in the 60s. A “situation” is a past whole state of a system, and it is reached by a “past tense” operation.\n\nThese ideas are important on a number of fronts (for example, think of the many ways that a “general UNDO” at any granularity could vastly help programming and debugging). Both databases (usually) and user interfaces (sometimes) have unlimited undoes and looks at the historical past, but this is also very useful for finer grained programming, AI, etc.\n\nHistories and tenses can be implemented in languages with a decent meta-framework (e.g. Lisp, Smalltalk, etc.). Here is a paper about such an experiment: http://www.vpri.org/pdf/tr2011001_final_worlds.pdf', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983833, 'subscription': 0, 'content': 'Some very confident (why?) answers here about “no, there aren’t programming languages with past tense”. Or “there isn’t any reason for such a thing”.\n\nBut take a look at Lucid, by Wadge and Ashcroft. Its variables are histories of the values, so the various kinds of past tense can be used. Lucid (programming language) - Wikipedia\n\nAlso, there have been a number of experiments and proposals for “world-lines” in programming, especially “good old real AI” programming. These go all the way back to John McCarthy’s “Situations, Actions, and Causal Laws” papers in the 60s. A “situation” is a past whole state of a system, and it is reached by a “past tense” operation.\n\nThese ideas are important on a number of fronts (for example, think of the many ways that a “general UNDO” at any granularity could vastly help programming and debugging). Both databases (usually) and user interfaces (sometimes) have unlimited undoes and looks at the historical past, but this is also very useful for finer grained programming, AI, etc.\n\nHistories and tenses can be implemented in languages with a decent meta-framework (e.g. Lisp, Smalltalk, etc.). Here is a paper about such an experiment: http://www.vpri.org/pdf/tr2011001_final_worlds.pdf', 'aiModelVersion': '1'}",0.9998
Scott Schafer,5y,What percent of a good programmer's work is researched online? Is real coding dead?,"When I was fifteen, I spent a summer trying to make a fairly complex arcade game. I hoped to sell it. This was in 1983, and the only tool I had at my disposal was this book:

Google, github or stackoverflow did not exist. The web did not exist. Every single pixel on the screen in my game was manipulated by code that I wrote in assembly language. Every vibration of the speaker was under my code’s control. Oh - I also designed all the graphics and the fonts by hand. And of course, I wrote the code to render fonts as well.

If this all seems overly ambitious, I already had a published program under my belt by then, and another accepted for publication.

Ultimately, I ran into hardware limitations and abandoned the game. A friend/classmate of mine offered to take it over. Although he wasn’t able to complete it, he said he found it quite impressive (he eventually became an engineering manager at Google and retired early, BTW).

Now I’m fifty, and still writing code professionally. I use Google and other online sources a lot, and I frequently use code I don’t deeply understand.

Just for grins (and because I thought it would be a fun project to do with my son, and because I wanted to learn some new technologies), I thought to make a retro arcade game.

It took me maybe the equivalent of two weeks to put together. I used all kinds of open source libraries, graphics and music. My kid designed it (kind of), I wrote the code, except for the open source third party stuff.

You can play it here: BowlBlaster!

Is real coding dead because programmers don’t have to handle all of the low-level details anymore since they have better tools? That’s ridiculous. I wrote this game, even if I didn’t have to write the code to render fonts, and even if I used (and adapted) some maze generation code I found on github. These tools saved me a lot of time, but they didn’t lessen the achievement - they actually just made it possible for me to crank this out and move on to the next thing.

There was once a time when painters ground their own pigments and had to stretch their own canvases. Art didn’t die when pre-made paints and canvases became available. Coding is no different.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/bf8wm41g26covnrj', 'title': ""What percent of a good programmer's work is researched online? Is real coding dead?"", 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'When I was fifteen, I spent a summer trying to make a fairly complex arcade game. I hoped to sell it. This was in 1983, and the only tool I had at my disposal was this book:\n\nGoogle, github or stackoverflow did not exist. The web did not exist. Every single pixel on the screen in my game was manipulated by code that I wrote in assembly language. Every vibration of the speaker was under my code’s control. Oh - I also designed all the graphics and the fonts by hand. And of course, I wrote the code to render fonts as well.\n\nIf this all seems overly ambitious, I already had a published program under my belt by then, and another accepted for publication.\n\nUltimately, I ran into hardware limitations and abandoned the game. A friend/classmate of mine offered to take it over. Although he wasn’t able to complete it, he said he found it quite impressive (he eventually became an engineering manager at Google and retired early, BTW).\n\nNow I’m fifty, and still writing code professionally. I use Google and other online sources a lot, and I frequently use code I don’t deeply understand.\n\nJust for grins (and because I thought it would be a fun project to do with my son, and because I wanted to learn some new technologies), I thought to make a retro arcade game.\n\nIt took me maybe the equivalent of two weeks to put together. I used all kinds of open source libraries, graphics and music. My kid designed it (kind of), I wrote the code, except for the open source third party stuff.\n\nYou can play it here: BowlBlaster!\n\nIs real coding dead because programmers don’t have to handle all of the low-level details anymore since they have better tools? That’s ridiculous. I wrote this game, even if I didn’t have to write the code to render fonts, and even if I used (and adapted) some maze generation code I found on github. These tools saved me a lot of time, but they didn’t lessen the achievement - they actually just made it possible for me to crank this out and move on to the next thing.\n\nThere was once a time when painters ground their own pigments and had to stretch their own canvases. Art didn’t die when pre-made paints and canvases became available. Coding is no different.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983828, 'subscription': 0, 'content': 'When I was fifteen, I spent a summer trying to make a fairly complex arcade game. I hoped to sell it. This was in 1983, and the only tool I had at my disposal was this book:\n\nGoogle, github or stackoverflow did not exist. The web did not exist. Every single pixel on the screen in my game was manipulated by code that I wrote in assembly language. Every vibration of the speaker was under my code’s control. Oh - I also designed all the graphics and the fonts by hand. And of course, I wrote the code to render fonts as well.\n\nIf this all seems overly ambitious, I already had a published program under my belt by then, and another accepted for publication.\n\nUltimately, I ran into hardware limitations and abandoned the game. A friend/classmate of mine offered to take it over. Although he wasn’t able to complete it, he said he found it quite impressive (he eventually became an engineering manager at Google and retired early, BTW).\n\nNow I’m fifty, and still writing code professionally. I use Google and other online sources a lot, and I frequently use code I don’t deeply understand.\n\nJust for grins (and because I thought it would be a fun project to do with my son, and because I wanted to learn some new technologies), I thought to make a retro arcade game.\n\nIt took me maybe the equivalent of two weeks to put together. I used all kinds of open source libraries, graphics and music. My kid designed it (kind of), I wrote the code, except for the open source third party stuff.\n\nYou can play it here: BowlBlaster!\n\nIs real coding dead because programmers don’t have to handle all of the low-level details anymore since they have better tools? That’s ridiculous. I wrote this game, even if I didn’t have to write the code to render fonts, and even if I used (and adapted) some maze generation code I found on github. These tools saved me a lot of time, but they didn’t lessen the achievement - they actually just made it possible for me to crank this out and move on to the next thing.\n\nThere was once a time when painters ground their own pigments and had to stretch their own canvases. Art didn’t die when pre-made paints and canvases became available. Coding is no different.', 'aiModelVersion': '1'}",0.9998
Dean Rubine,Updated Jan 25,Why does the C programming language refuse to die?,"I’ve been programming in C (not C++) since 1975. The purpose of C was to wean programmers off of assembly language, which by definition is not portable between different types of hardware. So C was sort of a universal assembly language, designed to be very low level, close to the machine, but at a high enough level to make programs (potentially) easy to read and maintain, and be portable across architectures.

It worked incredibly well. In 1975 all of Unix, including the kernel, the utilities including a C compiler, and the documentation, fit on a 3 megabyte RK03 disk drive. It’s hard to imagine now. I bet Hello World in C++ is about that big.

[RK03 was a 14 inch wide, couple inches tall, removable disk that held 3 megabytes. It was inserted into a drive that was about five rack spaces in a 19″ rack.]

At my first summer internship at Bell Labs in 1978, my job was to port UNIX utilities to the VAX 11/780, a 32 bit machine compared to the 16 bit PDP 11/70 we were running. It was pretty great; it seemed like I had a whole VAX for myself (the OS developers by then were mainly waiting around for bugs to fix) in July. Over a weekend around August 1, 1978 we switched the entire UNIX Development department to the VAX (and then I had a PDP 11 all to myself). It was an incredible demonstration of the portability of C and UNIX; maybe the first of that magnitude.

C is still used in the mainstream programming world to write compilers and interpreters for higher level languages, though as resources have become more abundant over the decades, C++ and other languages have taken over most of that. Probably for operating systems, necessarily close to the machine, C is still pretty popular. C lives on these days as the language of choice for programming embedded microcontrollers, which are in pretty much every electronic device. C is a great fit, allowing a relatively high level environment that creates code small and efficient enough to run on the cheapest, most pared back microcontroller. It seems like there’s always going to be competition at the low end, where shaving pennies by going with the cheapest microcontroller is valuable, so it seems like there will continue to be a niche for C for the foreseeable future.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/834uolbwxrgeavmz', 'title': 'Why does the C programming language refuse to die?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'I’ve been programming in C (not C++) since 1975. The purpose of C was to wean programmers off of assembly language, which by definition is not portable between different types of hardware. So C was sort of a universal assembly language, designed to be very low level, close to the machine, but at a high enough level to make programs (potentially) easy to read and maintain, and be portable across architectures.\n\nIt worked incredibly well. In 1975 all of Unix, including the kernel, the utilities including a C compiler, and the documentation, fit on a 3 megabyte RK03 disk drive. It’s hard to imagine now. I bet Hello World in C++ is about that big.\n\n[RK03 was a 14 inch wide, couple inches tall, removable disk that held 3 megabytes. It was inserted into a drive that was about five rack spaces in a 19″ rack.]\n\nAt my first summer internship at Bell Labs in 1978, my job was to port UNIX utilities to the VAX 11/780, a 32 bit machine compared to the 16 bit PDP 11/70 we were running. It was pretty great; it seemed like I had a whole VAX for myself (the OS developers by then were mainly waiting around for bugs to fix) in July. Over a weekend around August 1, 1978 we switched the entire UNIX Development department to the VAX (and then I had a PDP 11 all to myself). It was an incredible demonstration of the portability of C and UNIX; maybe the first of that magnitude.\n\nC is still used in the mainstream programming world to write compilers and interpreters for higher level languages, though as resources have become more abundant over the decades, C++ and other languages have taken over most of that. Probably for operating systems, necessarily close to the machine, C is still pretty popular. C lives on these days as the language of choice for programming embedded microcontrollers, which are in pretty much every electronic device. C is a great fit, allowing a relatively high level environment that creates code small and efficient enough to run on the cheapest, most pared back microcontroller. It seems like there’s always going to be competition at the low end, where shaving pennies by going with the cheapest microcontroller is valuable, so it seems like there will continue to be a niche for C for the foreseeable future.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983824, 'subscription': 0, 'content': 'I’ve been programming in C (not C++) since 1975. The purpose of C was to wean programmers off of assembly language, which by definition is not portable between different types of hardware. So C was sort of a universal assembly language, designed to be very low level, close to the machine, but at a high enough level to make programs (potentially) easy to read and maintain, and be portable across architectures.\n\nIt worked incredibly well. In 1975 all of Unix, including the kernel, the utilities including a C compiler, and the documentation, fit on a 3 megabyte RK03 disk drive. It’s hard to imagine now. I bet Hello World in C++ is about that big.\n\n[RK03 was a 14 inch wide, couple inches tall, removable disk that held 3 megabytes. It was inserted into a drive that was about five rack spaces in a 19″ rack.]\n\nAt my first summer internship at Bell Labs in 1978, my job was to port UNIX utilities to the VAX 11/780, a 32 bit machine compared to the 16 bit PDP 11/70 we were running. It was pretty great; it seemed like I had a whole VAX for myself (the OS developers by then were mainly waiting around for bugs to fix) in July. Over a weekend around August 1, 1978 we switched the entire UNIX Development department to the VAX (and then I had a PDP 11 all to myself). It was an incredible demonstration of the portability of C and UNIX; maybe the first of that magnitude.\n\nC is still used in the mainstream programming world to write compilers and interpreters for higher level languages, though as resources have become more abundant over the decades, C++ and other languages have taken over most of that. Probably for operating systems, necessarily close to the machine, C is still pretty popular. C lives on these days as the language of choice for programming embedded microcontrollers, which are in pretty much every electronic device. C is a great fit, allowing a relatively high level environment that creates code small and efficient enough to run on the cheapest, most pared back microcontroller. It seems like there’s always going to be competition at the low end, where shaving pennies by going with the cheapest microcontroller is valuable, so it seems like there will continue to be a niche for C for the foreseeable future.', 'aiModelVersion': '1'}",0.9997
Steve Johnson,10mo,Why was the C programming language designed as a successor of the B programming language rather than being designed from scratch?,"What is very hard to convey is how rich the intellectual environment of the Unix group was a Bell Labs. Shortly after its invention, B had a dozen or more users who worked with it and gave feedback on what worked and what didn’t. Dennis produced a new B compiler every few days, and carefully left the previous one in a known place. So when there were bugs, users of B sent mail to Dennis and used the previous compiler until the new one was fixed.

Technically, there were two main reasons to change the name from B to C. One was that B (and BCPL) assumed that the hardware was word addressed, and this assumption was the basis of the implementation of arrays. The industry was moving to byte-addressed hardware, and the PDP-11 was byte-addressed. The other is that B’s datatypes were rudimentary. There was no way to declare a 2-dimensional array without great pain. Also, strong typing was trendy at that time and had a lot of advantages.

But for the most part, B’s syntax of functions made sense for C and was adopted as the starting point of the language. Most of us converted to C even before the major additions were added — structs, unions, and multidimensional arrays — and used the new features as they were added.

As C matured, there was interest in having it run on larger computers like the mainframes in the computing centers. A dialect of FORTRAN that would run the same on the six mainframe architectures that supported FORTRAN had been around for several years, and we started looking at how C would look with this added portability.

At the time, I was working on Yacc and decided to see whether we could base the front end of a C compiler on a Yacc grammar. The experiment was successful—we could compile the programs into syntax trees. To debug Yacc, I wrote a back end that would find common errors when several files were compiled together. This evolved into Lint—we could take a C program written for one machine and run Lint on it on another machine and see what the problems were. A number of syntax and semantic ideas were tested out on Lint before deciding whether to move them into C. I should mention that I deferred to Dennis on what C should be.

And one day there was a fateful discussion between Dennis and me. He said, in effect, “It appears to me that it would be easier to move a C program to multiple computers than to take applications on one computer and rewrite them for another.” The result of that discussion is that I devoted several years to making pcc, the Portable C Compiler. Dennis and Ken worked over the Unix kernel code and others fixed portability problems in the commands.

This is a long answer, but the ending point was profound. pcc was ported to roughly 200 different architectures. And the Unix architecture dominated operating systems because it was easy (most of the time) to port C. In fact, hardware design was affected because designers would simulate real applications and optimize the hardware for the best performance.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/hsf78aplgy63r4cv', 'title': 'Why was the C programming language designed as a successor of the B programming language rather than being designed from scratch?', 'score': {'original': 0.49965, 'ai': 0.50035}, 'blocks': [{'text': 'What is very hard to convey is how rich the intellectual environment of the Unix group was a Bell Labs. Shortly after its invention, B had a dozen or more users who worked with it and gave feedback on what worked and what didn’t. Dennis produced a new B compiler every few days, and carefully left the previous one in a known place. So when there were bugs, users of B sent mail to Dennis and used the previous compiler until the new one was fixed.\n\nTechnically, there were two main reasons to change the name from B to C. One was that B (and BCPL) assumed that the hardware was word addressed, and this assumption was the basis of the implementation of arrays. The industry was moving to byte-addressed hardware, and the PDP-11 was byte-addressed. The other is that B’s datatypes were rudimentary. There was no way to declare a 2-dimensional array without great pain. Also, strong typing was trendy at that time and had a lot of advantages.\n\nBut for the most part, B’s syntax of functions made sense for C and was adopted as the starting point of the language. Most of us converted to C even before the major additions were added — structs, unions, and multidimensional arrays — and used the new features as they were added.\n\nAs C matured, there was interest in having it run on larger computers like the mainframes in the computing centers. A dialect of FORTRAN that would run the same on the six mainframe architectures that supported FORTRAN had been around for several years, and we started looking at how C would look with this added portability.\n\nAt the time, I was working on Yacc and decided to see whether we could base the front end of a C compiler on a Yacc grammar. The experiment was successful—we could compile the programs into syntax trees. To debug Yacc, I wrote a back end that would find common errors when several files were compiled together. This evolved into Lint—we could take a C program written for one machine and run Lint on it on another machine and see what the problems were. A number of syntax and semantic ideas were tested out on Lint before deciding whether to move them into C. I should mention that I deferred to Dennis on what C should be.\n\nAnd one day there was a fateful discussion between Dennis and me. He said, in effect, “It appears to me that it would be easier to move a C program to multiple computers than to take applications on one computer and rewrite them for another.” The result of that discussion is that I devoted several years to making pcc, the Portable C Compiler. Dennis and Ken worked over the Unix kernel code and others fixed portability problems in the commands.\n\nThis is a long answer, but the ending point was profound. pcc was ported to roughly 200 different architectures. And the Unix architecture dominated operating systems because it was easy (most of the time) to port C. In fact, hardware design was affected', 'result': {'fake': 0.0266, 'real': 0.9734}, 'status': 'success'}, {'text': 'because designers would simulate real applications and optimize the hardware for the best performance.', 'result': {'fake': 1, 'real': 0}, 'status': 'success'}], 'credits_used': 6, 'credits': 1983818, 'subscription': 0, 'content': 'What is very hard to convey is how rich the intellectual environment of the Unix group was a Bell Labs. Shortly after its invention, B had a dozen or more users who worked with it and gave feedback on what worked and what didn’t. Dennis produced a new B compiler every few days, and carefully left the previous one in a known place. So when there were bugs, users of B sent mail to Dennis and used the previous compiler until the new one was fixed.\n\nTechnically, there were two main reasons to change the name from B to C. One was that B (and BCPL) assumed that the hardware was word addressed, and this assumption was the basis of the implementation of arrays. The industry was moving to byte-addressed hardware, and the PDP-11 was byte-addressed. The other is that B’s datatypes were rudimentary. There was no way to declare a 2-dimensional array without great pain. Also, strong typing was trendy at that time and had a lot of advantages.\n\nBut for the most part, B’s syntax of functions made sense for C and was adopted as the starting point of the language. Most of us converted to C even before the major additions were added — structs, unions, and multidimensional arrays — and used the new features as they were added.\n\nAs C matured, there was interest in having it run on larger computers like the mainframes in the computing centers. A dialect of FORTRAN that would run the same on the six mainframe architectures that supported FORTRAN had been around for several years, and we started looking at how C would look with this added portability.\n\nAt the time, I was working on Yacc and decided to see whether we could base the front end of a C compiler on a Yacc grammar. The experiment was successful—we could compile the programs into syntax trees. To debug Yacc, I wrote a back end that would find common errors when several files were compiled together. This evolved into Lint—we could take a C program written for one machine and run Lint on it on another machine and see what the problems were. A number of syntax and semantic ideas were tested out on Lint before deciding whether to move them into C. I should mention that I deferred to Dennis on what C should be.\n\nAnd one day there was a fateful discussion between Dennis and me. He said, in effect, “It appears to me that it would be easier to move a C program to multiple computers than to take applications on one computer and rewrite them for another.” The result of that discussion is that I devoted several years to making pcc, the Portable C Compiler. Dennis and Ken worked over the Unix kernel code and others fixed portability problems in the commands.\n\nThis is a long answer, but the ending point was profound. pcc was ported to roughly 200 different architectures. And the Unix architecture dominated operating systems because it was easy (most of the time) to port C. In fact, hardware design was affected because designers would simulate real applications and optimize the hardware for the best performance.', 'aiModelVersion': '1'}",0.49965
Brandon Ross,Updated 3y,How do I learn to code without coding?,"Seeking advice, a student “with ideas” brings tea to his master who is meditating in the garden.

“Master, how do I learn to code without coding?”

The student pours the tea, but the master does not reply.

“Master, my question?”

The master says nothing.

“Master, is this a test?”

Silence is the master’s only reply.

“Ah, I understand, master.”

The student continues.

“The principle of wu wei.”

Still, the master sits quietly, meditating. The student proudly declares:

“Clearly, you mean that by doing without doing, everything gets done.”

A beat.

“Just as a scholar can learn to dance without dancing, so too can I learn coding without coding.”

A long, doubtful silence falls over the garden.

“Or perhaps you mean that a scholar can learn about dance. But learning about dance is not the same as learning to dance. … and coding is the same…”

The student trails off. Steam from the tea escapes.

“But coding is hard. Coding is doing, and I wish to learn coding without doing.”

The master’s face is stone. Dejected, the student continues.

“Perhaps it is not possible to code without coding. The characters do not appear from nothing.”

The student sips his tea, looking inward:

“Perhaps it is not coding that I wish to avoid. It is frustration. Failure that inevitably comes with coding. When my mind is not yet in harmony with the compiler’s true nature or the user’s desires.”

Without prompting, the student goes further:

“But frustration is natural. It is my realization of my ignorance. I only think I have knowledge of coding. Only doing coding will reveal whether my knowledge of coding is true. Frustration teaches me whether I have learned. Therefore, learning coding is doing coding. To truly learn to code, I must code. ‘Doing without doing' means to accept this truth without resistance.”

Finally, the master opens one eye:

“Forgive my silence. I have been learning to speak wisdom without speaking.”

And the student was enlightened.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/t9cfju41ios0we37', 'title': 'How do I learn to code without coding?', 'score': {'original': 0.9951, 'ai': 0.0049}, 'blocks': [{'text': ""Seeking advice, a student “with ideas” brings tea to his master who is meditating in the garden.\n\n“Master, how do I learn to code without coding?”\n\nThe student pours the tea, but the master does not reply.\n\n“Master, my question?”\n\nThe master says nothing.\n\n“Master, is this a test?”\n\nSilence is the master’s only reply.\n\n“Ah, I understand, master.”\n\nThe student continues.\n\n“The principle of wu wei.”\n\nStill, the master sits quietly, meditating. The student proudly declares:\n\n“Clearly, you mean that by doing without doing, everything gets done.”\n\nA beat.\n\n“Just as a scholar can learn to dance without dancing, so too can I learn coding without coding.”\n\nA long, doubtful silence falls over the garden.\n\n“Or perhaps you mean that a scholar can learn about dance. But learning about dance is not the same as learning to dance. … and coding is the same…”\n\nThe student trails off. Steam from the tea escapes.\n\n“But coding is hard. Coding is doing, and I wish to learn coding without doing.”\n\nThe master’s face is stone. Dejected, the student continues.\n\n“Perhaps it is not possible to code without coding. The characters do not appear from nothing.”\n\nThe student sips his tea, looking inward:\n\n“Perhaps it is not coding that I wish to avoid. It is frustration. Failure that inevitably comes with coding. When my mind is not yet in harmony with the compiler’s true nature or the user’s desires.”\n\nWithout prompting, the student goes further:\n\n“But frustration is natural. It is my realization of my ignorance. I only think I have knowledge of coding. Only doing coding will reveal whether my knowledge of coding is true. Frustration teaches me whether I have learned. Therefore, learning coding is doing coding. To truly learn to code, I must code. ‘Doing without doing' means to accept this truth without resistance.”\n\nFinally, the master opens one eye:\n\n“Forgive my silence. I have been learning to speak wisdom without speaking.”\n\nAnd the student was enlightened."", 'result': {'fake': 0.0049, 'real': 0.9951}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983814, 'subscription': 0, 'content': ""Seeking advice, a student “with ideas” brings tea to his master who is meditating in the garden.\n\n“Master, how do I learn to code without coding?”\n\nThe student pours the tea, but the master does not reply.\n\n“Master, my question?”\n\nThe master says nothing.\n\n“Master, is this a test?”\n\nSilence is the master’s only reply.\n\n“Ah, I understand, master.”\n\nThe student continues.\n\n“The principle of wu wei.”\n\nStill, the master sits quietly, meditating. The student proudly declares:\n\n“Clearly, you mean that by doing without doing, everything gets done.”\n\nA beat.\n\n“Just as a scholar can learn to dance without dancing, so too can I learn coding without coding.”\n\nA long, doubtful silence falls over the garden.\n\n“Or perhaps you mean that a scholar can learn about dance. But learning about dance is not the same as learning to dance. … and coding is the same…”\n\nThe student trails off. Steam from the tea escapes.\n\n“But coding is hard. Coding is doing, and I wish to learn coding without doing.”\n\nThe master’s face is stone. Dejected, the student continues.\n\n“Perhaps it is not possible to code without coding. The characters do not appear from nothing.”\n\nThe student sips his tea, looking inward:\n\n“Perhaps it is not coding that I wish to avoid. It is frustration. Failure that inevitably comes with coding. When my mind is not yet in harmony with the compiler’s true nature or the user’s desires.”\n\nWithout prompting, the student goes further:\n\n“But frustration is natural. It is my realization of my ignorance. I only think I have knowledge of coding. Only doing coding will reveal whether my knowledge of coding is true. Frustration teaches me whether I have learned. Therefore, learning coding is doing coding. To truly learn to code, I must code. ‘Doing without doing' means to accept this truth without resistance.”\n\nFinally, the master opens one eye:\n\n“Forgive my silence. I have been learning to speak wisdom without speaking.”\n\nAnd the student was enlightened."", 'aiModelVersion': '1'}",0.9951
Andy Baker,5y,What are some best technologies to learn for software developers besides programming?,"Become comfortable at the command line. Bash is sufficient as you can use it on the 3 major platforms (Linux etc, Mac OS and Windows thanks to the gift of Windows Subsystem for Linux). If you’re going to be predominantly working in a Microsoft world then learn Powershell as well.
Learn a modern VCS. Probably Git (because sadly Mercurial lost that battle)
Understand HTTP at a low-ish level. Request/Response and HTTP headers will touch nearly all aspects of development even if you’re not strictly a web developer.
Learn to understand the concepts of relational databases and maybe even a smattering of SQL. Even if you drink the No SQL kool-aid you will need to know why they’ve decided to sacrifice one of the cornerstones of classic database theory and what the trade-offs were.
Become vaguely proficient in Gimp or Photoshop if you ever need to process images. And I struggle to think how you’ll sidestep this one in most areas of software development.
Understand data transfer formats to some degree. JSON, XML, CSV and maybe YAML or similar will cross your path at some point. Be aware of when to select one over the others.
Learn to be lazy. Good programmers are lazy. Bad programmers reinvent things that already exist and forget the actual task at hand. Sometimes you just need to do something quick and dirty and if that means a crappy online service or hacking something together in Excel then so be it.
Which reminds me - a good spreadsheet will solve many problems better than a quick script. Or even better - a spreadsheet combines with a quick script will solve nearly all problems. It’s like duct tape and cable ties but for software.
Regular expressions. But know when to stop…","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/lpx1gcrun64qjs05', 'title': 'What are some best technologies to learn for software developers besides programming?', 'score': {'original': 0.9999, 'ai': 0.0001}, 'blocks': [{'text': 'Become comfortable at the command line. Bash is sufficient as you can use it on the 3 major platforms (Linux etc, Mac OS and Windows thanks to the gift of Windows Subsystem for Linux). If you’re going to be predominantly working in a Microsoft world then learn Powershell as well.\nLearn a modern VCS. Probably Git (because sadly Mercurial lost that battle)\nUnderstand HTTP at a low-ish level. Request/Response and HTTP headers will touch nearly all aspects of development even if you’re not strictly a web developer.\nLearn to understand the concepts of relational databases and maybe even a smattering of SQL. Even if you drink the No SQL kool-aid you will need to know why they’ve decided to sacrifice one of the cornerstones of classic database theory and what the trade-offs were.\nBecome vaguely proficient in Gimp or Photoshop if you ever need to process images. And I struggle to think how you’ll sidestep this one in most areas of software development.\nUnderstand data transfer formats to some degree. JSON, XML, CSV and maybe YAML or similar will cross your path at some point. Be aware of when to select one over the others.\nLearn to be lazy. Good programmers are lazy. Bad programmers reinvent things that already exist and forget the actual task at hand. Sometimes you just need to do something quick and dirty and if that means a crappy online service or hacking something together in Excel then so be it.\nWhich reminds me - a good spreadsheet will solve many problems better than a quick script. Or even better - a spreadsheet combines with a quick script will solve nearly all problems. It’s like duct tape and cable ties but for software.\nRegular expressions. But know when to stop…', 'result': {'fake': 0.0001, 'real': 0.9999}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983811, 'subscription': 0, 'content': 'Become comfortable at the command line. Bash is sufficient as you can use it on the 3 major platforms (Linux etc, Mac OS and Windows thanks to the gift of Windows Subsystem for Linux). If you’re going to be predominantly working in a Microsoft world then learn Powershell as well.\nLearn a modern VCS. Probably Git (because sadly Mercurial lost that battle)\nUnderstand HTTP at a low-ish level. Request/Response and HTTP headers will touch nearly all aspects of development even if you’re not strictly a web developer.\nLearn to understand the concepts of relational databases and maybe even a smattering of SQL. Even if you drink the No SQL kool-aid you will need to know why they’ve decided to sacrifice one of the cornerstones of classic database theory and what the trade-offs were.\nBecome vaguely proficient in Gimp or Photoshop if you ever need to process images. And I struggle to think how you’ll sidestep this one in most areas of software development.\nUnderstand data transfer formats to some degree. JSON, XML, CSV and maybe YAML or similar will cross your path at some point. Be aware of when to select one over the others.\nLearn to be lazy. Good programmers are lazy. Bad programmers reinvent things that already exist and forget the actual task at hand. Sometimes you just need to do something quick and dirty and if that means a crappy online service or hacking something together in Excel then so be it.\nWhich reminds me - a good spreadsheet will solve many problems better than a quick script. Or even better - a spreadsheet combines with a quick script will solve nearly all problems. It’s like duct tape and cable ties but for software.\nRegular expressions. But know when to stop…', 'aiModelVersion': '1'}",0.9999
Mohammed Isam,5y,What is the hardest program to code from scratch?,"I would say that a Windows-like operating system is extremely difficult to code from scratch.

(Source: Microsoft Windows - Wikipedia
).

The system is 32 years old, has gone from a 16 bit, MS DOS add-on, to a fully fledged 64 bit OS. It has anywhere between 40–50 million lines of code. The code base does everything from interfacing with hardware, manipulating file systems, managing network traffic, supervising memory access, among many other functions. It’s pretty difficult to write such code from scratch (ask ReactOS
 team, they have written 5+ million lines of code).

Let’s take another example. Mozilla Firefox is a pretty complex piece of software.

(Source: Download the fastest Firefox ever
).

This monster is about 51 million lines of code
, most of which are in C++, JavaScript and C. I guess it is pretty tough to write a cross-platform, multi-language, full-fledged, cutting-edge web browser after all.

A third example is GCC, the GNU/Linux universal compiler.

(Source: File:GNU Compiler Collection logo.svg
).

Using David Wheeler’s SLOCCount tool
 on the source code of the last version (v7.3.0), I found that the core part of GCC is about 5 million lines of code (mostly in C, C++ and Ada). Remember that GCC is huge piece of software that has front ends to compile 6 different languages
 (C, C++, Ada, Objective C, Fortran, Go), plus 8 upcoming languages. Writing a multipass, cross-language compiler can be pretty tough.

I don’t have enough space, but some other tough programs to code from scratch are game engines and 3D games, device drivers (especially if you don’t have the specs), among many others.

Thanks for A2A.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/2b8yqi6rotn3zxgp', 'title': 'What is the hardest program to code from scratch?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'I would say that a Windows-like operating system is extremely difficult to code from scratch.\n\n(Source: Microsoft Windows - Wikipedia\n).\n\nThe system is 32 years old, has gone from a 16 bit, MS DOS add-on, to a fully fledged 64 bit OS. It has anywhere between 40–50 million lines of code. The code base does everything from interfacing with hardware, manipulating file systems, managing network traffic, supervising memory access, among many other functions. It’s pretty difficult to write such code from scratch (ask ReactOS\n team, they have written 5+ million lines of code).\n\nLet’s take another example. Mozilla Firefox is a pretty complex piece of software.\n\n(Source: Download the fastest Firefox ever\n).\n\nThis monster is about 51 million lines of code\n, most of which are in C++, JavaScript and C. I guess it is pretty tough to write a cross-platform, multi-language, full-fledged, cutting-edge web browser after all.\n\nA third example is GCC, the GNU/Linux universal compiler.\n\n(Source: File:GNU Compiler Collection logo.svg\n).\n\nUsing David Wheeler’s SLOCCount tool\n on the source code of the last version (v7.3.0), I found that the core part of GCC is about 5 million lines of code (mostly in C, C++ and Ada). Remember that GCC is huge piece of software that has front ends to compile 6 different languages\n (C, C++, Ada, Objective C, Fortran, Go), plus 8 upcoming languages. Writing a multipass, cross-language compiler can be pretty tough.\n\nI don’t have enough space, but some other tough programs to code from scratch are game engines and 3D games, device drivers (especially if you don’t have the specs), among many others.\n\nThanks for A2A.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983808, 'subscription': 0, 'content': 'I would say that a Windows-like operating system is extremely difficult to code from scratch.\n\n(Source: Microsoft Windows - Wikipedia\n).\n\nThe system is 32 years old, has gone from a 16 bit, MS DOS add-on, to a fully fledged 64 bit OS. It has anywhere between 40–50 million lines of code. The code base does everything from interfacing with hardware, manipulating file systems, managing network traffic, supervising memory access, among many other functions. It’s pretty difficult to write such code from scratch (ask ReactOS\n team, they have written 5+ million lines of code).\n\nLet’s take another example. Mozilla Firefox is a pretty complex piece of software.\n\n(Source: Download the fastest Firefox ever\n).\n\nThis monster is about 51 million lines of code\n, most of which are in C++, JavaScript and C. I guess it is pretty tough to write a cross-platform, multi-language, full-fledged, cutting-edge web browser after all.\n\nA third example is GCC, the GNU/Linux universal compiler.\n\n(Source: File:GNU Compiler Collection logo.svg\n).\n\nUsing David Wheeler’s SLOCCount tool\n on the source code of the last version (v7.3.0), I found that the core part of GCC is about 5 million lines of code (mostly in C, C++ and Ada). Remember that GCC is huge piece of software that has front ends to compile 6 different languages\n (C, C++, Ada, Objective C, Fortran, Go), plus 8 upcoming languages. Writing a multipass, cross-language compiler can be pretty tough.\n\nI don’t have enough space, but some other tough programs to code from scratch are game engines and 3D games, device drivers (especially if you don’t have the specs), among many others.\n\nThanks for A2A.', 'aiModelVersion': '1'}",0.9998
Michael B.,4y,"Movies usually portray programmers as these insane coders who memorize everything. Do professional programmers actually know code (when making a bot, application, etc) or do research to put the pieces together?","Bit of both.

First of all what you see in the movies usually isn’t programming. It’s hacking (or cracking if you want to be technical). Hacking is when someone gets unauthorized access to a system. It’s nothing like depicted in Hollywood. It takes much longer, and most of the time it involves hacking the people, not the system.

But programming is also very different than what you’re imaging. For one thing there’s a lot less typing. Some people can just sit down and write code for 8 hours straight. Most people can’t. Most people need to think about the problem, ask questions, draw a diagram…

For another, computer science doesn’t require much memorization. If you use a language and set of libraries for a year, obviously you’re going to start remembering what each function does. But the IDE, the program that makes it easier to program remembers a lot of this stuff for you. And of course in real life programmers spend a lot of time on Google, Stack Overflow, or even just reading the documentation.

And then there’s the fact that you’re not always familiar with the pieces you’re using. A good chunk of the code of any program is going to be libraries. Preexisting code that does something. You might be familiar with the standard libraries used in your language, but if you want the program to do something specialized that can often involve having to learn a new library.

On the other side of the spectrum are design patterns. Set ways of solving a problem that can be used in any language. These are one of the few things that programmers will actually memorize.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/oqnwsfculixm0t5d', 'title': 'Movies usually portray programmers as these insane coders who memorize everything. Do professional programmers actually know code (when making a bot, application, etc) or do research to put the pieces together?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Bit of both.\n\nFirst of all what you see in the movies usually isn’t programming. It’s hacking (or cracking if you want to be technical). Hacking is when someone gets unauthorized access to a system. It’s nothing like depicted in Hollywood. It takes much longer, and most of the time it involves hacking the people, not the system.\n\nBut programming is also very different than what you’re imaging. For one thing there’s a lot less typing. Some people can just sit down and write code for 8 hours straight. Most people can’t. Most people need to think about the problem, ask questions, draw a diagram…\n\nFor another, computer science doesn’t require much memorization. If you use a language and set of libraries for a year, obviously you’re going to start remembering what each function does. But the IDE, the program that makes it easier to program remembers a lot of this stuff for you. And of course in real life programmers spend a lot of time on Google, Stack Overflow, or even just reading the documentation.\n\nAnd then there’s the fact that you’re not always familiar with the pieces you’re using. A good chunk of the code of any program is going to be libraries. Preexisting code that does something. You might be familiar with the standard libraries used in your language, but if you want the program to do something specialized that can often involve having to learn a new library.\n\nOn the other side of the spectrum are design patterns. Set ways of solving a problem that can be used in any language. These are one of the few things that programmers will actually memorize.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983805, 'subscription': 0, 'content': 'Bit of both.\n\nFirst of all what you see in the movies usually isn’t programming. It’s hacking (or cracking if you want to be technical). Hacking is when someone gets unauthorized access to a system. It’s nothing like depicted in Hollywood. It takes much longer, and most of the time it involves hacking the people, not the system.\n\nBut programming is also very different than what you’re imaging. For one thing there’s a lot less typing. Some people can just sit down and write code for 8 hours straight. Most people can’t. Most people need to think about the problem, ask questions, draw a diagram…\n\nFor another, computer science doesn’t require much memorization. If you use a language and set of libraries for a year, obviously you’re going to start remembering what each function does. But the IDE, the program that makes it easier to program remembers a lot of this stuff for you. And of course in real life programmers spend a lot of time on Google, Stack Overflow, or even just reading the documentation.\n\nAnd then there’s the fact that you’re not always familiar with the pieces you’re using. A good chunk of the code of any program is going to be libraries. Preexisting code that does something. You might be familiar with the standard libraries used in your language, but if you want the program to do something specialized that can often involve having to learn a new library.\n\nOn the other side of the spectrum are design patterns. Set ways of solving a problem that can be used in any language. These are one of the few things that programmers will actually memorize.', 'aiModelVersion': '1'}",0.9998
Alon Amit,Updated 3y,What are some programming problems that look hard at a first glance but are actually easy?,"Here’s a black and white image.

It is represented, as you’d expect, as an array of bits: 0 is white, 1 is black. Your programming challenge is to determine the number of connected components in such an image. In this example, there are three of them:

You’re not required to color them in! I’m just clarifying what I mean by “connected component”.

You can make the following assumptions. The black pixels of a component share an edge, not just a corner. Assume that this:

doesn’t happen. Connected components are strongly connected (their pixels share an edge), and different components don’t touch even in pixel corners. With a hi-res image like the example above those are very natural assumptions (Note: in an earlier version of this answer I was too lax here. Corrected now.)

Another simplifying assumption you can make is that there are no holes. The “blobs”, the connected components, are whole and filled in. Such blobs are called simply connected.

Finally, you may assume that the exterior border of the array is all white. If not, you can just zero-pad it.

So:

Input: array of bits, representing an image with simply connected components.
Output: an integer representing the number of components.
GO!

This is actually an important and useful algorithmic problem. Versions of it are needed, for example, in science and engineering to count objects in industrial, biological or medical images.

So, how would you go about this?

Almost anyone who attempts this does the most natural thing: Flood Fill
. Scan the image, find a black pixel, start crawling its neighbors and their neighbors and so on, marking the pixels you’ve found along the way. When you get stuck, backtrack to a previous black pixel which still has unprocessed neighbors, and continue until you’ve completed a blob. Add 
1
1
 to the count of blobs. Start over.

Here’s a quick animation (from the loc. cit. Wiki page) of a flood fill algorithm filling a white blob on a black background.

This is not a terribly difficult algorithm, but it’s not straightforward either. The Wikipedia article shows various versions, including a fairly optimized one with some 100 lines of pseudocode. See also Connected-component labeling
 for more on this approach.

(Naturally, the code golfers have addressed the problem
, but as you can see even they couldn’t get it down to their usual 9-byte Jelly programs. Except for the guy who cheated with Matlab’s imfill, the solutions are hundreds of bytes of dense code.)

But remember, I didn’t ask you to flood-fill anything, nor to label the blobs. We just want to count. Is there an easier way?

Yes, there is, a fantastically simple and easy way. It lets you count the number of connected components in the simply connected case, and in fact it works more generally: it counts the number of components minus the number of holes. If we assume no holes, as we did, then you simply get the number of blobs.

Here’s the complete algorithm.

Set a counter to 
0
0
. Scan the entire image, once, looking at 
2
×
2
2×2
 pixel windows anchored at each pixel. Add 1 to the counter every time you see this (a “dot”):

Subtract 1 every time you see that (a “T”):

Done. The counter has the number of connected components.

Yes, really. No queues, no stacks, no recursion, no backtracking, no forest fire fills, no labeling, nothing. Just a dead-simple, linear, one-time pass through the array, and counting two simple combinations of pixels.

If this is the input:

You’ll catch one 
+
1
+1
 and no subtractions. Output: 
1
1
. Check.

If this is the input:

You’ll count two 
+
1
+1
's and one 
−
1
−1
. Output: 
1
1
. Check.

Here’s a more complicated example:

There are 
4
4
 
+
1
+1
's here and 
3
3
 
−
1
−1
's. Output: 
1
1
. Check.

The local nature of the algorithm makes it quite clear that if it works for single blobs, it works for any number of blobs. Indeed, it is additive under superpositions. Overlay two disjoint blobs and the algorithm will simply accumulate the results from each independent one.

This algorithm is an instance of something truly deep and profound: the local-global behavior of the Euler characteristic
. In simple words, if you have local geometric data and you’re interested in global features, take an alternating sum. In our case, “dots minus T’s” is the same as “components minus holes”. The very same idea lies behind deep results like the Lefschetz fixed point theorem
 and the Gauss–Bonnet theorem
.

We’ll have to save a complete proof to another answer, but I would submit that this is an amazing instance of a seemingly challenging algorithmic problem which turns out to have a ridiculously simple solution.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/4qi8fydcz5uaxg9n', 'title': 'What are some programming problems that look hard at a first glance but are actually easy?', 'score': {'original': 0.9801, 'ai': 0.0199}, 'blocks': [{'text': 'Here’s a black and white image.\n\nIt is represented, as you’d expect, as an array of bits: 0 is white, 1 is black. Your programming challenge is to determine the number of connected components in such an image. In this example, there are three of them:\n\nYou’re not required to color them in! I’m just clarifying what I mean by “connected component”.\n\nYou can make the following assumptions. The black pixels of a component share an edge, not just a corner. Assume that this:\n\ndoesn’t happen. Connected components are strongly connected (their pixels share an edge), and different components don’t touch even in pixel corners. With a hi-res image like the example above those are very natural assumptions (Note: in an earlier version of this answer I was too lax here. Corrected now.)\n\nAnother simplifying assumption you can make is that there are no holes. The “blobs”, the connected components, are whole and filled in. Such blobs are called simply connected.\n\nFinally, you may assume that the exterior border of the array is all white. If not, you can just zero-pad it.\n\nSo:\n\nInput: array of bits, representing an image with simply connected components.\nOutput: an integer representing the number of components.\nGO!\n\nThis is actually an important and useful algorithmic problem. Versions of it are needed, for example, in science and engineering to count objects in industrial, biological or medical images.\n\nSo, how would you go about this?\n\nAlmost anyone who attempts this does the most natural thing: Flood Fill\n. Scan the image, find a black pixel, start crawling its neighbors and their neighbors and so on, marking the pixels you’ve found along the way. When you get stuck, backtrack to a previous black pixel which still has unprocessed neighbors, and continue until you’ve completed a blob. Add \n1\n1\n to the count of blobs. Start over.\n\nHere’s a quick animation (from the loc. cit. Wiki page) of a flood fill algorithm filling a white blob on a black background.\n\nThis is not a terribly difficult algorithm, but it’s not straightforward either. The Wikipedia article shows various versions, including a fairly optimized one with some 100 lines of pseudocode. See also Connected-component labeling\n for more on this approach.\n\n(Naturally, the code golfers have addressed the problem\n, but as you can see even they couldn’t get it down to their usual 9-byte Jelly programs. Except for the guy who cheated with Matlab’s imfill, the solutions are hundreds of bytes of dense code.)\n\nBut remember, I didn’t ask you to flood-fill anything, nor to label the blobs. We just want to count. Is there an easier way?\n\nYes, there is, a fantastically simple and easy way. It lets you count the number of connected components in the simply connected case, and in fact it works more generally: it counts the number of components minus the number of holes. If we assume no holes, as we did, then you simply get the number of blobs.\n\nHere’s the complete algorithm.\n\nSet a counter to \n0\n0\n. Scan the entire image, once, looking at \n2\n×\n2\n2×2\n pixel windows anchored at each pixel. Add 1 to the counter every time you see this (a “dot”):\n\nSubtract 1 every time you see', 'result': {'fake': 0.009, 'real': 0.991}, 'status': 'success'}, {'text': ""that (a “T”):\n\nDone. The counter has the number of connected components.\n\nYes, really. No queues, no stacks, no recursion, no backtracking, no forest fire fills, no labeling, nothing. Just a dead-simple, linear, one-time pass through the array, and counting two simple combinations of pixels.\n\nIf this is the input:\n\nYou’ll catch one \n+\n1\n+1\n and no subtractions. Output: \n1\n1\n. Check.\n\nIf this is the input:\n\nYou’ll count two \n+\n1\n+1\n's and one \n−\n1\n−1\n. Output: \n1\n1\n. Check.\n\nHere’s a more complicated example:\n\nThere are \n4\n4\n \n+\n1\n+1\n's here and \n3\n3\n \n−\n1\n−1\n's. Output: \n1\n1\n. Check.\n\nThe local nature of the algorithm makes it quite clear that if it works for single blobs, it works for any number of blobs. Indeed, it is additive under superpositions. Overlay two disjoint blobs and the algorithm will simply accumulate the results from each independent one.\n\nThis algorithm is an instance of something truly deep and profound: the local-global behavior of the Euler characteristic\n. In simple words, if you have local geometric data and you’re interested in global features, take an alternating sum. In our case, “dots minus T’s” is the same as “components minus holes”. The very same idea lies behind deep results like the Lefschetz fixed point theorem\n and the Gauss–Bonnet theorem\n.\n\nWe’ll have to save a complete proof to another answer, but I would submit that this is an amazing instance of a seemingly challenging algorithmic problem which turns out to have a ridiculously simple solution."", 'result': {'fake': 0.1562, 'real': 0.8438}, 'status': 'success'}], 'credits_used': 8, 'credits': 1983797, 'subscription': 0, 'content': ""Here’s a black and white image.\n\nIt is represented, as you’d expect, as an array of bits: 0 is white, 1 is black. Your programming challenge is to determine the number of connected components in such an image. In this example, there are three of them:\n\nYou’re not required to color them in! I’m just clarifying what I mean by “connected component”.\n\nYou can make the following assumptions. The black pixels of a component share an edge, not just a corner. Assume that this:\n\ndoesn’t happen. Connected components are strongly connected (their pixels share an edge), and different components don’t touch even in pixel corners. With a hi-res image like the example above those are very natural assumptions (Note: in an earlier version of this answer I was too lax here. Corrected now.)\n\nAnother simplifying assumption you can make is that there are no holes. The “blobs”, the connected components, are whole and filled in. Such blobs are called simply connected.\n\nFinally, you may assume that the exterior border of the array is all white. If not, you can just zero-pad it.\n\nSo:\n\nInput: array of bits, representing an image with simply connected components.\nOutput: an integer representing the number of components.\nGO!\n\nThis is actually an important and useful algorithmic problem. Versions of it are needed, for example, in science and engineering to count objects in industrial, biological or medical images.\n\nSo, how would you go about this?\n\nAlmost anyone who attempts this does the most natural thing: Flood Fill\n. Scan the image, find a black pixel, start crawling its neighbors and their neighbors and so on, marking the pixels you’ve found along the way. When you get stuck, backtrack to a previous black pixel which still has unprocessed neighbors, and continue until you’ve completed a blob. Add \n1\n1\n to the count of blobs. Start over.\n\nHere’s a quick animation (from the loc. cit. Wiki page) of a flood fill algorithm filling a white blob on a black background.\n\nThis is not a terribly difficult algorithm, but it’s not straightforward either. The Wikipedia article shows various versions, including a fairly optimized one with some 100 lines of pseudocode. See also Connected-component labeling\n for more on this approach.\n\n(Naturally, the code golfers have addressed the problem\n, but as you can see even they couldn’t get it down to their usual 9-byte Jelly programs. Except for the guy who cheated with Matlab’s imfill, the solutions are hundreds of bytes of dense code.)\n\nBut remember, I didn’t ask you to flood-fill anything, nor to label the blobs. We just want to count. Is there an easier way?\n\nYes, there is, a fantastically simple and easy way. It lets you count the number of connected components in the simply connected case, and in fact it works more generally: it counts the number of components minus the number of holes. If we assume no holes, as we did, then you simply get the number of blobs.\n\nHere’s the complete algorithm.\n\nSet a counter to \n0\n0\n. Scan the entire image, once, looking at \n2\n×\n2\n2×2\n pixel windows anchored at each pixel. Add 1 to the counter every time you see this (a “dot”):\n\nSubtract 1 every time you see that (a “T”):\n\nDone. The counter has the number of connected components.\n\nYes, really. No queues, no stacks, no recursion, no backtracking, no forest fire fills, no labeling, nothing. Just a dead-simple, linear, one-time pass through the array, and counting two simple combinations of pixels.\n\nIf this is the input:\n\nYou’ll catch one \n+\n1\n+1\n and no subtractions. Output: \n1\n1\n. Check.\n\nIf this is the input:\n\nYou’ll count two \n+\n1\n+1\n's and one \n−\n1\n−1\n. Output: \n1\n1\n. Check.\n\nHere’s a more complicated example:\n\nThere are \n4\n4\n \n+\n1\n+1\n's here and \n3\n3\n \n−\n1\n−1\n's. Output: \n1\n1\n. Check.\n\nThe local nature of the algorithm makes it quite clear that if it works for single blobs, it works for any number of blobs. Indeed, it is additive under superpositions. Overlay two disjoint blobs and the algorithm will simply accumulate the results from each independent one.\n\nThis algorithm is an instance of something truly deep and profound: the local-global behavior of the Euler characteristic\n. In simple words, if you have local geometric data and you’re interested in global features, take an alternating sum. In our case, “dots minus T’s” is the same as “components minus holes”. The very same idea lies behind deep results like the Lefschetz fixed point theorem\n and the Gauss–Bonnet theorem\n.\n\nWe’ll have to save a complete proof to another answer, but I would submit that this is an amazing instance of a seemingly challenging algorithmic problem which turns out to have a ridiculously simple solution."", 'aiModelVersion': '1'}",0.9801
Håkon Hapnes Strand,5y,What's your favourite niche non-joke programming language?,"Bring on the ridicule. I’m going to go with…

LabVIEW.

Yeah, you heard me.

It’s that graphical programming language that’s never mentioned without someone bringing up this screenshot:

It’s pretty much universally accepted as the prime counterexample of why programming languages are text-based.

But that example is obviously a severe case of bad programming style. You can find spaghetti code written in any language if you want to.

A real LabVIEW architecture might look something like this:

The above is actually a non-trivial piece of code. It consists of two processes running in parallel, exploiting the inherent parallelism in LabVIEW. The bottom loop is a finite state machine that triggers the processing of a queue of events every 100 milliseconds. The upper loop reacts to user events and allows a user to interrupt the state machine at any time. Yet, this implementation is really simple.

It’s in these sorts of real-time scenarios that LabVIEW shines. I challenge you to find any programming language where you can implement a real-time simulation with a built-in GUI any faster than with LabVIEW.

It’s also great for process control scenarios. Here, someone has made a process control simulation with a PID controller and a chart. If you adjust the settings, all the visuals respond immediately.

Even the code is visual. When debugging, you can highlight the code execution and see how the data flows through your code in real-time.

Of course, I’m not saying that this is a general-purpose programming language, but it’s really nice for some use cases. It’s also easy to learn, which I consider a great benefit. The main drawback of LabVIEW is that a professional license is expensive as fuck. In one of my former companies, our team was spending millions on licensing. But as long as the company is paying, who cares, right.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/6t7j4iry28ge0ulm', 'title': ""What's your favourite niche non-joke programming language?"", 'score': {'original': 0.998, 'ai': 0.002}, 'blocks': [{'text': 'Bring on the ridicule. I’m going to go with…\n\nLabVIEW.\n\nYeah, you heard me.\n\nIt’s that graphical programming language that’s never mentioned without someone bringing up this screenshot:\n\nIt’s pretty much universally accepted as the prime counterexample of why programming languages are text-based.\n\nBut that example is obviously a severe case of bad programming style. You can find spaghetti code written in any language if you want to.\n\nA real LabVIEW architecture might look something like this:\n\nThe above is actually a non-trivial piece of code. It consists of two processes running in parallel, exploiting the inherent parallelism in LabVIEW. The bottom loop is a finite state machine that triggers the processing of a queue of events every 100 milliseconds. The upper loop reacts to user events and allows a user to interrupt the state machine at any time. Yet, this implementation is really simple.\n\nIt’s in these sorts of real-time scenarios that LabVIEW shines. I challenge you to find any programming language where you can implement a real-time simulation with a built-in GUI any faster than with LabVIEW.\n\nIt’s also great for process control scenarios. Here, someone has made a process control simulation with a PID controller and a chart. If you adjust the settings, all the visuals respond immediately.\n\nEven the code is visual. When debugging, you can highlight the code execution and see how the data flows through your code in real-time.\n\nOf course, I’m not saying that this is a general-purpose programming language, but it’s really nice for some use cases. It’s also easy to learn, which I consider a great benefit. The main drawback of LabVIEW is that a professional license is expensive as fuck. In one of my former companies, our team was spending millions on licensing. But as long as the company is paying, who cares, right.', 'result': {'fake': 0.002, 'real': 0.998}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983793, 'subscription': 0, 'content': 'Bring on the ridicule. I’m going to go with…\n\nLabVIEW.\n\nYeah, you heard me.\n\nIt’s that graphical programming language that’s never mentioned without someone bringing up this screenshot:\n\nIt’s pretty much universally accepted as the prime counterexample of why programming languages are text-based.\n\nBut that example is obviously a severe case of bad programming style. You can find spaghetti code written in any language if you want to.\n\nA real LabVIEW architecture might look something like this:\n\nThe above is actually a non-trivial piece of code. It consists of two processes running in parallel, exploiting the inherent parallelism in LabVIEW. The bottom loop is a finite state machine that triggers the processing of a queue of events every 100 milliseconds. The upper loop reacts to user events and allows a user to interrupt the state machine at any time. Yet, this implementation is really simple.\n\nIt’s in these sorts of real-time scenarios that LabVIEW shines. I challenge you to find any programming language where you can implement a real-time simulation with a built-in GUI any faster than with LabVIEW.\n\nIt’s also great for process control scenarios. Here, someone has made a process control simulation with a PID controller and a chart. If you adjust the settings, all the visuals respond immediately.\n\nEven the code is visual. When debugging, you can highlight the code execution and see how the data flows through your code in real-time.\n\nOf course, I’m not saying that this is a general-purpose programming language, but it’s really nice for some use cases. It’s also easy to learn, which I consider a great benefit. The main drawback of LabVIEW is that a professional license is expensive as fuck. In one of my former companies, our team was spending millions on licensing. But as long as the company is paying, who cares, right.', 'aiModelVersion': '1'}",0.998
Chris Nash,Updated 2y,What is something that programmers should know but isn’t taught extensively enough in school?,"First

I find it incredible that many graduates don’t have the first idea of how to actually write a program. For us in college, we programmed. A lot.

I may have programmed more than my peers, simply because I loved it so much. Some of my programs took weeks. Some a few hours. But I loved doing it, so I did it a lot.

Many years later I worked with a woman who had a Masters degree in Computer Science. I only have a Bachelors. She had absolutely no idea how to program whatsoever. She couldn’t understand a simple if statement. I was amazed and couldn’t understand how she earned that degree.

She worked at the help desk. She hated it. About 20 of us worked in software engineering. All of us had bachelors degrees. We made more than 2x what she did with a Masters degree.

So first and foremost, make sure you, the student, know how to program from the ground up. Make sure you can fire up an IDE and write a program from scratch. Do it often. Do it for fun. Do it for serious things.

Second

Source control. When I graduated from college, source control wasn’t really a thing. It was used some places on some things, but it certainly wasn’t popular or the norm.

Now it is, and most college graduates have never been introduced to it. That’s a shame. It should be one of the first things they learn to use. Like an IDE and StackOverflow, it’s an indispensable tool for today’s software engineer.

Given that today’s most popular SCM tool, Git, is free, not teaching it is inexcusable.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/q79ia508r2omvkgh', 'title': 'What is something that programmers should know but isn’t taught extensively enough in school?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'First\n\nI find it incredible that many graduates don’t have the first idea of how to actually write a program. For us in college, we programmed. A lot.\n\nI may have programmed more than my peers, simply because I loved it so much. Some of my programs took weeks. Some a few hours. But I loved doing it, so I did it a lot.\n\nMany years later I worked with a woman who had a Masters degree in Computer Science. I only have a Bachelors. She had absolutely no idea how to program whatsoever. She couldn’t understand a simple if statement. I was amazed and couldn’t understand how she earned that degree.\n\nShe worked at the help desk. She hated it. About 20 of us worked in software engineering. All of us had bachelors degrees. We made more than 2x what she did with a Masters degree.\n\nSo first and foremost, make sure you, the student, know how to program from the ground up. Make sure you can fire up an IDE and write a program from scratch. Do it often. Do it for fun. Do it for serious things.\n\nSecond\n\nSource control. When I graduated from college, source control wasn’t really a thing. It was used some places on some things, but it certainly wasn’t popular or the norm.\n\nNow it is, and most college graduates have never been introduced to it. That’s a shame. It should be one of the first things they learn to use. Like an IDE and StackOverflow, it’s an indispensable tool for today’s software engineer.\n\nGiven that today’s most popular SCM tool, Git, is free, not teaching it is inexcusable.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983790, 'subscription': 0, 'content': 'First\n\nI find it incredible that many graduates don’t have the first idea of how to actually write a program. For us in college, we programmed. A lot.\n\nI may have programmed more than my peers, simply because I loved it so much. Some of my programs took weeks. Some a few hours. But I loved doing it, so I did it a lot.\n\nMany years later I worked with a woman who had a Masters degree in Computer Science. I only have a Bachelors. She had absolutely no idea how to program whatsoever. She couldn’t understand a simple if statement. I was amazed and couldn’t understand how she earned that degree.\n\nShe worked at the help desk. She hated it. About 20 of us worked in software engineering. All of us had bachelors degrees. We made more than 2x what she did with a Masters degree.\n\nSo first and foremost, make sure you, the student, know how to program from the ground up. Make sure you can fire up an IDE and write a program from scratch. Do it often. Do it for fun. Do it for serious things.\n\nSecond\n\nSource control. When I graduated from college, source control wasn’t really a thing. It was used some places on some things, but it certainly wasn’t popular or the norm.\n\nNow it is, and most college graduates have never been introduced to it. That’s a shame. It should be one of the first things they learn to use. Like an IDE and StackOverflow, it’s an indispensable tool for today’s software engineer.\n\nGiven that today’s most popular SCM tool, Git, is free, not teaching it is inexcusable.', 'aiModelVersion': '1'}",0.9998
Sharifeee,3y,What are the most fun programming projects for a beginner?,"When I started out, the most fun programming project was the text adventure. Most beginners don’t go anywhere near the GUI and their programs consist mainly of text-based console applications. As such, this project fits perfectly for anyone who meets that precedent. A text adventure is a story-based puzzle game where the user can interact through typing commands in the console to make decisions.

It’s like the Netflix show Bandersnatch in which the audience can select options on the screen to play out different scenarios. There are usually huge decision trees for these types of games with multiple different endings.

This is a great project as it intuitively teaches you about state machines. In simple terms, the program switches to a different state/mode depending on a series of inputs made by the user. This is a useful transferrable skill that is used in many programming projects.

I’ve worked on many text-adventures in the past, the first one was bad… like really bad. It was a singular file of hundreds of nesting if/elseif statements and random incohesive functions scattered everywhere. However, the last one I made (about 3 years ago) was pretty fun and I hope it can motivate you to build one yourself. Here’s a couple screenshots of what it looked like.

Firstly, you’re greeted with the above message, in this version of the game, you can save your current progress and return back to it, this is done by serialising all the important data using the python pickle library. Likewise, the serialised data is read back into the program if the user types ‘load’. Otherwise the user is sent to the initial setup.

I laughed looking back at this since I didn’t think it through that well, but it was a fun memorable project nonetheless. I’d like to show the entire game but this answer would be too long for that. Essentially, the user starts in a house filled with monsters and they must find the exit by solving a series of puzzles and collecting certain items. The user has an inventory and a shop to buy weapons and armour in order to survive, if you take too long you’ll eventually die from the numbers of monsters that have spawned over time.

There are endless things you can do with this idea, it is entirely up to your imagination. I highly recommend that you build one, as it’s great fun!","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/01oc9x7m4jsqd582', 'title': 'What are the most fun programming projects for a beginner?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'When I started out, the most fun programming project was the text adventure. Most beginners don’t go anywhere near the GUI and their programs consist mainly of text-based console applications. As such, this project fits perfectly for anyone who meets that precedent. A text adventure is a story-based puzzle game where the user can interact through typing commands in the console to make decisions.\n\nIt’s like the Netflix show Bandersnatch in which the audience can select options on the screen to play out different scenarios. There are usually huge decision trees for these types of games with multiple different endings.\n\nThis is a great project as it intuitively teaches you about state machines. In simple terms, the program switches to a different state/mode depending on a series of inputs made by the user. This is a useful transferrable skill that is used in many programming projects.\n\nI’ve worked on many text-adventures in the past, the first one was bad… like really bad. It was a singular file of hundreds of nesting if/elseif statements and random incohesive functions scattered everywhere. However, the last one I made (about 3 years ago) was pretty fun and I hope it can motivate you to build one yourself. Here’s a couple screenshots of what it looked like.\n\nFirstly, you’re greeted with the above message, in this version of the game, you can save your current progress and return back to it, this is done by serialising all the important data using the python pickle library. Likewise, the serialised data is read back into the program if the user types ‘load’. Otherwise the user is sent to the initial setup.\n\nI laughed looking back at this since I didn’t think it through that well, but it was a fun memorable project nonetheless. I’d like to show the entire game but this answer would be too long for that. Essentially, the user starts in a house filled with monsters and they must find the exit by solving a series of puzzles and collecting certain items. The user has an inventory and a shop to buy weapons and armour in order to survive, if you take too long you’ll eventually die from the numbers of monsters that have spawned over time.\n\nThere are endless things you can do with this idea, it is entirely up to your imagination. I highly recommend that you build one, as it’s great fun!', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983785, 'subscription': 0, 'content': 'When I started out, the most fun programming project was the text adventure. Most beginners don’t go anywhere near the GUI and their programs consist mainly of text-based console applications. As such, this project fits perfectly for anyone who meets that precedent. A text adventure is a story-based puzzle game where the user can interact through typing commands in the console to make decisions.\n\nIt’s like the Netflix show Bandersnatch in which the audience can select options on the screen to play out different scenarios. There are usually huge decision trees for these types of games with multiple different endings.\n\nThis is a great project as it intuitively teaches you about state machines. In simple terms, the program switches to a different state/mode depending on a series of inputs made by the user. This is a useful transferrable skill that is used in many programming projects.\n\nI’ve worked on many text-adventures in the past, the first one was bad… like really bad. It was a singular file of hundreds of nesting if/elseif statements and random incohesive functions scattered everywhere. However, the last one I made (about 3 years ago) was pretty fun and I hope it can motivate you to build one yourself. Here’s a couple screenshots of what it looked like.\n\nFirstly, you’re greeted with the above message, in this version of the game, you can save your current progress and return back to it, this is done by serialising all the important data using the python pickle library. Likewise, the serialised data is read back into the program if the user types ‘load’. Otherwise the user is sent to the initial setup.\n\nI laughed looking back at this since I didn’t think it through that well, but it was a fun memorable project nonetheless. I’d like to show the entire game but this answer would be too long for that. Essentially, the user starts in a house filled with monsters and they must find the exit by solving a series of puzzles and collecting certain items. The user has an inventory and a shop to buy weapons and armour in order to survive, if you take too long you’ll eventually die from the numbers of monsters that have spawned over time.\n\nThere are endless things you can do with this idea, it is entirely up to your imagination. I highly recommend that you build one, as it’s great fun!', 'aiModelVersion': '1'}",0.9996
Kanthaswamy Balasubramaniam,3y,What is the best way to learn the concept of computer coding?,"I started learning coding two months ago at 63. Until then I had no.idea of coding. I could use application but no idea how these applications were created.

Initially I got a book on C but after two hours understood very little

So I.joined a forum online for C /C++ programming. They were creating games so way ahead but a young guy named Tuhin Sengupta aged 17, advised me that it was like learning a language. First write in your language then try translating it in the other language

So I tried

Adding numbers

I tried in.english

Pick how many.numbers you want

Lets say you want to add six numbers

Then choose the numbers

Now add the numbers based on the adding method you know

Now you need to use Syntax for the same

***************

Assign A to accept no.of numbers

Then create a loop from 1 to that number A(6 in this case)

Enter the numbers from B to G

Use a known function or simply assign H = B+C+D+E+F+G

Print H

The Syntax can be googled easily.

Once you know how you would solve the problem if you were doing things on paper , you can start coding

And Youtubers will always help. There are excellent demos

Let's say you want to know which number is greatest between any three numbers

So you write them down

Compare the first with the second, the second with the third and the first with the third and finally decide which is the greatest

Same in Syntax

Assign a value to each number A,B,C

Check which is higher between AB, AC and BC

If A is higher than B, then AC and if A is higher than C then A is the largest number or else C is the largest number

If B is higher than A then BC and If B is higher than C then B is the largest number or else C is the largest number

(By the way this is very simple stuff. One of my gurus a 19 year old girl chided me and said uncle if I give you 50 numbers will you spend your life writing the code??? She advised me to use the For loop first and now says to learn something called Arrays)

This way you can code in any language as long as you know the basic process which may be from opening a file to adding four numbers to creating a function for converting centigrade to farenheit.

I find this way to be the best. With a notebook and pen. Write the logical way and then try to write in syntax

Then when I run it always errors will pop up and you rectify them (forgetting colons or going into a never ending loop) finally the program works.

Its a real joy to see on screen even if the code is a simple displaying your name in a

“Hi my name is Kanthaswamy Balasubrmaniam”

Of course that road is still.miles off. The ultimate aim is to program a car using arduino to avoid obstacles and climb a ramp

Its like Class VI that i am at compared to BE Year I","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/tjedfw0klogb4mar', 'title': 'What is the best way to learn the concept of computer coding?', 'score': {'original': 0.63725, 'ai': 0.36275}, 'blocks': [{'text': ""I started learning coding two months ago at 63. Until then I had no.idea of coding. I could use application but no idea how these applications were created.\n\nInitially I got a book on C but after two hours understood very little\n\nSo I.joined a forum online for C /C++ programming. They were creating games so way ahead but a young guy named Tuhin Sengupta aged 17, advised me that it was like learning a language. First write in your language then try translating it in the other language\n\nSo I tried\n\nAdding numbers\n\nI tried in.english\n\nPick how many.numbers you want\n\nLets say you want to add six numbers\n\nThen choose the numbers\n\nNow add the numbers based on the adding method you know\n\nNow you need to use Syntax for the same\n\n***************\n\nAssign A to accept no.of numbers\n\nThen create a loop from 1 to that number A(6 in this case)\n\nEnter the numbers from B to G\n\nUse a known function or simply assign H = B+C+D+E+F+G\n\nPrint H\n\nThe Syntax can be googled easily.\n\nOnce you know how you would solve the problem if you were doing things on paper , you can start coding\n\nAnd Youtubers will always help. There are excellent demos\n\nLet's say you want to know which number is greatest between any three numbers\n\nSo you write them down\n\nCompare the first with the second, the second with the third and the first with the third and finally decide which is the greatest\n\nSame in Syntax\n\nAssign a value to each number A,B,C\n\nCheck which is higher between AB, AC and BC\n\nIf A is higher than B, then AC and if A is higher than C then A is the largest number or else C is the largest number\n\nIf B is higher than A then BC and If B is higher than C then B is the largest number or else C is the largest number\n\n(By the way this is very simple stuff. One of my gurus a 19 year old girl chided me and said uncle if I give you 50 numbers will you spend your life writing the code??? She advised me to use the For loop first and now says to learn something called Arrays)\n\nThis way you can code in any language as long as you know the basic process which may be from opening a file to adding four numbers to creating a function for converting centigrade to farenheit.\n\nI find this way to be the best. With a notebook and pen. Write the logical way and then try to write in syntax\n\nThen when I run it always errors will pop up and you rectify them (forgetting colons or going into a never ending loop) finally the program works.\n\nIts a real joy to see on screen even if the code is a simple displaying your name in a\n\n“Hi my name is Kanthaswamy Balasubrmaniam”\n\nOf course that road is still.miles off. The ultimate aim is to program a car using arduino to avoid obstacles and climb a ramp\n\nIts like Class VI that i am at compared to BE Year I"", 'result': {'fake': 0.0139, 'real': 0.9861}, 'status': 'success'}], 'credits_used': 6, 'credits': 1983779, 'subscription': 0, 'content': ""I started learning coding two months ago at 63. Until then I had no.idea of coding. I could use application but no idea how these applications were created.\n\nInitially I got a book on C but after two hours understood very little\n\nSo I.joined a forum online for C /C++ programming. They were creating games so way ahead but a young guy named Tuhin Sengupta aged 17, advised me that it was like learning a language. First write in your language then try translating it in the other language\n\nSo I tried\n\nAdding numbers\n\nI tried in.english\n\nPick how many.numbers you want\n\nLets say you want to add six numbers\n\nThen choose the numbers\n\nNow add the numbers based on the adding method you know\n\nNow you need to use Syntax for the same\n\n***************\n\nAssign A to accept no.of numbers\n\nThen create a loop from 1 to that number A(6 in this case)\n\nEnter the numbers from B to G\n\nUse a known function or simply assign H = B+C+D+E+F+G\n\nPrint H\n\nThe Syntax can be googled easily.\n\nOnce you know how you would solve the problem if you were doing things on paper , you can start coding\n\nAnd Youtubers will always help. There are excellent demos\n\nLet's say you want to know which number is greatest between any three numbers\n\nSo you write them down\n\nCompare the first with the second, the second with the third and the first with the third and finally decide which is the greatest\n\nSame in Syntax\n\nAssign a value to each number A,B,C\n\nCheck which is higher between AB, AC and BC\n\nIf A is higher than B, then AC and if A is higher than C then A is the largest number or else C is the largest number\n\nIf B is higher than A then BC and If B is higher than C then B is the largest number or else C is the largest number\n\n(By the way this is very simple stuff. One of my gurus a 19 year old girl chided me and said uncle if I give you 50 numbers will you spend your life writing the code??? She advised me to use the For loop first and now says to learn something called Arrays)\n\nThis way you can code in any language as long as you know the basic process which may be from opening a file to adding four numbers to creating a function for converting centigrade to farenheit.\n\nI find this way to be the best. With a notebook and pen. Write the logical way and then try to write in syntax\n\nThen when I run it always errors will pop up and you rectify them (forgetting colons or going into a never ending loop) finally the program works.\n\nIts a real joy to see on screen even if the code is a simple displaying your name in a\n\n“Hi my name is Kanthaswamy Balasubrmaniam”\n\nOf course that road is still.miles off. The ultimate aim is to program a car using arduino to avoid obstacles and climb a ramp\n\nIts like Class VI that i am at compared to BE Year I"", 'aiModelVersion': '1'}",0.63725
Chris Nash,1y,How do I know if someone does not write their own code?,"They can’t explain it.

At one gig, we had weekly “code presentations” where a developer would get up and explain a recent change they made to the code, whether it be a new feature, a refactor or a bug fix. It was meant to be a short presentation, no longer than 30 minutes, and not overly code heavy. Code would be presented, but only for parts that were interesting or important. Questions would be taken from the other developers throughout.

The rotation came around to “Edward” and he showed part of a recent change, a really important if statement. He couldn’t explain it. He couldn’t even explain in the simplest terms what the statement did. After 30 seconds, it was clear he didn’t even know what an if statement did.

There was nothing wrong with the code—it did what it was supposed to—but Edward couldn’t explain what it was doing, or how. It was perfectly clear to the rest of us.

I was perplexed.

How did this code get checked-in?
How did he write this code?
Who organized this presentation for him? Why would he show code he didn’t even understand?

In the coming weeks, I found out what happened. Edward would try to check something in, but when the lead got it, he’d rewrite it so it made sense and worked. Then the lead would check it in, leaving Edward’s name on it. And just like his code, the lead threw the presentation together.

Edward was in a largely administrative job. While he in his forties, he was making less than a lot of the software engineers who were fresh college graduates. He had a family to support and he decided he wanted to make at least what the new college graduates did.

So he started taking programming classes at night. He learned a language we used on a lot of our projects (I think it was C#). He was given a chance as a junior programmer on our project. But from this presentation, it was clear he didn’t know an if from a while or an else.

He was learning a language, but he wasn’t learning software engineering.

I felt bad for the guy. I liked Edward. I think everyone did. I think the lead was trying to “lift him up”. But it was clear he didn’t understand how to program. He wanted the money but didn’t have the skill.

I transferred to another department and I’m not sure what happened with Edward. He got another job eventually when the company lost the recompete on the single contract that was keeping them in business. I hope he eventually learned how to program because he really wanted—probably needed—to earn a better living.

If an engineer can’t explain their own code, there’s a good chance they didn’t write it.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/c6mwrtfa0l8gbh1j', 'title': 'How do I know if someone does not write their own code?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'They can’t explain it.\n\nAt one gig, we had weekly “code presentations” where a developer would get up and explain a recent change they made to the code, whether it be a new feature, a refactor or a bug fix. It was meant to be a short presentation, no longer than 30 minutes, and not overly code heavy. Code would be presented, but only for parts that were interesting or important. Questions would be taken from the other developers throughout.\n\nThe rotation came around to “Edward” and he showed part of a recent change, a really important if statement. He couldn’t explain it. He couldn’t even explain in the simplest terms what the statement did. After 30 seconds, it was clear he didn’t even know what an if statement did.\n\nThere was nothing wrong with the code—it did what it was supposed to—but Edward couldn’t explain what it was doing, or how. It was perfectly clear to the rest of us.\n\nI was perplexed.\n\nHow did this code get checked-in?\nHow did he write this code?\nWho organized this presentation for him? Why would he show code he didn’t even understand?\n\nIn the coming weeks, I found out what happened. Edward would try to check something in, but when the lead got it, he’d rewrite it so it made sense and worked. Then the lead would check it in, leaving Edward’s name on it. And just like his code, the lead threw the presentation together.\n\nEdward was in a largely administrative job. While he in his forties, he was making less than a lot of the software engineers who were fresh college graduates. He had a family to support and he decided he wanted to make at least what the new college graduates did.\n\nSo he started taking programming classes at night. He learned a language we used on a lot of our projects (I think it was C#). He was given a chance as a junior programmer on our project. But from this presentation, it was clear he didn’t know an if from a while or an else.\n\nHe was learning a language, but he wasn’t learning software engineering.\n\nI felt bad for the guy. I liked Edward. I think everyone did. I think the lead was trying to “lift him up”. But it was clear he didn’t understand how to program. He wanted the money but didn’t have the skill.\n\nI transferred to another department and I’m not sure what happened with Edward. He got another job eventually when the company lost the recompete on the single contract that was keeping them in business. I hope he eventually learned how to program because he really wanted—probably needed—to earn a better living.\n\nIf an engineer can’t explain their own code, there’s a good chance they didn’t write it.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983774, 'subscription': 0, 'content': 'They can’t explain it.\n\nAt one gig, we had weekly “code presentations” where a developer would get up and explain a recent change they made to the code, whether it be a new feature, a refactor or a bug fix. It was meant to be a short presentation, no longer than 30 minutes, and not overly code heavy. Code would be presented, but only for parts that were interesting or important. Questions would be taken from the other developers throughout.\n\nThe rotation came around to “Edward” and he showed part of a recent change, a really important if statement. He couldn’t explain it. He couldn’t even explain in the simplest terms what the statement did. After 30 seconds, it was clear he didn’t even know what an if statement did.\n\nThere was nothing wrong with the code—it did what it was supposed to—but Edward couldn’t explain what it was doing, or how. It was perfectly clear to the rest of us.\n\nI was perplexed.\n\nHow did this code get checked-in?\nHow did he write this code?\nWho organized this presentation for him? Why would he show code he didn’t even understand?\n\nIn the coming weeks, I found out what happened. Edward would try to check something in, but when the lead got it, he’d rewrite it so it made sense and worked. Then the lead would check it in, leaving Edward’s name on it. And just like his code, the lead threw the presentation together.\n\nEdward was in a largely administrative job. While he in his forties, he was making less than a lot of the software engineers who were fresh college graduates. He had a family to support and he decided he wanted to make at least what the new college graduates did.\n\nSo he started taking programming classes at night. He learned a language we used on a lot of our projects (I think it was C#). He was given a chance as a junior programmer on our project. But from this presentation, it was clear he didn’t know an if from a while or an else.\n\nHe was learning a language, but he wasn’t learning software engineering.\n\nI felt bad for the guy. I liked Edward. I think everyone did. I think the lead was trying to “lift him up”. But it was clear he didn’t understand how to program. He wanted the money but didn’t have the skill.\n\nI transferred to another department and I’m not sure what happened with Edward. He got another job eventually when the company lost the recompete on the single contract that was keeping them in business. I hope he eventually learned how to program because he really wanted—probably needed—to earn a better living.\n\nIf an engineer can’t explain their own code, there’s a good chance they didn’t write it.', 'aiModelVersion': '1'}",0.9998
Aaron Christianson,1y,Is Lisp more like a religion than a practical programming language?,"I’d say Lisp, for some, is more like a religious experience than a religion. It is certainly not a programming language in the sense of one programming language. There are forms of Lisp, like Clojure, which are very practical. There are other forms of Lisp, like R5RS Scheme, which are less practical (or at least they leave it up to individual implementations to add enough functionality to make them really practical).

The reason I say that Lisp is more like a religious experience is that most people experience a sort of enlightenment while using Lisp—the realization that code is just data which can be represented with a tree, and code can be constructed and deconstructed like any other tree data structure. Even if you don’t continue to use Lisp, this revelation can continue to inform the way you approach complex projects in other languages.

Some people may wish to continue using Lisp after this revelation because it makes code generation so intuitive, but plenty of people move on to other languages for practical reasons, which is fine.

I do think the insights of Lisp are something every programmer should experience, but it’s not necessary to use it for all kinds (or even any kinds) of real programming projects.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/lmpy8jt7kven6c5w', 'title': 'Is Lisp more like a religion than a practical programming language?', 'score': {'original': 0.5963, 'ai': 0.4037}, 'blocks': [{'text': 'I’d say Lisp, for some, is more like a religious experience than a religion. It is certainly not a programming language in the sense of one programming language. There are forms of Lisp, like Clojure, which are very practical. There are other forms of Lisp, like R5RS Scheme, which are less practical (or at least they leave it up to individual implementations to add enough functionality to make them really practical).\n\nThe reason I say that Lisp is more like a religious experience is that most people experience a sort of enlightenment while using Lisp—the realization that code is just data which can be represented with a tree, and code can be constructed and deconstructed like any other tree data structure. Even if you don’t continue to use Lisp, this revelation can continue to inform the way you approach complex projects in other languages.\n\nSome people may wish to continue using Lisp after this revelation because it makes code generation so intuitive, but plenty of people move on to other languages for practical reasons, which is fine.\n\nI do think the insights of Lisp are something every programmer should experience, but it’s not necessary to use it for all kinds (or even any kinds) of real programming projects.', 'result': {'fake': 0.4037, 'real': 0.5963}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983771, 'subscription': 0, 'content': 'I’d say Lisp, for some, is more like a religious experience than a religion. It is certainly not a programming language in the sense of one programming language. There are forms of Lisp, like Clojure, which are very practical. There are other forms of Lisp, like R5RS Scheme, which are less practical (or at least they leave it up to individual implementations to add enough functionality to make them really practical).\n\nThe reason I say that Lisp is more like a religious experience is that most people experience a sort of enlightenment while using Lisp—the realization that code is just data which can be represented with a tree, and code can be constructed and deconstructed like any other tree data structure. Even if you don’t continue to use Lisp, this revelation can continue to inform the way you approach complex projects in other languages.\n\nSome people may wish to continue using Lisp after this revelation because it makes code generation so intuitive, but plenty of people move on to other languages for practical reasons, which is fine.\n\nI do think the insights of Lisp are something every programmer should experience, but it’s not necessary to use it for all kinds (or even any kinds) of real programming projects.', 'aiModelVersion': '1'}",0.5963
Greg Kemnitz,9y,How do I learn all (I mean everything) of the Linux commands?,"I agree that for the most part, you can learn obscure commands as you need them. If I were to recommend a short list of commands, I'd say:


Commands useful in scripts


1. Learn Bash as a programming language. (Yes, it is one) Pipes, subshells, job control, and process handling are all useful to know well.
2. Learn how commands react when they exit on success and exit on error, so you can process them in Bash scripts.
3. Learn sed, awk, grep, and egrep.
4. Occasionally, sort and uniq can be useful, as is expr for calculations.
5. It's also worth knowing how to use date for date formatting on occasion, particularly if you're doing bash scripts that create files with dates in the filename.

Other commands worth knowing well

1. The ""find"" command is very useful for working with big directory trees, especially if used with its -exec option, including such things as -exec grep, etc.
2. The ""ps"" command in its full glory is useful.
3. Obviously, ls, cd, pushd/popd.
4. man itself
5. Your favorite browser, so you can ask questions and google up the more obscure commands :) Linux and Unix have a lot of apps that you'll use once a year and basically forget the rest of the time.

Learn either the emacs or vi editor really well, including the global ""line edit"" modes, which are shockingly powerful.


Personally, I'm a ""vi"" guy, but will forgive you if you become an emacs person :) But learn to edit directly on Linux and not in notepad or a ""cut & paste"" style editor. Also, I'd advise not getting too attached to GUI-level tools - the command line is your friend, and if you're doing serious Linux, you will need to work in environments where no GUI is available.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/8ot5kym42ndegz13', 'title': 'How do I learn all (I mean everything) of the Linux commands?', 'score': {'original': 0.8617, 'ai': 0.1383}, 'blocks': [{'text': 'I agree that for the most part, you can learn obscure commands as you need them. If I were to recommend a short list of commands, I\'d say:\n\n\nCommands useful in scripts\n\n\n1. Learn Bash as a programming language. (Yes, it is one) Pipes, subshells, job control, and process handling are all useful to know well.\n2. Learn how commands react when they exit on success and exit on error, so you can process them in Bash scripts.\n3. Learn sed, awk, grep, and egrep.\n4. Occasionally, sort and uniq can be useful, as is expr for calculations.\n5. It\'s also worth knowing how to use date for date formatting on occasion, particularly if you\'re doing bash scripts that create files with dates in the filename.\n\nOther commands worth knowing well\n\n1. The ""find"" command is very useful for working with big directory trees, especially if used with its -exec option, including such things as -exec grep, etc.\n2. The ""ps"" command in its full glory is useful.\n3. Obviously, ls, cd, pushd/popd.\n4. man itself\n5. Your favorite browser, so you can ask questions and google up the more obscure commands :) Linux and Unix have a lot of apps that you\'ll use once a year and basically forget the rest of the time.\n\nLearn either the emacs or vi editor really well, including the global ""line edit"" modes, which are shockingly powerful.\n\n\nPersonally, I\'m a ""vi"" guy, but will forgive you if you become an emacs person :) But learn to edit directly on Linux and not in notepad or a ""cut & paste"" style editor. Also, I\'d advise not getting too attached to GUI-level tools - the command line is your friend, and if you\'re doing serious Linux, you will need to work in environments where no GUI is available.', 'result': {'fake': 0.3218, 'real': 0.6782}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983768, 'subscription': 0, 'content': 'I agree that for the most part, you can learn obscure commands as you need them. If I were to recommend a short list of commands, I\'d say:\n\n\nCommands useful in scripts\n\n\n1. Learn Bash as a programming language. (Yes, it is one) Pipes, subshells, job control, and process handling are all useful to know well.\n2. Learn how commands react when they exit on success and exit on error, so you can process them in Bash scripts.\n3. Learn sed, awk, grep, and egrep.\n4. Occasionally, sort and uniq can be useful, as is expr for calculations.\n5. It\'s also worth knowing how to use date for date formatting on occasion, particularly if you\'re doing bash scripts that create files with dates in the filename.\n\nOther commands worth knowing well\n\n1. The ""find"" command is very useful for working with big directory trees, especially if used with its -exec option, including such things as -exec grep, etc.\n2. The ""ps"" command in its full glory is useful.\n3. Obviously, ls, cd, pushd/popd.\n4. man itself\n5. Your favorite browser, so you can ask questions and google up the more obscure commands :) Linux and Unix have a lot of apps that you\'ll use once a year and basically forget the rest of the time.\n\nLearn either the emacs or vi editor really well, including the global ""line edit"" modes, which are shockingly powerful.\n\n\nPersonally, I\'m a ""vi"" guy, but will forgive you if you become an emacs person :) But learn to edit directly on Linux and not in notepad or a ""cut & paste"" style editor. Also, I\'d advise not getting too attached to GUI-level tools - the command line is your friend, and if you\'re doing serious Linux, you will need to work in environments where no GUI is available.', 'aiModelVersion': '1'}",0.8617
Bobby Polzer,Updated 6y,What should I give to a computer programmer?,"Recently, my boss bought me a new Lenovo PC with 16 GB RAM, 2 TB HDD, a new monitor and a nice keyboard. Additionally, he gave me a comfortable chair (very important). There is already a huge book shelve, where I can put my books in that I frequently need for work. Also a coffee machine, a microwave and a fridge is a few steps away from my working place. That’s all I need to be happy, efficient (hopefully) and (very) thankful.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/hti5x26wsynaf3kd', 'title': 'What should I give to a computer programmer?', 'score': {'original': 0.9979, 'ai': 0.0021}, 'blocks': [{'text': 'Recently, my boss bought me a new Lenovo PC with 16 GB RAM, 2 TB HDD, a new monitor and a nice keyboard. Additionally, he gave me a comfortable chair (very important). There is already a huge book shelve, where I can put my books in that I frequently need for work. Also a coffee machine, a microwave and a fridge is a few steps away from my working place. That’s all I need to be happy, efficient (hopefully) and (very) thankful.', 'result': {'fake': 0.0021, 'real': 0.9979}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983767, 'subscription': 0, 'content': 'Recently, my boss bought me a new Lenovo PC with 16 GB RAM, 2 TB HDD, a new monitor and a nice keyboard. Additionally, he gave me a comfortable chair (very important). There is already a huge book shelve, where I can put my books in that I frequently need for work. Also a coffee machine, a microwave and a fridge is a few steps away from my working place. That’s all I need to be happy, efficient (hopefully) and (very) thankful.', 'aiModelVersion': '1'}",0.9979
Anna Sharudenko,6y,"If almost everyone can learn programming for free, why is the salary relatively very high?","The majority of people doesn’t give a flying unicorn about programming. They can over romanticize the idea of sitting on your butt cheeks, sipping coffee, and pushing buttons. But sticking to it is harder than you think, unless you program for the joy of it.

You are capable of becoming a spectacular programmer with a few hundred bucks worth of books, an Internet connection, an old laptop, and hard work. If you are not passionate, debugging will flush your brain cells down the toilet.

Do you know why people try to do it? For money. That’s why they fail.

When you breathe in the code, and exhale functions and syntax, while genuinely enjoying the process, you have a good shot to become decent. But if it’s a torture in the rectum and 1 minute feels 5 hours long, just quit. Get your priorities straight.

Good programmers code because they don’t have a choice. They love doing it. It’s an addiction. Money is great, but loving your work is so gratifying.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/04rgtqikecyxvh2o', 'title': 'If almost everyone can learn programming for free, why is the salary relatively very high?', 'score': {'original': 0.999, 'ai': 0.001}, 'blocks': [{'text': 'The majority of people doesn’t give a flying unicorn about programming. They can over romanticize the idea of sitting on your butt cheeks, sipping coffee, and pushing buttons. But sticking to it is harder than you think, unless you program for the joy of it.\n\nYou are capable of becoming a spectacular programmer with a few hundred bucks worth of books, an Internet connection, an old laptop, and hard work. If you are not passionate, debugging will flush your brain cells down the toilet.\n\nDo you know why people try to do it? For money. That’s why they fail.\n\nWhen you breathe in the code, and exhale functions and syntax, while genuinely enjoying the process, you have a good shot to become decent. But if it’s a torture in the rectum and 1 minute feels 5 hours long, just quit. Get your priorities straight.\n\nGood programmers code because they don’t have a choice. They love doing it. It’s an addiction. Money is great, but loving your work is so gratifying.', 'result': {'fake': 0.001, 'real': 0.999}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983765, 'subscription': 0, 'content': 'The majority of people doesn’t give a flying unicorn about programming. They can over romanticize the idea of sitting on your butt cheeks, sipping coffee, and pushing buttons. But sticking to it is harder than you think, unless you program for the joy of it.\n\nYou are capable of becoming a spectacular programmer with a few hundred bucks worth of books, an Internet connection, an old laptop, and hard work. If you are not passionate, debugging will flush your brain cells down the toilet.\n\nDo you know why people try to do it? For money. That’s why they fail.\n\nWhen you breathe in the code, and exhale functions and syntax, while genuinely enjoying the process, you have a good shot to become decent. But if it’s a torture in the rectum and 1 minute feels 5 hours long, just quit. Get your priorities straight.\n\nGood programmers code because they don’t have a choice. They love doing it. It’s an addiction. Money is great, but loving your work is so gratifying.', 'aiModelVersion': '1'}",0.999
Peter Lewerin,4y,What is the most horrible piece of code you have ever seen that made you doubt the programmer understands the language? For me: if (condition) then return true else return false.,"That’s a Boolean unifier (converts from general truth to Boolean type). It’s not elegant, but not especially horrible either.

The most horrible code I’ve seen involves meticulously calling free() for every pointer when not in use any more, and putting if (p != NULL) guards around code that might use the pointer. As if free() somehow changed the value of the pointer to NULL.

Worse, the writer of that code is sitting right here with my cat. It was a long time ago when I was still young, but still I really should have known better.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/vjeky6fxh5o7tibm', 'title': 'What is the most horrible piece of code you have ever seen that made you doubt the programmer understands the language? For me: if (condition) then return true else return false.', 'score': {'original': 0.9967, 'ai': 0.0033}, 'blocks': [{'text': 'That’s a Boolean unifier (converts from general truth to Boolean type). It’s not elegant, but not especially horrible either.\n\nThe most horrible code I’ve seen involves meticulously calling free() for every pointer when not in use any more, and putting if (p != NULL) guards around code that might use the pointer. As if free() somehow changed the value of the pointer to NULL.\n\nWorse, the writer of that code is sitting right here with my cat. It was a long time ago when I was still young, but still I really should have known better.', 'result': {'fake': 0.0033, 'real': 0.9967}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983764, 'subscription': 0, 'content': 'That’s a Boolean unifier (converts from general truth to Boolean type). It’s not elegant, but not especially horrible either.\n\nThe most horrible code I’ve seen involves meticulously calling free() for every pointer when not in use any more, and putting if (p != NULL) guards around code that might use the pointer. As if free() somehow changed the value of the pointer to NULL.\n\nWorse, the writer of that code is sitting right here with my cat. It was a long time ago when I was still young, but still I really should have known better.', 'aiModelVersion': '1'}",0.9967
Jerry Rufener,Updated 3y,How was the first programming language created without an operating system?,"Computers don’t necessarily have to have operating systems!!!!

An extremely popular computer was the PDP8 series of computers introduced in 1965 and a development the earlier PDP5. They were made by Digital Equipment Corporation (DEC) of Maynard, MA. They were THE minicomputer for many years. It had several OS’s available but were often sold/used without an OS - in fact without a disk. I have personally used them that way.

Here is a picture of one of the more popular versions, the PDP8/e. (By Florian Schäffer - Own work, CC BY-SA 4.0, File:Digital pdp8-e2.jpg
)

Notice the switches. To use it you sat in front of it and, using those switches, toggled in the RIM (Read In Mode) loader which was (as I recall) about 20 instructions long. You entered the 12 bit address using the switches, you pressed LOAD ADDR, you entered your first 12 bit instruction, you pressed DEP - that instruction was loaded at the specified memory address and address was incremented. You loaded your next instruction, you pressed DEP again … repeated until all the instructions were loaded. Now you entered the starting address of the loader, pressed LOAD ADDR and then pressed RUN. The RIM loader would execute. Its job was to load the BIN (Binary) loader, on paper tape, from your ASR-33 teletype (33 character per second). The BIN loaded would then load a program from a binary paper tape from the ASR-33.

If it was a cold start you probably read in editor - which allowed you to enter your source code at the, again, ASR-33. The editor would then print out a listing of your program on the ASR-33 and a paper tape of the source code. The source code was most likely in assembler. You then loaded the assembly program using - you guessed it - the ASR33.

The assembler read the source code from the paper tape using the ASR33. If all went well, the assembler would punch out a paper tape in object format. More likely - the first few times - you got errors and had to go back to the editor to fix them. You goal was to produce a paper tape with object code on it.

You would then load the linker and link all of the object modules you produced together - along with any libraries. This could produce more errors which sent you back several steps.

Once you had a clean binary, you loaded in using the BIN loader and the debugging fun began! No symbolic debug - you put debugging instructions into your own code.

Fun huh???

There were disks available - very expensive - very small. Also available was “drum” memory - it is like a disk but built like an Edison cylindrical phonograph. More common were tapes - both 7 and 9 track IBM compatible mag-tapes could be had - if you had the money. More common was something called DECtape - which was actually pretty slick and found on, I think, most PPD8’s. You could get an high speed paper tape reader (100 cps). You could get a ROM loader with RIM on it, but it took and entire slot in the computer, to save the toggling in process. Why didn’t everyone get these items? The computer alone cost $10,000 - for a base model. A disk would at least double the price. You can see where that goes.

Now if you were with a large organization they would have one machine with all the bells and whistles for the developer. They then distributed their application (and updates) on paper tape to machines in the field that were bare bones. I worked on one veneer processing system that was exactly that way. I was with DEC - the OEM (the company that developed the software) bought PDP8s from DEC - they built the electrical/electronic interface to control the veneer manufacturing equipment. They sold it to the end user along with the software.

While you could buy a computer directly from DEC, most were sold via the OEM route. They were installed and used without an OS.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/modujhexb263vf7q', 'title': 'How was the first programming language created without an operating system?', 'score': {'original': 0.99245, 'ai': 0.00755}, 'blocks': [{'text': 'Computers don’t necessarily have to have operating systems!!!!\n\nAn extremely popular computer was the PDP8 series of computers introduced in 1965 and a development the earlier PDP5. They were made by Digital Equipment Corporation (DEC) of Maynard, MA. They were THE minicomputer for many years. It had several OS’s available but were often sold/used without an OS - in fact without a disk. I have personally used them that way.\n\nHere is a picture of one of the more popular versions, the PDP8/e. (By Florian Schäffer - Own work, CC BY-SA 4.0, File:Digital pdp8-e2.jpg\n)\n\nNotice the switches. To use it you sat in front of it and, using those switches, toggled in the RIM (Read In Mode) loader which was (as I recall) about 20 instructions long. You entered the 12 bit address using the switches, you pressed LOAD ADDR, you entered your first 12 bit instruction, you pressed DEP - that instruction was loaded at the specified memory address and address was incremented. You loaded your next instruction, you pressed DEP again … repeated until all the instructions were loaded. Now you entered the starting address of the loader, pressed LOAD ADDR and then pressed RUN. The RIM loader would execute. Its job was to load the BIN (Binary) loader, on paper tape, from your ASR-33 teletype (33 character per second). The BIN loaded would then load a program from a binary paper tape from the ASR-33.\n\nIf it was a cold start you probably read in editor - which allowed you to enter your source code at the, again, ASR-33. The editor would then print out a listing of your program on the ASR-33 and a paper tape of the source code. The source code was most likely in assembler. You then loaded the assembly program using - you guessed it - the ASR33.\n\nThe assembler read the source code from the paper tape using the ASR33. If all went well, the assembler would punch out a paper tape in object format. More likely - the first few times - you got errors and had to go back to the editor to fix them. You goal was to produce a paper tape with object code on it.\n\nYou would then load the linker and link all of the object modules you produced together - along with any libraries. This could produce more errors which sent you back several steps.\n\nOnce you had a clean binary, you loaded in using the BIN loader and the debugging fun began! No symbolic debug - you put debugging instructions into your own code.\n\nFun huh???\n\nThere were disks available - very expensive - very small. Also available was “drum” memory - it is like a disk but built like an Edison cylindrical phonograph. More common were tapes - both 7 and 9 track IBM compatible mag-tapes could be had - if you had the money. More common was something called DECtape - which was actually pretty slick and found on, I think, most PPD8’s. You could get an high speed paper tape reader (100 cps). You could get a ROM loader with RIM', 'result': {'fake': 0.0167, 'real': 0.9833}, 'status': 'success'}, {'text': 'on it, but it took and entire slot in the computer, to save the toggling in process. Why didn’t everyone get these items? The computer alone cost $10,000 - for a base model. A disk would at least double the price. You can see where that goes.\n\nNow if you were with a large organization they would have one machine with all the bells and whistles for the developer. They then distributed their application (and updates) on paper tape to machines in the field that were bare bones. I worked on one veneer processing system that was exactly that way. I was with DEC - the OEM (the company that developed the software) bought PDP8s from DEC - they built the electrical/electronic interface to control the veneer manufacturing equipment. They sold it to the end user along with the software.\n\nWhile you could buy a computer directly from DEC, most were sold via the OEM route. They were installed and used without an OS.', 'result': {'fake': 0.0717, 'real': 0.9283}, 'status': 'success'}], 'credits_used': 7, 'credits': 1983757, 'subscription': 0, 'content': 'Computers don’t necessarily have to have operating systems!!!!\n\nAn extremely popular computer was the PDP8 series of computers introduced in 1965 and a development the earlier PDP5. They were made by Digital Equipment Corporation (DEC) of Maynard, MA. They were THE minicomputer for many years. It had several OS’s available but were often sold/used without an OS - in fact without a disk. I have personally used them that way.\n\nHere is a picture of one of the more popular versions, the PDP8/e. (By Florian Schäffer - Own work, CC BY-SA 4.0, File:Digital pdp8-e2.jpg\n)\n\nNotice the switches. To use it you sat in front of it and, using those switches, toggled in the RIM (Read In Mode) loader which was (as I recall) about 20 instructions long. You entered the 12 bit address using the switches, you pressed LOAD ADDR, you entered your first 12 bit instruction, you pressed DEP - that instruction was loaded at the specified memory address and address was incremented. You loaded your next instruction, you pressed DEP again … repeated until all the instructions were loaded. Now you entered the starting address of the loader, pressed LOAD ADDR and then pressed RUN. The RIM loader would execute. Its job was to load the BIN (Binary) loader, on paper tape, from your ASR-33 teletype (33 character per second). The BIN loaded would then load a program from a binary paper tape from the ASR-33.\n\nIf it was a cold start you probably read in editor - which allowed you to enter your source code at the, again, ASR-33. The editor would then print out a listing of your program on the ASR-33 and a paper tape of the source code. The source code was most likely in assembler. You then loaded the assembly program using - you guessed it - the ASR33.\n\nThe assembler read the source code from the paper tape using the ASR33. If all went well, the assembler would punch out a paper tape in object format. More likely - the first few times - you got errors and had to go back to the editor to fix them. You goal was to produce a paper tape with object code on it.\n\nYou would then load the linker and link all of the object modules you produced together - along with any libraries. This could produce more errors which sent you back several steps.\n\nOnce you had a clean binary, you loaded in using the BIN loader and the debugging fun began! No symbolic debug - you put debugging instructions into your own code.\n\nFun huh???\n\nThere were disks available - very expensive - very small. Also available was “drum” memory - it is like a disk but built like an Edison cylindrical phonograph. More common were tapes - both 7 and 9 track IBM compatible mag-tapes could be had - if you had the money. More common was something called DECtape - which was actually pretty slick and found on, I think, most PPD8’s. You could get an high speed paper tape reader (100 cps). You could get a ROM loader with RIM on it, but it took and entire slot in the computer, to save the toggling in process. Why didn’t everyone get these items? The computer alone cost $10,000 - for a base model. A disk would at least double the price. You can see where that goes.\n\nNow if you were with a large organization they would have one machine with all the bells and whistles for the developer. They then distributed their application (and updates) on paper tape to machines in the field that were bare bones. I worked on one veneer processing system that was exactly that way. I was with DEC - the OEM (the company that developed the software) bought PDP8s from DEC - they built the electrical/electronic interface to control the veneer manufacturing equipment. They sold it to the end user along with the software.\n\nWhile you could buy a computer directly from DEC, most were sold via the OEM route. They were installed and used without an OS.', 'aiModelVersion': '1'}",0.99245
Alan Mellor,5y,Why do people think coding is difficult?,"Because it gets difficult.

Simple amateur coding is trivial and most people can do it. Making an Excel spreadsheet, probably making ten or twenty lines of code in a programming language is something most people could do I think.

As a job, two factors mess that up:

Figuring out what to code. You just get asked, say, ‘Can you make it email me if more than five expense claims get rejected on the same day for the same person?’. How do you code that?
Fitting it in to existing code. You have to figure out how to fit your new code in to the existing code without breaking it. It might be millions of lines you have never seen. it might be very badly constructed and might break on small changes.

That bit is hard.

And then, we want to do better as professionals.

We want our code to have automated tests, which changes how you design it a bit.

We want it to be easy to deploy to computers, so you have to design that in.

We want it free from security holes, to keep data safe.

We want to never corrupt any data.

We want our colleagues to easily read and easily change our code, which needs designing in.

We want our code to be robust and correctly handle bad data, bad user input and anything else ‘unexpected’. We have to learn to expect that.

Those bits are pretty hard, too.

Then, our bosses want to know when all that is going to be ready, so they can plan around it. Once the TV advert goes live, that software better be running.

That’s hard.

We have to juggle competing priorities of adding features, managing tech debt and fixing bugs.

There’s no right answer for that. Somebody is always disappointed.

We have to cope with floods of new users and feature requests that are difficult to build. The whole ‘scalability’ piece is hard.

The code needs to stay running 24/7 or close to it - even if half the computers, disk drives, cooling systems, internet switches and electrical power fails.

That adds a bit of trickyness for sure.

We need to use existing libraries wherever we can, so we need to understand code we’ve not written. Tricky. But trickier still, we need to be part-time lawyers, because we have to check we are legally allowed to use that code without it affecting the business.

We need to remember somebody pays for all the computing our code runs on, so we have to make it play nice.

We have to work for and with people who range from fantastic humans to the sort you’d rather not spend time with. And with all ranges of skill levels.

That’s a real mixed bag.

We have to know so much about computing, engineering, the problem area we are solving, testing.

Coding isn’t hard - if you are left alone to code what you want, when you want, how you want and keep the option to just give up when it gets too hard.

That’s the really hard bit: we can’t do that.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/mg1sbdn78l9ox4ez', 'title': 'Why do people think coding is difficult?', 'score': {'original': 0.41225, 'ai': 0.58775}, 'blocks': [{'text': 'Because it gets difficult.\n\nSimple amateur coding is trivial and most people can do it. Making an Excel spreadsheet, probably making ten or twenty lines of code in a programming language is something most people could do I think.\n\nAs a job, two factors mess that up:\n\nFiguring out what to code. You just get asked, say, ‘Can you make it email me if more than five expense claims get rejected on the same day for the same person?’. How do you code that?\nFitting it in to existing code. You have to figure out how to fit your new code in to the existing code without breaking it. It might be millions of lines you have never seen. it might be very badly constructed and might break on small changes.\n\nThat bit is hard.\n\nAnd then, we want to do better as professionals.\n\nWe want our code to have automated tests, which changes how you design it a bit.\n\nWe want it to be easy to deploy to computers, so you have to design that in.\n\nWe want it free from security holes, to keep data safe.\n\nWe want to never corrupt any data.\n\nWe want our colleagues to easily read and easily change our code, which needs designing in.\n\nWe want our code to be robust and correctly handle bad data, bad user input and anything else ‘unexpected’. We have to learn to expect that.\n\nThose bits are pretty hard, too.\n\nThen, our bosses want to know when all that is going to be ready, so they can plan around it. Once the TV advert goes live, that software better be running.\n\nThat’s hard.\n\nWe have to juggle competing priorities of adding features, managing tech debt and fixing bugs.\n\nThere’s no right answer for that. Somebody is always disappointed.\n\nWe have to cope with floods of new users and feature requests that are difficult to build. The whole ‘scalability’ piece is hard.\n\nThe code needs to stay running 24/7 or close to it - even if half the computers, disk drives, cooling systems, internet switches and electrical power fails.\n\nThat adds a bit of trickyness for sure.\n\nWe need to use existing libraries wherever we can, so we need to understand code we’ve not written. Tricky. But trickier still, we need to be part-time lawyers, because we have to check we are legally allowed to use that code without it affecting the business.\n\nWe need to remember somebody pays for all the computing our code runs on, so we have to make it play nice.\n\nWe have to work for and with people who range from fantastic humans to the sort you’d rather not spend time with. And with all ranges of skill levels.\n\nThat’s a real mixed bag.\n\nWe have to know so much about computing, engineering, the problem area we are solving, testing.\n\nCoding isn’t hard - if you are left alone to code what you want, when you want, how you want and keep the option to just give up when it gets too hard.\n\nThat’s the really hard bit: we can’t do that.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 6, 'credits': 1983751, 'subscription': 0, 'content': 'Because it gets difficult.\n\nSimple amateur coding is trivial and most people can do it. Making an Excel spreadsheet, probably making ten or twenty lines of code in a programming language is something most people could do I think.\n\nAs a job, two factors mess that up:\n\nFiguring out what to code. You just get asked, say, ‘Can you make it email me if more than five expense claims get rejected on the same day for the same person?’. How do you code that?\nFitting it in to existing code. You have to figure out how to fit your new code in to the existing code without breaking it. It might be millions of lines you have never seen. it might be very badly constructed and might break on small changes.\n\nThat bit is hard.\n\nAnd then, we want to do better as professionals.\n\nWe want our code to have automated tests, which changes how you design it a bit.\n\nWe want it to be easy to deploy to computers, so you have to design that in.\n\nWe want it free from security holes, to keep data safe.\n\nWe want to never corrupt any data.\n\nWe want our colleagues to easily read and easily change our code, which needs designing in.\n\nWe want our code to be robust and correctly handle bad data, bad user input and anything else ‘unexpected’. We have to learn to expect that.\n\nThose bits are pretty hard, too.\n\nThen, our bosses want to know when all that is going to be ready, so they can plan around it. Once the TV advert goes live, that software better be running.\n\nThat’s hard.\n\nWe have to juggle competing priorities of adding features, managing tech debt and fixing bugs.\n\nThere’s no right answer for that. Somebody is always disappointed.\n\nWe have to cope with floods of new users and feature requests that are difficult to build. The whole ‘scalability’ piece is hard.\n\nThe code needs to stay running 24/7 or close to it - even if half the computers, disk drives, cooling systems, internet switches and electrical power fails.\n\nThat adds a bit of trickyness for sure.\n\nWe need to use existing libraries wherever we can, so we need to understand code we’ve not written. Tricky. But trickier still, we need to be part-time lawyers, because we have to check we are legally allowed to use that code without it affecting the business.\n\nWe need to remember somebody pays for all the computing our code runs on, so we have to make it play nice.\n\nWe have to work for and with people who range from fantastic humans to the sort you’d rather not spend time with. And with all ranges of skill levels.\n\nThat’s a real mixed bag.\n\nWe have to know so much about computing, engineering, the problem area we are solving, testing.\n\nCoding isn’t hard - if you are left alone to code what you want, when you want, how you want and keep the option to just give up when it gets too hard.\n\nThat’s the really hard bit: we can’t do that.', 'aiModelVersion': '1'}",0.41225
Akash Deep,10mo,What are some good coding competition/practice sites?,"Solving coding problems is a great method to advance your coding abilities. You may improve your problem-solving skills, master the nuances of programming languages, get ready for job interviews, discover new algorithms, and more by tackling various challenges and puzzles. There are several well-known websites for coding challenges that assist you in doing so by offering various types of tasks that require you to use your mathematical and analytical abilities to answer using programming languages. The top 5 websites for coding challenges are highlighted below –

LeetCode

One of the biggest tech communities is LeetCode, which has millions of people that are active every day. It provides competitors with a variety of weekly and biweekly programming competitions. Also, it aids in interview preparation, and conversations are available on LeetCode. It offers 90-minute contests where you may use any of the supported programming languages to complete the tasks in their online editor, sometimes known as a playground.

LeetCode is one of the largest tech communities with millions of active users.
You can practice over 2300+ coding problems and the number is increasing day by day!
LeetCode supports over 14 popular coding languages that make it more preferable.

HackerRank

HackerRank is a well-known site for programming competitions where you must complete tasks according to predetermined guidelines. You may complete these programming tasks on HackerRank using any of the many programming languages available, including C, Java, Python, Ruby, etc. In addition, participants can work through issues in a variety of computer science fields, including artificial intelligence, machine learning, and algorithms. By completing tasks on the HackerRank website, you may also earn badges that will be added to your profile. The following is a list of the several contests HackerRank has hosted:

101-Hack – A monthly algorithmic contest in which five challenges have to be solved within 2 hours.

HourRank – The shortest contest format in which 3-4 algorithm challenges need to be solved within 1 hour.

Week of Code – A weeklong algorithm contest where one new challenge is offered each day. Also, the challenges become more complicated as the day passes.

Ad Infinitum – A 48-hour contest of Mathematics conducted every three months.

Real Data/Machine Learning Contests – A weeklong contest focuses on real-world data skills and requires the use of machine learning techniques.

Language/Domain Specific Contests – These are the contest based on various programming languages like C, Java, Python, etc.

Company Contests – The contests sponsored by specific companies that are looking to hire developers. The nature of this contest varies as per the requirements of the sponsoring companies.

World CodeSprint – It is a 24-hour contest having 7-8 challenges to be solved.

GeeksForGeeks

Every month, GeeksForGeeks holds a number of programming competitions through the practice portal, including a number of job-a-thons for freshmen to gain employment prospects at a sizable number of organizations. In addition, several more monthly, weekly, and daily challenges are often presented on websites. It is an individual participation competition. Participants have the chance to be employed by a variety of businesses that choose candidates for interviews based on their own standards. This coding contest is only open to students. The top 100 students have access to free courses as well as a chance to win interesting prizes.

CodeChef

Aspiring programmers may test and hone their programming abilities through a variety of online competitions on the competitive programming website CodeChef. Every month, CodeChef has a larger programming competition at the beginning and two smaller contests in the middle and end of the month. You can submit your solution in any of the more than 55 programming languages supported by the competitions, including C, C++, Java, and Python. To make the process of computer programming more approachable, CodeChef also provides a variety of algorithm lessons and forum discussions in addition to these competitions. Gaining points and climbing the ranks of CodeChef is highly worthwhile. There are various coding competitions where you can show your programming skills such as – Monthly Programming Contests, Cook-off and Lunchtime Coding Contests. Some of the major stats regarding CodeChef contests are listed below:

CodeChef has around 1,250,000+ programmers from 12,000 institutions.
There are approximately 3200+ programming contests with around 92 million+ submissions.
The contests have prizes of around INR 20,000 for Indian Community and $700 for Global Community.

Codeforces

Aspiring programmers may test and hone their programming abilities through a variety of online competitions on the competitive programming website CodeChef. Every month, CodeChef has a larger programming competition at the beginning and two smaller contests in the middle and end of the month. You can submit your solution in any of the more than 55 programming languages supported by the competitions, including C, C++, Java, and Python. To make the process of computer programming more approachable, CodeChef also provides a variety of algorithm lessons and forum discussions in addition to these competitions. Gaining points and climbing the ranks of CodeChef is highly worthwhile. The best thing about Codeforces is that the contests are regularly conducted here as every month they organize nearly 6 contests. Also, participation in the contests is free and open to everybody. Codeforces offers various type of coding challenges and features such as –

Short format Contests with a duration of 2 hours.
Educational Contests of 2-2.5 hours duration conducted 2-3 times in a month.
You can challenge or hack other contestants’ solutions as well.
You can also solve problems from previous contests for learning objectives.

Conclusion

This list was based on a few things: my own experiences using the websites, and some Google searches. I also frequented some forums and subreddits such as r/learnSystemDesign, r/developersIndia to see what websites were usually recommended by the users there. To upskill your coding skills, you can join online courses like Logicmojo, Coding Ninjas or Scaler Academy. These sites can help you to improve your coding skills, learn new techniques and algorithms, and prepare for technical interviews and coding competitions.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/2f5li4yudnbsp1gt', 'title': 'What are some good coding competition/practice sites?', 'score': {'original': 0.06985, 'ai': 0.93015}, 'blocks': [{'text': 'Solving coding problems is a great method to advance your coding abilities. You may improve your problem-solving skills, master the nuances of programming languages, get ready for job interviews, discover new algorithms, and more by tackling various challenges and puzzles. There are several well-known websites for coding challenges that assist you in doing so by offering various types of tasks that require you to use your mathematical and analytical abilities to answer using programming languages. The top 5 websites for coding challenges are highlighted below –\n\nLeetCode\n\nOne of the biggest tech communities is LeetCode, which has millions of people that are active every day. It provides competitors with a variety of weekly and biweekly programming competitions. Also, it aids in interview preparation, and conversations are available on LeetCode. It offers 90-minute contests where you may use any of the supported programming languages to complete the tasks in their online editor, sometimes known as a playground.\n\nLeetCode is one of the largest tech communities with millions of active users.\nYou can practice over 2300+ coding problems and the number is increasing day by day!\nLeetCode supports over 14 popular coding languages that make it more preferable.\n\nHackerRank\n\nHackerRank is a well-known site for programming competitions where you must complete tasks according to predetermined guidelines. You may complete these programming tasks on HackerRank using any of the many programming languages available, including C, Java, Python, Ruby, etc. In addition, participants can work through issues in a variety of computer science fields, including artificial intelligence, machine learning, and algorithms. By completing tasks on the HackerRank website, you may also earn badges that will be added to your profile. The following is a list of the several contests HackerRank has hosted:\n\n101-Hack – A monthly algorithmic contest in which five challenges have to be solved within 2 hours.\n\nHourRank – The shortest contest format in which 3-4 algorithm challenges need to be solved within 1 hour.\n\nWeek of Code – A weeklong algorithm contest where one new challenge is offered each day. Also, the challenges become more complicated as the day passes.\n\nAd Infinitum – A 48-hour contest of Mathematics conducted every three months.\n\nReal Data/Machine Learning Contests – A weeklong contest focuses on real-world data skills and requires the use of machine learning techniques.\n\nLanguage/Domain Specific Contests – These are the contest based on various programming languages like C, Java, Python, etc.\n\nCompany Contests – The contests sponsored by specific companies that are looking to hire developers. The nature of this contest varies as per the requirements of the sponsoring companies.\n\nWorld CodeSprint – It is a 24-hour contest having 7-8 challenges to be solved.\n\nGeeksForGeeks\n\nEvery month, GeeksForGeeks holds a number of programming competitions through the practice portal, including a number of job-a-thons for freshmen to gain employment prospects at a sizable number of organizations. In addition, several more monthly, weekly, and daily challenges are often presented on websites. It is an individual participation competition. Participants have the chance to be employed by a variety of businesses that choose candidates for interviews based on their own standards. This coding contest is only open to students. The top 100 students have', 'result': {'fake': 0.7137, 'real': 0.2863}, 'status': 'success'}, {'text': 'access to free courses as well as a chance to win interesting prizes.\n\nCodeChef\n\nAspiring programmers may test and hone their programming abilities through a variety of online competitions on the competitive programming website CodeChef. Every month, CodeChef has a larger programming competition at the beginning and two smaller contests in the middle and end of the month. You can submit your solution in any of the more than 55 programming languages supported by the competitions, including C, C++, Java, and Python. To make the process of computer programming more approachable, CodeChef also provides a variety of algorithm lessons and forum discussions in addition to these competitions. Gaining points and climbing the ranks of CodeChef is highly worthwhile. There are various coding competitions where you can show your programming skills such as – Monthly Programming Contests, Cook-off and Lunchtime Coding Contests. Some of the major stats regarding CodeChef contests are listed below:\n\nCodeChef has around 1,250,000+ programmers from 12,000 institutions.\nThere are approximately 3200+ programming contests with around 92 million+ submissions.\nThe contests have prizes of around INR 20,000 for Indian Community and $700 for Global Community.\n\nCodeforces\n\nAspiring programmers may test and hone their programming abilities through a variety of online competitions on the competitive programming website CodeChef. Every month, CodeChef has a larger programming competition at the beginning and two smaller contests in the middle and end of the month. You can submit your solution in any of the more than 55 programming languages supported by the competitions, including C, C++, Java, and Python. To make the process of computer programming more approachable, CodeChef also provides a variety of algorithm lessons and forum discussions in addition to these competitions. Gaining points and climbing the ranks of CodeChef is highly worthwhile. The best thing about Codeforces is that the contests are regularly conducted here as every month they organize nearly 6 contests. Also, participation in the contests is free and open to everybody. Codeforces offers various type of coding challenges and features such as –\n\nShort format Contests with a duration of 2 hours.\nEducational Contests of 2-2.5 hours duration conducted 2-3 times in a month.\nYou can challenge or hack other contestants’ solutions as well.\nYou can also solve problems from previous contests for learning objectives.\n\nConclusion\n\nThis list was based on a few things: my own experiences using the websites, and some Google searches. I also frequented some forums and subreddits such as r/learnSystemDesign, r/developersIndia to see what websites were usually recommended by the users there. To upskill your coding skills, you can join online courses like Logicmojo, Coding Ninjas or Scaler Academy. These sites can help you to improve your coding skills, learn new techniques and algorithms, and prepare for technical interviews and coding competitions.', 'result': {'fake': 0.9992, 'real': 0.0008}, 'status': 'success'}], 'credits_used': 10, 'credits': 1983741, 'subscription': 0, 'content': 'Solving coding problems is a great method to advance your coding abilities. You may improve your problem-solving skills, master the nuances of programming languages, get ready for job interviews, discover new algorithms, and more by tackling various challenges and puzzles. There are several well-known websites for coding challenges that assist you in doing so by offering various types of tasks that require you to use your mathematical and analytical abilities to answer using programming languages. The top 5 websites for coding challenges are highlighted below –\n\nLeetCode\n\nOne of the biggest tech communities is LeetCode, which has millions of people that are active every day. It provides competitors with a variety of weekly and biweekly programming competitions. Also, it aids in interview preparation, and conversations are available on LeetCode. It offers 90-minute contests where you may use any of the supported programming languages to complete the tasks in their online editor, sometimes known as a playground.\n\nLeetCode is one of the largest tech communities with millions of active users.\nYou can practice over 2300+ coding problems and the number is increasing day by day!\nLeetCode supports over 14 popular coding languages that make it more preferable.\n\nHackerRank\n\nHackerRank is a well-known site for programming competitions where you must complete tasks according to predetermined guidelines. You may complete these programming tasks on HackerRank using any of the many programming languages available, including C, Java, Python, Ruby, etc. In addition, participants can work through issues in a variety of computer science fields, including artificial intelligence, machine learning, and algorithms. By completing tasks on the HackerRank website, you may also earn badges that will be added to your profile. The following is a list of the several contests HackerRank has hosted:\n\n101-Hack – A monthly algorithmic contest in which five challenges have to be solved within 2 hours.\n\nHourRank – The shortest contest format in which 3-4 algorithm challenges need to be solved within 1 hour.\n\nWeek of Code – A weeklong algorithm contest where one new challenge is offered each day. Also, the challenges become more complicated as the day passes.\n\nAd Infinitum – A 48-hour contest of Mathematics conducted every three months.\n\nReal Data/Machine Learning Contests – A weeklong contest focuses on real-world data skills and requires the use of machine learning techniques.\n\nLanguage/Domain Specific Contests – These are the contest based on various programming languages like C, Java, Python, etc.\n\nCompany Contests – The contests sponsored by specific companies that are looking to hire developers. The nature of this contest varies as per the requirements of the sponsoring companies.\n\nWorld CodeSprint – It is a 24-hour contest having 7-8 challenges to be solved.\n\nGeeksForGeeks\n\nEvery month, GeeksForGeeks holds a number of programming competitions through the practice portal, including a number of job-a-thons for freshmen to gain employment prospects at a sizable number of organizations. In addition, several more monthly, weekly, and daily challenges are often presented on websites. It is an individual participation competition. Participants have the chance to be employed by a variety of businesses that choose candidates for interviews based on their own standards. This coding contest is only open to students. The top 100 students have access to free courses as well as a chance to win interesting prizes.\n\nCodeChef\n\nAspiring programmers may test and hone their programming abilities through a variety of online competitions on the competitive programming website CodeChef. Every month, CodeChef has a larger programming competition at the beginning and two smaller contests in the middle and end of the month. You can submit your solution in any of the more than 55 programming languages supported by the competitions, including C, C++, Java, and Python. To make the process of computer programming more approachable, CodeChef also provides a variety of algorithm lessons and forum discussions in addition to these competitions. Gaining points and climbing the ranks of CodeChef is highly worthwhile. There are various coding competitions where you can show your programming skills such as – Monthly Programming Contests, Cook-off and Lunchtime Coding Contests. Some of the major stats regarding CodeChef contests are listed below:\n\nCodeChef has around 1,250,000+ programmers from 12,000 institutions.\nThere are approximately 3200+ programming contests with around 92 million+ submissions.\nThe contests have prizes of around INR 20,000 for Indian Community and $700 for Global Community.\n\nCodeforces\n\nAspiring programmers may test and hone their programming abilities through a variety of online competitions on the competitive programming website CodeChef. Every month, CodeChef has a larger programming competition at the beginning and two smaller contests in the middle and end of the month. You can submit your solution in any of the more than 55 programming languages supported by the competitions, including C, C++, Java, and Python. To make the process of computer programming more approachable, CodeChef also provides a variety of algorithm lessons and forum discussions in addition to these competitions. Gaining points and climbing the ranks of CodeChef is highly worthwhile. The best thing about Codeforces is that the contests are regularly conducted here as every month they organize nearly 6 contests. Also, participation in the contests is free and open to everybody. Codeforces offers various type of coding challenges and features such as –\n\nShort format Contests with a duration of 2 hours.\nEducational Contests of 2-2.5 hours duration conducted 2-3 times in a month.\nYou can challenge or hack other contestants’ solutions as well.\nYou can also solve problems from previous contests for learning objectives.\n\nConclusion\n\nThis list was based on a few things: my own experiences using the websites, and some Google searches. I also frequented some forums and subreddits such as r/learnSystemDesign, r/developersIndia to see what websites were usually recommended by the users there. To upskill your coding skills, you can join online courses like Logicmojo, Coding Ninjas or Scaler Academy. These sites can help you to improve your coding skills, learn new techniques and algorithms, and prepare for technical interviews and coding competitions.', 'aiModelVersion': '1'}",0.06985
Phillip McMullen,Updated 6y,What are your top 3 tips for new programmers?,"Don’t think Googling/Stack Overflowing makes you less of a programmer. We all do it, and I don't think we’ll ever see a time when we won't. No one expects you to know every function/method/variable type/etc. Knowing how to search for answers, however, is a valuable skill.

2. Rather than trying to write code from the start of a project, create your void method, don't define any inputs, and start filling that method with comments showing how your method will flow. Like this:

public void GetDatabaseData() 
{ 
  //establish connection to database 
  //compose query here to get all users from area code 
  //handle any return errors here 
  //handle any null data here 
  //do stuff to the data here 
  //return 
} 

My code got way better once I learned this skill to speed it up and break it into manageable chunks. Then go back and define your return type, inputs, name, etc.

3. Always be willing to learn. The day you think you're done learning is the day you retire or settle for initiating the obsoleting of your relevance in the field. Programming is (fortunately) always evolving and we have to stay on our game to produce great code. Good luck!

**ignore any weird formatting. Typing this on my phone","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/dv509w2y7oiqauc3', 'title': 'What are your top 3 tips for new programmers?', 'score': {'original': 0.9246, 'ai': 0.0754}, 'blocks': [{'text': ""Don’t think Googling/Stack Overflowing makes you less of a programmer. We all do it, and I don't think we’ll ever see a time when we won't. No one expects you to know every function/method/variable type/etc. Knowing how to search for answers, however, is a valuable skill.\n\n2. Rather than trying to write code from the start of a project, create your void method, don't define any inputs, and start filling that method with comments showing how your method will flow. Like this:\n\npublic void GetDatabaseData()\xa0\n{\xa0\n  //establish connection to database\xa0\n  //compose query here to get all users from area code\xa0\n  //handle any return errors here\xa0\n  //handle any null data here\xa0\n  //do stuff to the data here\xa0\n  //return\xa0\n}\xa0\n\nMy code got way better once I learned this skill to speed it up and break it into manageable chunks. Then go back and define your return type, inputs, name, etc.\n\n3. Always be willing to learn. The day you think you're done learning is the day you retire or settle for initiating the obsoleting of your relevance in the field. Programming is (fortunately) always evolving and we have to stay on our game to produce great code. Good luck!\n\n**ignore any weird formatting. Typing this on my phone"", 'result': {'fake': 0.0754, 'real': 0.9246}, 'status': 'success'}], 'credits_used': 3, 'credits': 1983738, 'subscription': 0, 'content': ""Don’t think Googling/Stack Overflowing makes you less of a programmer. We all do it, and I don't think we’ll ever see a time when we won't. No one expects you to know every function/method/variable type/etc. Knowing how to search for answers, however, is a valuable skill.\n\n2. Rather than trying to write code from the start of a project, create your void method, don't define any inputs, and start filling that method with comments showing how your method will flow. Like this:\n\npublic void GetDatabaseData()\xa0\n{\xa0\n  //establish connection to database\xa0\n  //compose query here to get all users from area code\xa0\n  //handle any return errors here\xa0\n  //handle any null data here\xa0\n  //do stuff to the data here\xa0\n  //return\xa0\n}\xa0\n\nMy code got way better once I learned this skill to speed it up and break it into manageable chunks. Then go back and define your return type, inputs, name, etc.\n\n3. Always be willing to learn. The day you think you're done learning is the day you retire or settle for initiating the obsoleting of your relevance in the field. Programming is (fortunately) always evolving and we have to stay on our game to produce great code. Good luck!\n\n**ignore any weird formatting. Typing this on my phone"", 'aiModelVersion': '1'}",0.9246
Steven Abell,Updated 3y,How complicated is the code that controls a calculator?,"NOTE: This is about a calculator’s internal code, not its user-level programming.

I wrote that stuff for HP forty years ago.

First, there is the CPU. It is like nothing you have ever seen. Its architecture will make your head turn inside out and bleed on the floor. Calculator processors do decimal arithmetic in four-bit chunks, which affects the programming model in perverse ways. They are designed to run as long as possible on batteries, which also affects the programming model in perverse ways. And the code has to fit into tiny ROMs. No coding trick is too obscene if it makes the code smaller. The code was all in a bizarre assembly language for this weird CPU. When I was doing this, it took a new software engineer about a year to get good enough at programming these things to write production code.

The usual handheld calculator does floating-point arithmetic in software. This on a CPU that does not know how to multiply or divide, much less deliver transcendental functions. There is some really high-powered math behind this stuff. One of the best examples of this is the i-function, which calculates interest rates on a financial calculator. There is no closed-form solution for this, and the numerical techniques you learn in upper-division classes in college are often powerless to solve it. Last I heard, most calculator manufacturers still haven’t figured out how to do the i-function right. And once the software is written, it is subjected to exhaustive automated testing, 24 hours a day, for years.

My product was the HP-71 handheld computer. When it was released in 1984, it was more powerful than many desktop computers of that era. Try writing an operating system on a floating point processor.

It probably seems to most people that there can’t be much to calculator software. I have been all over Silicon Valley for the last four decades, written lots of code for many different kinds of products. Writing calculator software is by far the hardest thing I have ever done.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/y8hcp92a4vf0jt1z', 'title': 'How complicated is the code that controls a calculator?', 'score': {'original': 0.9984, 'ai': 0.0016}, 'blocks': [{'text': 'NOTE: This is about a calculator’s internal code, not its user-level programming.\n\nI wrote that stuff for HP forty years ago.\n\nFirst, there is the CPU. It is like nothing you have ever seen. Its architecture will make your head turn inside out and bleed on the floor. Calculator processors do decimal arithmetic in four-bit chunks, which affects the programming model in perverse ways. They are designed to run as long as possible on batteries, which also affects the programming model in perverse ways. And the code has to fit into tiny ROMs. No coding trick is too obscene if it makes the code smaller. The code was all in a bizarre assembly language for this weird CPU. When I was doing this, it took a new software engineer about a year to get good enough at programming these things to write production code.\n\nThe usual handheld calculator does floating-point arithmetic in software. This on a CPU that does not know how to multiply or divide, much less deliver transcendental functions. There is some really high-powered math behind this stuff. One of the best examples of this is the i-function, which calculates interest rates on a financial calculator. There is no closed-form solution for this, and the numerical techniques you learn in upper-division classes in college are often powerless to solve it. Last I heard, most calculator manufacturers still haven’t figured out how to do the i-function right. And once the software is written, it is subjected to exhaustive automated testing, 24 hours a day, for years.\n\nMy product was the HP-71 handheld computer. When it was released in 1984, it was more powerful than many desktop computers of that era. Try writing an operating system on a floating point processor.\n\nIt probably seems to most people that there can’t be much to calculator software. I have been all over Silicon Valley for the last four decades, written lots of code for many different kinds of products. Writing calculator software is by far the hardest thing I have ever done.', 'result': {'fake': 0.0016, 'real': 0.9984}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983734, 'subscription': 0, 'content': 'NOTE: This is about a calculator’s internal code, not its user-level programming.\n\nI wrote that stuff for HP forty years ago.\n\nFirst, there is the CPU. It is like nothing you have ever seen. Its architecture will make your head turn inside out and bleed on the floor. Calculator processors do decimal arithmetic in four-bit chunks, which affects the programming model in perverse ways. They are designed to run as long as possible on batteries, which also affects the programming model in perverse ways. And the code has to fit into tiny ROMs. No coding trick is too obscene if it makes the code smaller. The code was all in a bizarre assembly language for this weird CPU. When I was doing this, it took a new software engineer about a year to get good enough at programming these things to write production code.\n\nThe usual handheld calculator does floating-point arithmetic in software. This on a CPU that does not know how to multiply or divide, much less deliver transcendental functions. There is some really high-powered math behind this stuff. One of the best examples of this is the i-function, which calculates interest rates on a financial calculator. There is no closed-form solution for this, and the numerical techniques you learn in upper-division classes in college are often powerless to solve it. Last I heard, most calculator manufacturers still haven’t figured out how to do the i-function right. And once the software is written, it is subjected to exhaustive automated testing, 24 hours a day, for years.\n\nMy product was the HP-71 handheld computer. When it was released in 1984, it was more powerful than many desktop computers of that era. Try writing an operating system on a floating point processor.\n\nIt probably seems to most people that there can’t be much to calculator software. I have been all over Silicon Valley for the last four decades, written lots of code for many different kinds of products. Writing calculator software is by far the hardest thing I have ever done.', 'aiModelVersion': '1'}",0.9984
Bhaumik Patel,Updated 7y,How can I become a world-class coder in under three years?,"I don't have technical advice for you but there's a quote that I read whenever I need some extra inspiration. Chris Hadfield, an astronaut who was literally orbiting the Earth at the time, did an AMA [Ask me anything] thread on Reddit. Someone asked him for advice on the field and I think his answer can apply to ANY career goal.

{Background first}

I found this advice at a very important moment in my life. I had spent my whole life through college thinking I was going to be a doctor. My parents had made that promise to my entire extended family. I wanted to switch into programming but felt like it was too late. I figured that I had wasted too much time, money, and mental energy already so I might as well finish it up.

Horrible advice.

I needed to find a different career path. Programming came to me suddenly after watching Alexis Ohanain (co-founder of Reddit) speak at UVa. He had a few eye-opening things to say about entrepreneurship and the tech scene. What specifically stuck out was his line ""50-100 years ago, you needed a factory and hundreds of employees to start a company. Now, you just need a laptop."" He also pointed to the library where they had actually registered the domain for reddit.com
 a few years earlier. That hour changed me. After I started dabbling with a little Codecademy, I found Thinkful
 - a new edtech startup that matched you up with a personal mentor to guide your journey. A few weeks into the course, I had hit the beginner's wall, was bummed about my recent performance and questioned this crazy life decision.

But then, I read Chris Hadfield's response to ""Any advice to a young person who wants to get into this field?""


Decide in your heart of hearts what really excites and challenges you, and start moving your life in that direction. Every decision you make, from what you eat to what you do with your time tonight, turns you into who you are tomorrow, and the day after that. Look at who you want to be, and start sculpting yourself into that person. You may not get exactly where you thought you'd be, but you will be doing things that suit you in a profession you believe in. Don't let life randomly kick you into the adult you don't want to become.


That changed me. I'm now driven more than ever to thrive in tech. Maybe I'll start my own company some day :)

[3 year update!] After learning to code with Thinkful's frontend course, I applied to join the school and now help our Web Development Career Path
 students land full-time programming jobs! They're not ""world-class coders"" yet but certainly well on their way. The circle has closed :)

If you're interested in that course or just need general career advice about learning to code, advancing your existing skill set, or getting into tech/startups in a non-technical role, feel free shoot an email to bhaumik@thinkful.com
. I absolutely helping out people in the midst of a career transition. (You can also DM me here but expect faster responses over email).

p.s. Someone* saw the post and turned it into a comic :)

* ""That someone is named Gavin Aung and runs a super cool blog making comics out of famous quotes called http://zenpencils.com
"" - User in the comments","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/mew4sjar8d0lb1gp', 'title': 'How can I become a world-class coder in under three years?', 'score': {'original': 0.81975, 'ai': 0.18025}, 'blocks': [{'text': 'I don\'t have technical advice for you but there\'s a quote that I read whenever I need some extra inspiration. Chris Hadfield, an astronaut who was literally orbiting the Earth at the time, did an AMA [Ask me anything] thread on Reddit. Someone asked him for advice on the field and I think his answer can apply to ANY career goal.\n\n{Background first}\n\nI found this advice at a very important moment in my life. I had spent my whole life through college thinking I was going to be a doctor. My parents had made that promise to my entire extended family. I wanted to switch into programming but felt like it was too late. I figured that I had wasted too much time, money, and mental energy already so I might as well finish it up.\n\nHorrible advice.\n\nI needed to find a different career path. Programming came to me suddenly after watching Alexis Ohanain (co-founder of Reddit) speak at UVa. He had a few eye-opening things to say about entrepreneurship and the tech scene. What specifically stuck out was his line ""50-100 years ago, you needed a factory and hundreds of employees to start a company. Now, you just need a laptop."" He also pointed to the library where they had actually registered the domain for reddit.com\n a few years earlier. That hour changed me. After I started dabbling with a little Codecademy, I found Thinkful\n - a new edtech startup that matched you up with a personal mentor to guide your journey. A few weeks into the course, I had hit the beginner\'s wall, was bummed about my recent performance and questioned this crazy life decision.\n\nBut then, I read Chris Hadfield\'s response to ""Any advice to a young person who wants to get into this field?""\n\n\nDecide in your heart of hearts what really excites and challenges you, and start moving your life in that direction. Every decision you make, from what you eat to what you do with your time tonight, turns you into who you are tomorrow, and the day after that. Look at who you want to be, and start sculpting yourself into that person. You may not get exactly where you thought you\'d be, but you will be doing things that suit you in a profession you believe in. Don\'t let life randomly kick you into the adult you don\'t want to become.\n\n\nThat changed me. I\'m now driven more than ever to thrive in tech. Maybe I\'ll start my own company some day :)\n\n[3 year update!] After learning to code with Thinkful\'s frontend course, I applied to join the school and now help our Web Development Career Path\n students land full-time programming jobs! They\'re not ""world-class coders"" yet but certainly well on their way. The circle has closed :)\n\nIf you\'re interested in that course or just need general career advice about learning to code, advancing your existing skill set, or getting into tech/startups in a non-technical role, feel free shoot an email to bhaumik@thinkful.com\n. I absolutely helping out people in the midst of a career transition. (You can also DM', 'result': {'fake': 0.2264, 'real': 0.7736}, 'status': 'success'}, {'text': 'me here but expect faster responses over email).\n\np.s. Someone* saw the post and turned it into a comic :)\n\n* ""That someone is named Gavin Aung and runs a super cool blog making comics out of famous quotes called http://zenpencils.com\n"" - User in the comments', 'result': {'fake': 0.0543, 'real': 0.9457}, 'status': 'success'}], 'credits_used': 6, 'credits': 1983728, 'subscription': 0, 'content': 'I don\'t have technical advice for you but there\'s a quote that I read whenever I need some extra inspiration. Chris Hadfield, an astronaut who was literally orbiting the Earth at the time, did an AMA [Ask me anything] thread on Reddit. Someone asked him for advice on the field and I think his answer can apply to ANY career goal.\n\n{Background first}\n\nI found this advice at a very important moment in my life. I had spent my whole life through college thinking I was going to be a doctor. My parents had made that promise to my entire extended family. I wanted to switch into programming but felt like it was too late. I figured that I had wasted too much time, money, and mental energy already so I might as well finish it up.\n\nHorrible advice.\n\nI needed to find a different career path. Programming came to me suddenly after watching Alexis Ohanain (co-founder of Reddit) speak at UVa. He had a few eye-opening things to say about entrepreneurship and the tech scene. What specifically stuck out was his line ""50-100 years ago, you needed a factory and hundreds of employees to start a company. Now, you just need a laptop."" He also pointed to the library where they had actually registered the domain for reddit.com\n a few years earlier. That hour changed me. After I started dabbling with a little Codecademy, I found Thinkful\n - a new edtech startup that matched you up with a personal mentor to guide your journey. A few weeks into the course, I had hit the beginner\'s wall, was bummed about my recent performance and questioned this crazy life decision.\n\nBut then, I read Chris Hadfield\'s response to ""Any advice to a young person who wants to get into this field?""\n\n\nDecide in your heart of hearts what really excites and challenges you, and start moving your life in that direction. Every decision you make, from what you eat to what you do with your time tonight, turns you into who you are tomorrow, and the day after that. Look at who you want to be, and start sculpting yourself into that person. You may not get exactly where you thought you\'d be, but you will be doing things that suit you in a profession you believe in. Don\'t let life randomly kick you into the adult you don\'t want to become.\n\n\nThat changed me. I\'m now driven more than ever to thrive in tech. Maybe I\'ll start my own company some day :)\n\n[3 year update!] After learning to code with Thinkful\'s frontend course, I applied to join the school and now help our Web Development Career Path\n students land full-time programming jobs! They\'re not ""world-class coders"" yet but certainly well on their way. The circle has closed :)\n\nIf you\'re interested in that course or just need general career advice about learning to code, advancing your existing skill set, or getting into tech/startups in a non-technical role, feel free shoot an email to bhaumik@thinkful.com\n. I absolutely helping out people in the midst of a career transition. (You can also DM me here but expect faster responses over email).\n\np.s. Someone* saw the post and turned it into a comic :)\n\n* ""That someone is named Gavin Aung and runs a super cool blog making comics out of famous quotes called http://zenpencils.com\n"" - User in the comments', 'aiModelVersion': '1'}",0.81975
Joe Zbiciak,1y,Why isn't my c++ code working?,"OK, this is OP's code, reformatted for readability.

OP didn't say what isn't working. I'm just going to point out what I see.

/*   
identifier comments here for Assignment 1  
see Canvas for the application details  
*/  
#include <iostream>  
#include <iomanip> 
    
using namespace std;  
    
// Complete your software 
// inside the main function. 
    
int main() {  
  string var, var1;  
  float pounds, kilograms, 
        foot, inches, cm, 
        fahrenheit, celsius;  
  int i=1;  
    
  while (i=1000000000) {  
    cout 
      << ""Welcome to Ethan's "" 
         ""weights and measures "" 
         ""converter."" 
      << endl;  
    cout 
      << ""Would you like to "" 
         ""convert using imperial "" 
         ""or metric? Choose I "" 
         ""or M: "" 
      << endl;  
   
    cin >> var;  
     
    if (var == ""M"") {  
      cout 
        << ""Converting from Metric!"" 
        << endl << endl;  
      cout 
        << ""Would you like to "" 
           ""convert Height, "" 
           ""Temperature, or "" 
           ""Weight? Please choose "" 
           ""H, T, or W: "" 
        << endl; 
    
      cin >> var;  
    
      if (var == ""H"") {  
        cout 
          << ""Converting from "" 
             ""centimetres to feet "" 
             ""and inches!"" 
          << endl;  
        cout 
          << ""Enter centimetres: "" 
          << endl;  
    
        cin >> cm;  
    
        inches = cm / 2.54;  
        foot = inches / 12;  
     
        cout 
          << ""That is equivalent to "" 
          << inches << "" inches"" 
          << endl;  
        cout 
          << ""That is equivalent to"" 
          << foot << "" feet"" 
          << endl;  
        return 0;  
      } 
     
      if (var == ""T"") {  
        cout  
          << ""Converting from "" 
             ""Celsius to "" 
             ""Fahrenheit!"" 
          << endl;  
        cout 
          << ""Enter Celsius: "" 
          << endl; 
     
        cin >> celsius; 
     
        fahrenheit = 
          (celsius * 9.0) / 5.0 + 32; 
    
        cout 
          << ""That is equivalent "" 
             ""to "" << fahrenheit 
          << "" fahrenheit"" 
          << endl; 
    
        return 0;  
      } 
    
      if (var == ""W"") {  
        cout 
          << ""Converting from "" 
             ""Kilograms to Pounds!"" 
          << endl;  
        cout 
          << ""Enter kilograms: "" 
          << endl; 
    
        cin >> kilograms;  
    
        pounds = kilograms * 2.21;  
        cout 
          << ""That is equivalent to "" 
          << pounds << "" pounds"" 
          << endl; 
      
        return 0;  
      }  
     
      return 0;  
    } 
     
    if (var == ""I"") {  
      cout 
        << ""Converting from Imperial!"" 
        << endl; 
      cout 
        << ""Would you like to "" 
           ""convert Height, "" 
           ""Temperature, or "" 
           ""Weight? Please choose "" 
           ""H, T, or W: "" 
        << endl; 
     
      cin >> var;  
      
      if (var == ""H"") {  
        cout 
          << ""Converting from "" 
             ""feet and inches to "" 
             ""centimetres!"" 
          << endl;  
        cout 
          << ""Enter feet and inches: "" 
          << endl;  
     
        cin >> foot, inches;  
     
        inches = cm / 2.54;  
        foot = inches / 12;  
        cm = foot / (2.54 * 12);  
     
        cout 
          << ""That is equivalent to "" 
          << cm << "" centimetres"" 
          << endl;  
     
        return 0;  
      }  
       
      if (var == ""T"") {  
        cout 
          << ""Converting from "" 
             ""Fahrenheit to Celsius!"" 
          << endl;  
        cout 
          << ""Enter Fahrenheit: "" 
          << endl; 
     
        cin >> fahrenheit;  
     
        celsius = 
          (fahrenheit - 32)*(5/9);  
     
        cout  
          << ""That is equivalent to "" 
          << celsius << "" celsius"" 
          << endl;  
     
        return 0;  
      } 
      
      if (var == ""W"") {  
        cout 
          << ""Converting from Pounds "" 
             ""to Kilograms!"" 
          << endl;  
        cout 
          << ""Enter Pounds: "" 
          << endl;  
     
        cin >> pounds;  
     
        kilograms = pounds * 0.454;  
     
        cout 
          << ""That is equivalent to "" 
          << kilograms << "" Kilograms"" 
          << endl;  
    
        return 0;  
      }  
    
      return 0;  
    }  
  }  
     
  return 0;  
    
  cout 
    << ""Would you like to perform "" 
       ""another conversion? (Y/N): "";  
   
  cin >> var;  
   
  bool run = true;  
  if (var == ""Y"") {  
    true;  
    cout 
      << ""Thank you for using "" 
         ""my converter."";  
  }  
  else if (var == ""N"") {  
    false;  
    cout 
      << ""Thank you for using "" 
         ""my converter."";  
  }  
} 

OK, let's see:

Insert the standard grumbles about using namespace std.
I understand you're a student, and it's fine for homework.
Just understand that many C++ shops aren't fans of it in production code.
This statement performs an assignment, not a comparison: while (i=1000000000).
That seems to be intentional.
It's a goofy way of writing while (1) or while (true).
Weird flex, but OK.
Usually, when folks translate to feet and inches, they want something like 254 cm converted into 8 feet, 4 inches.
Your program will print out something like 100 inches, 8.333333 feet, which isn't so useful.
If you need the X feet, Y inches, I recommend truncating foot to an integer, and subtracting 12 times that from your number of inches.
Also, consider renaming foot to feet.
What's with all these return 0 statements?
Every single conversion exits the program immediately after.
If you give an unexpected input to one of the second-level menu prompts, it exits the program.
Your infinite while loop only gets to iterate if you enter an incorrect input to the top level menu prompt.
Feet and inches to centimeters looks badly broken:
 cin >> foot, inches;  
     
 inches = cm / 2.54;  
 foot = inches / 12;  
 cm = foot / (2.54 * 12);  
The comma doesn't do what you want.
You need a >> there instead.
With the comma, you have two unrelated expressions that may as well have been separated by a semicolon: cin >> feet;  inches;
Therefore what you wrote will read one value into foot and nothing into inches.
You're not doing anything with the value you read into foot.
You're overwriting it with a value converted from inches.
inches wasn't initialized by cin, for reasons mentioned above.
Instead, you're converting the uninitialized value in cm to inches.
cm is what you're meant to convert to, and in fact you close that ouroboros a couple lines later.
If I told you something was 14m 33cm, how would you go about converting that to a single millimeter measurement? Or converting 3 hours, 45 minutes into seconds. Apply that thought process here.
Your conversion Fahrenheit to Celsius always outputs zero.
The expression (5/9) is integer division.
Take a closer look at your Celsius to Fahrenheit conversion and try to understand how they differ.
On line 207 (in my reformatted version above), you exit the program before you ask whether the user wants to perform another conversion.
Or, at least you would if you could reach this line, but you can't, because it's outside your while loop.
The while loop iterates “forever,” unless you manage to input a correct entry at the top level menu.
Lines 217 and 224 (true; and false;) would do absolutely nothing if they could be reached.
It seems like all the code after line 207 was meant to be inside the while loop, but it isn't. Right now it's dead code.

There may be other errors, but that's what I spotted with a quick glance through.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/2i3uc8saydvpmf6e', 'title': ""Why isn't my c++ code working?"", 'score': {'original': 0.29806666666667, 'ai': 0.70193333333333}, 'blocks': [{'text': 'OK, this is OP\'s code, reformatted for readability.\n\nOP didn\'t say what isn\'t working. I\'m just going to point out what I see.\n\n/*  \xa0\nidentifier comments here for Assignment 1 \xa0\nsee Canvas for the application details \xa0\n*/ \xa0\n#include <iostream> \xa0\n#include <iomanip>\xa0\n   \xa0\nusing namespace std; \xa0\n   \xa0\n// Complete your software\xa0\n// inside the main function.\xa0\n   \xa0\nint main() { \xa0\n  string var, var1; \xa0\n  float pounds, kilograms,\xa0\n        foot, inches, cm,\xa0\n        fahrenheit, celsius; \xa0\n  int i=1; \xa0\n   \xa0\n  while (i=1000000000) { \xa0\n    cout\xa0\n      << ""Welcome to Ethan\'s ""\xa0\n         ""weights and measures ""\xa0\n         ""converter.""\xa0\n      << endl; \xa0\n    cout\xa0\n      << ""Would you like to ""\xa0\n         ""convert using imperial ""\xa0\n         ""or metric? Choose I ""\xa0\n         ""or M: ""\xa0\n      << endl; \xa0\n  \xa0\n    cin >> var; \xa0\n    \xa0\n    if (var == ""M"") { \xa0\n      cout\xa0\n        << ""Converting from Metric!""\xa0\n        << endl << endl; \xa0\n      cout\xa0\n        << ""Would you like to ""\xa0\n           ""convert Height, ""\xa0\n           ""Temperature, or ""\xa0\n           ""Weight? Please choose ""\xa0\n           ""H, T, or W: ""\xa0\n        << endl;\xa0\n   \xa0\n      cin >> var; \xa0\n   \xa0\n      if (var == ""H"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""centimetres to feet ""\xa0\n             ""and inches!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter centimetres: ""\xa0\n          << endl; \xa0\n   \xa0\n        cin >> cm; \xa0\n   \xa0\n        inches = cm / 2.54; \xa0\n        foot = inches / 12; \xa0\n    \xa0\n    ', 'result': {'fake': 0.9732, 'real': 0.0268}, 'status': 'success'}, {'text': '   cout\xa0\n          << ""That is equivalent to ""\xa0\n          << inches << "" inches""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""That is equivalent to""\xa0\n          << foot << "" feet""\xa0\n          << endl; \xa0\n        return 0; \xa0\n      }\xa0\n    \xa0\n      if (var == ""T"") { \xa0\n        cout \xa0\n          << ""Converting from ""\xa0\n             ""Celsius to ""\xa0\n             ""Fahrenheit!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter Celsius: ""\xa0\n          << endl;\xa0\n    \xa0\n        cin >> celsius;\xa0\n    \xa0\n        fahrenheit =\xa0\n          (celsius * 9.0) / 5.0 + 32;\xa0\n   \xa0\n        cout\xa0\n          << ""That is equivalent ""\xa0\n             ""to "" << fahrenheit\xa0\n          << "" fahrenheit""\xa0\n          << endl;\xa0\n   \xa0\n        return 0; \xa0\n      }\xa0\n   \xa0\n      if (var == ""W"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""Kilograms to Pounds!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter kilograms: ""\xa0\n          << endl;\xa0\n   \xa0\n        cin >> kilograms; \xa0\n   \xa0\n        pounds = kilograms * 2.21; \xa0\n        cout\xa0\n          << ""That is equivalent to ""\xa0\n          << pounds << "" pounds""\xa0\n       ', 'result': {'fake': 0.9999, 'real': 0.0001}, 'status': 'success'}, {'text': '  << endl;\xa0\n     \xa0\n        return 0; \xa0\n      } \xa0\n    \xa0\n      return 0; \xa0\n    }\xa0\n    \xa0\n    if (var == ""I"") { \xa0\n      cout\xa0\n        << ""Converting from Imperial!""\xa0\n        << endl;\xa0\n      cout\xa0\n        << ""Would you like to ""\xa0\n           ""convert Height, ""\xa0\n           ""Temperature, or ""\xa0\n           ""Weight? Please choose ""\xa0\n           ""H, T, or W: ""\xa0\n        << endl;\xa0\n    \xa0\n      cin >> var; \xa0\n     \xa0\n      if (var == ""H"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""feet and inches to ""\xa0\n             ""centimetres!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter feet and inches: ""\xa0\n          << endl; \xa0\n    \xa0\n        cin >> foot, inches; \xa0\n    \xa0\n        inches = cm / 2.54; \xa0\n        foot = inches / 12; \xa0\n        cm = foot / (2.54 * 12); \xa0\n    \xa0\n        cout\xa0\n          << ""That is equivalent to ""\xa0\n          << cm << "" centimetres""\xa0\n          << endl; \xa0\n    \xa0\n        return 0; \xa0\n      } \xa0\n      \xa0\n      if (var == ""T"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""Fahrenheit to Celsius!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter Fahrenheit: ""\xa0\n', 'result': {'fake': 0.8829, 'real': 0.1171}, 'status': 'success'}, {'text': '         << endl;\xa0\n    \xa0\n        cin >> fahrenheit; \xa0\n    \xa0\n        celsius =\xa0\n          (fahrenheit - 32)*(5/9); \xa0\n    \xa0\n        cout \xa0\n          << ""That is equivalent to ""\xa0\n          << celsius << "" celsius""\xa0\n          << endl; \xa0\n    \xa0\n        return 0; \xa0\n      }\xa0\n     \xa0\n      if (var == ""W"") { \xa0\n        cout\xa0\n          << ""Converting from Pounds ""\xa0\n             ""to Kilograms!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter Pounds: ""\xa0\n          << endl; \xa0\n    \xa0\n        cin >> pounds; \xa0\n    \xa0\n        kilograms = pounds * 0.454; \xa0\n    \xa0\n        cout\xa0\n          << ""That is equivalent to ""\xa0\n          << kilograms << "" Kilograms""\xa0\n          << endl; \xa0\n   \xa0\n        return 0; \xa0\n      } \xa0\n   \xa0\n      return 0; \xa0\n    } \xa0\n  } \xa0\n    \xa0\n  return 0; \xa0\n   \xa0\n  cout\xa0\n    << ""Would you like to perform ""\xa0\n       ""another conversion? (Y/N): ""; \xa0\n  \xa0\n  cin >> var; \xa0\n  \xa0\n  bool run = true; \xa0\n  if (var == ""Y"") { \xa0\n    true; \xa0\n    cout\xa0\n      << ""Thank you for using ""\xa0\n         ""my converter.""; \xa0\n  } \xa0\n  else if (var == ""N"") { \xa0\n    false; \xa0\n    cout\xa0\n      << ""Thank you for using ""\xa0\n         ""my converter.""; \xa0\n  } \xa0\n}\xa0\n\nOK, let\'s see:\n\nInsert the standard grumbles about using namespace std.\nI understand you\'re a student, and it\'s fine for homework.\nJust understand that many C++ shops aren\'t fans of it in production code.\nThis statement performs an', 'result': {'fake': 0.9602, 'real': 0.0398}, 'status': 'success'}, {'text': ""assignment, not a comparison: while (i=1000000000).\nThat seems to be intentional.\nIt's a goofy way of writing while (1) or while (true).\nWeird flex, but OK.\nUsually, when folks translate to feet and inches, they want something like 254 cm converted into 8 feet, 4 inches.\nYour program will print out something like 100 inches, 8.333333 feet, which isn't so useful.\nIf you need the X feet, Y inches, I recommend truncating foot to an integer, and subtracting 12 times that from your number of inches.\nAlso, consider renaming foot to feet.\nWhat's with all these return 0 statements?\nEvery single conversion exits the program immediately after.\nIf you give an unexpected input to one of the second-level menu prompts, it exits the program.\nYour infinite while loop only gets to iterate if you enter an incorrect input to the top level menu prompt.\nFeet and inches to centimeters looks badly broken:\n cin >> foot, inches; \xa0\n    \xa0\n inches = cm / 2.54; \xa0\n foot = inches / 12; \xa0\n cm = foot / (2.54 * 12); \xa0\nThe comma doesn't do what you want.\nYou need a >> there instead.\nWith the comma, you have two unrelated expressions that may as well have been separated by a semicolon: cin >> feet;  inches;\nTherefore what you wrote will read one value into foot and nothing into inches.\nYou're not doing anything with the value you read into foot.\nYou're overwriting it with a value converted from inches.\ninches wasn't initialized by cin, for reasons mentioned above.\nInstead, you're converting the uninitialized value in cm to inches.\ncm is what you're meant to convert to, and in fact you close that ouroboros a couple lines later.\nIf I told you something was 14m 33cm, how would you go about converting that to a single millimeter measurement? Or converting 3 hours, 45 minutes into seconds. Apply that thought process here.\nYour conversion Fahrenheit to Celsius always outputs zero.\nThe expression (5/9) is integer division.\nTake a closer look at your Celsius to Fahrenheit conversion and try to understand how they differ.\nOn line 207 (in my reformatted version above), you exit the program before you ask whether the user wants to perform another conversion.\nOr, at least you would if you could reach this line, but you can't, because it's outside your while loop.\nThe while loop iterates “forever,” unless you manage to input a correct entry at the top level menu.\nLines 217 and 224 (true; and false;) would do absolutely nothing if they could be reached.\nIt seems like all the code after line 207 was meant to be inside the while loop, but it isn't. Right now it's dead code.\n\nThere may be other errors, but that's what I spotted with a quick glance through."", 'result': {'fake': 0.4186, 'real': 0.5814}, 'status': 'success'}], 'credits_used': 9, 'credits': 1983719, 'subscription': 0, 'content': 'OK, this is OP\'s code, reformatted for readability.\n\nOP didn\'t say what isn\'t working. I\'m just going to point out what I see.\n\n/*  \xa0\nidentifier comments here for Assignment 1 \xa0\nsee Canvas for the application details \xa0\n*/ \xa0\n#include <iostream> \xa0\n#include <iomanip>\xa0\n   \xa0\nusing namespace std; \xa0\n   \xa0\n// Complete your software\xa0\n// inside the main function.\xa0\n   \xa0\nint main() { \xa0\n  string var, var1; \xa0\n  float pounds, kilograms,\xa0\n        foot, inches, cm,\xa0\n        fahrenheit, celsius; \xa0\n  int i=1; \xa0\n   \xa0\n  while (i=1000000000) { \xa0\n    cout\xa0\n      << ""Welcome to Ethan\'s ""\xa0\n         ""weights and measures ""\xa0\n         ""converter.""\xa0\n      << endl; \xa0\n    cout\xa0\n      << ""Would you like to ""\xa0\n         ""convert using imperial ""\xa0\n         ""or metric? Choose I ""\xa0\n         ""or M: ""\xa0\n      << endl; \xa0\n  \xa0\n    cin >> var; \xa0\n    \xa0\n    if (var == ""M"") { \xa0\n      cout\xa0\n        << ""Converting from Metric!""\xa0\n        << endl << endl; \xa0\n      cout\xa0\n        << ""Would you like to ""\xa0\n           ""convert Height, ""\xa0\n           ""Temperature, or ""\xa0\n           ""Weight? Please choose ""\xa0\n           ""H, T, or W: ""\xa0\n        << endl;\xa0\n   \xa0\n      cin >> var; \xa0\n   \xa0\n      if (var == ""H"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""centimetres to feet ""\xa0\n             ""and inches!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter centimetres: ""\xa0\n          << endl; \xa0\n   \xa0\n        cin >> cm; \xa0\n   \xa0\n        inches = cm / 2.54; \xa0\n        foot = inches / 12; \xa0\n    \xa0\n        cout\xa0\n          << ""That is equivalent to ""\xa0\n          << inches << "" inches""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""That is equivalent to""\xa0\n          << foot << "" feet""\xa0\n          << endl; \xa0\n        return 0; \xa0\n      }\xa0\n    \xa0\n      if (var == ""T"") { \xa0\n        cout \xa0\n          << ""Converting from ""\xa0\n             ""Celsius to ""\xa0\n             ""Fahrenheit!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter Celsius: ""\xa0\n          << endl;\xa0\n    \xa0\n        cin >> celsius;\xa0\n    \xa0\n        fahrenheit =\xa0\n          (celsius * 9.0) / 5.0 + 32;\xa0\n   \xa0\n        cout\xa0\n          << ""That is equivalent ""\xa0\n             ""to "" << fahrenheit\xa0\n          << "" fahrenheit""\xa0\n          << endl;\xa0\n   \xa0\n        return 0; \xa0\n      }\xa0\n   \xa0\n      if (var == ""W"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""Kilograms to Pounds!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter kilograms: ""\xa0\n          << endl;\xa0\n   \xa0\n        cin >> kilograms; \xa0\n   \xa0\n        pounds = kilograms * 2.21; \xa0\n        cout\xa0\n          << ""That is equivalent to ""\xa0\n          << pounds << "" pounds""\xa0\n          << endl;\xa0\n     \xa0\n        return 0; \xa0\n      } \xa0\n    \xa0\n      return 0; \xa0\n    }\xa0\n    \xa0\n    if (var == ""I"") { \xa0\n      cout\xa0\n        << ""Converting from Imperial!""\xa0\n        << endl;\xa0\n      cout\xa0\n        << ""Would you like to ""\xa0\n           ""convert Height, ""\xa0\n           ""Temperature, or ""\xa0\n           ""Weight? Please choose ""\xa0\n           ""H, T, or W: ""\xa0\n        << endl;\xa0\n    \xa0\n      cin >> var; \xa0\n     \xa0\n      if (var == ""H"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""feet and inches to ""\xa0\n             ""centimetres!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter feet and inches: ""\xa0\n          << endl; \xa0\n    \xa0\n        cin >> foot, inches; \xa0\n    \xa0\n        inches = cm / 2.54; \xa0\n        foot = inches / 12; \xa0\n        cm = foot / (2.54 * 12); \xa0\n    \xa0\n        cout\xa0\n          << ""That is equivalent to ""\xa0\n          << cm << "" centimetres""\xa0\n          << endl; \xa0\n    \xa0\n        return 0; \xa0\n      } \xa0\n      \xa0\n      if (var == ""T"") { \xa0\n        cout\xa0\n          << ""Converting from ""\xa0\n             ""Fahrenheit to Celsius!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter Fahrenheit: ""\xa0\n          << endl;\xa0\n    \xa0\n        cin >> fahrenheit; \xa0\n    \xa0\n        celsius =\xa0\n          (fahrenheit - 32)*(5/9); \xa0\n    \xa0\n        cout \xa0\n          << ""That is equivalent to ""\xa0\n          << celsius << "" celsius""\xa0\n          << endl; \xa0\n    \xa0\n        return 0; \xa0\n      }\xa0\n     \xa0\n      if (var == ""W"") { \xa0\n        cout\xa0\n          << ""Converting from Pounds ""\xa0\n             ""to Kilograms!""\xa0\n          << endl; \xa0\n        cout\xa0\n          << ""Enter Pounds: ""\xa0\n          << endl; \xa0\n    \xa0\n        cin >> pounds; \xa0\n    \xa0\n        kilograms = pounds * 0.454; \xa0\n    \xa0\n        cout\xa0\n          << ""That is equivalent to ""\xa0\n          << kilograms << "" Kilograms""\xa0\n          << endl; \xa0\n   \xa0\n        return 0; \xa0\n      } \xa0\n   \xa0\n      return 0; \xa0\n    } \xa0\n  } \xa0\n    \xa0\n  return 0; \xa0\n   \xa0\n  cout\xa0\n    << ""Would you like to perform ""\xa0\n       ""another conversion? (Y/N): ""; \xa0\n  \xa0\n  cin >> var; \xa0\n  \xa0\n  bool run = true; \xa0\n  if (var == ""Y"") { \xa0\n    true; \xa0\n    cout\xa0\n      << ""Thank you for using ""\xa0\n         ""my converter.""; \xa0\n  } \xa0\n  else if (var == ""N"") { \xa0\n    false; \xa0\n    cout\xa0\n      << ""Thank you for using ""\xa0\n         ""my converter.""; \xa0\n  } \xa0\n}\xa0\n\nOK, let\'s see:\n\nInsert the standard grumbles about using namespace std.\nI understand you\'re a student, and it\'s fine for homework.\nJust understand that many C++ shops aren\'t fans of it in production code.\nThis statement performs an assignment, not a comparison: while (i=1000000000).\nThat seems to be intentional.\nIt\'s a goofy way of writing while (1) or while (true).\nWeird flex, but OK.\nUsually, when folks translate to feet and inches, they want something like 254 cm converted into 8 feet, 4 inches.\nYour program will print out something like 100 inches, 8.333333 feet, which isn\'t so useful.\nIf you need the X feet, Y inches, I recommend truncating foot to an integer, and subtracting 12 times that from your number of inches.\nAlso, consider renaming foot to feet.\nWhat\'s with all these return 0 statements?\nEvery single conversion exits the program immediately after.\nIf you give an unexpected input to one of the second-level menu prompts, it exits the program.\nYour infinite while loop only gets to iterate if you enter an incorrect input to the top level menu prompt.\nFeet and inches to centimeters looks badly broken:\n cin >> foot, inches; \xa0\n    \xa0\n inches = cm / 2.54; \xa0\n foot = inches / 12; \xa0\n cm = foot / (2.54 * 12); \xa0\nThe comma doesn\'t do what you want.\nYou need a >> there instead.\nWith the comma, you have two unrelated expressions that may as well have been separated by a semicolon: cin >> feet;  inches;\nTherefore what you wrote will read one value into foot and nothing into inches.\nYou\'re not doing anything with the value you read into foot.\nYou\'re overwriting it with a value converted from inches.\ninches wasn\'t initialized by cin, for reasons mentioned above.\nInstead, you\'re converting the uninitialized value in cm to inches.\ncm is what you\'re meant to convert to, and in fact you close that ouroboros a couple lines later.\nIf I told you something was 14m 33cm, how would you go about converting that to a single millimeter measurement? Or converting 3 hours, 45 minutes into seconds. Apply that thought process here.\nYour conversion Fahrenheit to Celsius always outputs zero.\nThe expression (5/9) is integer division.\nTake a closer look at your Celsius to Fahrenheit conversion and try to understand how they differ.\nOn line 207 (in my reformatted version above), you exit the program before you ask whether the user wants to perform another conversion.\nOr, at least you would if you could reach this line, but you can\'t, because it\'s outside your while loop.\nThe while loop iterates “forever,” unless you manage to input a correct entry at the top level menu.\nLines 217 and 224 (true; and false;) would do absolutely nothing if they could be reached.\nIt seems like all the code after line 207 was meant to be inside the while loop, but it isn\'t. Right now it\'s dead code.\n\nThere may be other errors, but that\'s what I spotted with a quick glance through.', 'aiModelVersion': '1'}",0.29806666666667
Saurav Sharma,Updated 5y,How did you teach yourself programming?,"I was maybe 7–8 years old, my uncle had a computer at his home which looked similar to this:

I don’t remember the specs but maybe it was pentium 2/3 with windows 95 operating system.

It was summer vacation and as a typical Indian kid, I went to stay at my uncles place.

I used to spend a lot of time on computer.I had no idea about programming, mostly I used to play games like Dave, Wolf 3d, Aladdin etc.

Later my uncle decided to uninstall games and I was left with no choice but to tinker around with other programs which the computer had.

I played around with Microsoft power point as it had some fun pictures in clipart and managed to somehow animate them. Within a few days I became quite fluent with MS powerpoint.

Next vacation my parents decided to enrol me for a computer class called “MS-CIT” which is quite a basics computer course for beginners. However the issue was that I already knew the basics.

Later it was decided that I would join the institute to learn C programming language. I was about 9–10 year old maybe in 5th grade and I was learning C.

I can remember that there were only a handful students in the class and I was the youngest. The teacher however was extremely good at explaining things and that made a lot of difference.

In the first week we were taught about simple programs like hello world, addition , printf , scanf statements etc. We were given 30 minutes to practice code and it took me a good amount of time to just write a simple hello world program. I used to copy the code from whiteboard and later just type it in into the turbo c editor which looked something like this:

Initially it was all over my head, I didn’t understand a lot of things. I considered my-selves a genius even if i was able to fix the syntax errors.

Eventually after about a month, I became quite decent with C and was able to write simple programs on my own.

After that school started and I had to quit the class, there was no computer at my home to practice. I remember our computer teacher in school asking us what we did in vacations. He was shocked when I told him I learned C programming language. It was kind of cool to say that, I felt proud the first time.

In the next 5 years I never had a chance to code because of the unavailability of a computer. I started back later after years when my parents bought me a computer and since then I’ve never looked back.

I went from learning HTML to Java and Python, I was in love with Java until I discovered Python. I still remember learning Java from a big fat book called the Java black book.

Later when I joined college for a CS degree, programming was a child’s play for me. I would finish my lab assignments in minutes and spent most of my time helping other classmates in the lab.

I then started to learn more about web development, different frameworks like bootstrap, Django, Flask etc which were never taught in our college.

I also jumped into android development just as a hobby, however with a crappy laptop it was quite difficult to get the emulator started.

I still remember how I saved money by not having coffee in my college breaks just so that I can buy 1GB data.

Big breakthrough happened when I got a broadband connection, it was now much easier for me to get access to unlimited resources on the internet. I researched and read a ton of blogs, tutorials, videos on youtube etc to learn as much as I could.

Since then there is no looking back and the journey continues till date.

Saurav Sharma's answer to How do I learn Python programming? What are resources?","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/0njwebgao1v6tp5l', 'title': 'How did you teach yourself programming?', 'score': {'original': 0.7427, 'ai': 0.2573}, 'blocks': [{'text': 'I was maybe 7–8 years old, my uncle had a computer at his home which looked similar to this:\n\nI don’t remember the specs but maybe it was pentium 2/3 with windows 95 operating system.\n\nIt was summer vacation and as a typical Indian kid, I went to stay at my uncles place.\n\nI used to spend a lot of time on computer.I had no idea about programming, mostly I used to play games like Dave, Wolf 3d, Aladdin etc.\n\nLater my uncle decided to uninstall games and I was left with no choice but to tinker around with other programs which the computer had.\n\nI played around with Microsoft power point as it had some fun pictures in clipart and managed to somehow animate them. Within a few days I became quite fluent with MS powerpoint.\n\nNext vacation my parents decided to enrol me for a computer class called “MS-CIT” which is quite a basics computer course for beginners. However the issue was that I already knew the basics.\n\nLater it was decided that I would join the institute to learn C programming language. I was about 9–10 year old maybe in 5th grade and I was learning C.\n\nI can remember that there were only a handful students in the class and I was the youngest. The teacher however was extremely good at explaining things and that made a lot of difference.\n\nIn the first week we were taught about simple programs like hello world, addition , printf , scanf statements etc. We were given 30 minutes to practice code and it took me a good amount of time to just write a simple hello world program. I used to copy the code from whiteboard and later just type it in into the turbo c editor which looked something like this:\n\nInitially it was all over my head, I didn’t understand a lot of things. I considered my-selves a genius even if i was able to fix the syntax errors.\n\nEventually after about a month, I became quite decent with C and was able to write simple programs on my own.\n\nAfter that school started and I had to quit the class, there was no computer at my home to practice. I remember our computer teacher in school asking us what we did in vacations. He was shocked when I told him I learned C programming language. It was kind of cool to say that, I felt proud the first time.\n\nIn the next 5 years I never had a chance to code because of the unavailability of a computer. I started back later after years when my parents bought me a computer and since then I’ve never looked back.\n\nI went from learning HTML to Java and Python, I was in love with Java until I discovered Python. I still remember learning Java from a big fat book called the Java black book.\n\nLater when I joined college for a CS degree, programming was a child’s play for me. I would finish my lab assignments in minutes and spent most of my time helping other classmates in the lab.\n\nI then started to learn more', 'result': {'fake': 0.1868, 'real': 0.8132}, 'status': 'success'}, {'text': ""about web development, different frameworks like bootstrap, Django, Flask etc which were never taught in our college.\n\nI also jumped into android development just as a hobby, however with a crappy laptop it was quite difficult to get the emulator started.\n\nI still remember how I saved money by not having coffee in my college breaks just so that I can buy 1GB data.\n\nBig breakthrough happened when I got a broadband connection, it was now much easier for me to get access to unlimited resources on the internet. I researched and read a ton of blogs, tutorials, videos on youtube etc to learn as much as I could.\n\nSince then there is no looking back and the journey continues till date.\n\nSaurav Sharma's answer to How do I learn Python programming? What are resources?"", 'result': {'fake': 0.7744, 'real': 0.2256}, 'status': 'success'}], 'credits_used': 7, 'credits': 1983712, 'subscription': 0, 'content': ""I was maybe 7–8 years old, my uncle had a computer at his home which looked similar to this:\n\nI don’t remember the specs but maybe it was pentium 2/3 with windows 95 operating system.\n\nIt was summer vacation and as a typical Indian kid, I went to stay at my uncles place.\n\nI used to spend a lot of time on computer.I had no idea about programming, mostly I used to play games like Dave, Wolf 3d, Aladdin etc.\n\nLater my uncle decided to uninstall games and I was left with no choice but to tinker around with other programs which the computer had.\n\nI played around with Microsoft power point as it had some fun pictures in clipart and managed to somehow animate them. Within a few days I became quite fluent with MS powerpoint.\n\nNext vacation my parents decided to enrol me for a computer class called “MS-CIT” which is quite a basics computer course for beginners. However the issue was that I already knew the basics.\n\nLater it was decided that I would join the institute to learn C programming language. I was about 9–10 year old maybe in 5th grade and I was learning C.\n\nI can remember that there were only a handful students in the class and I was the youngest. The teacher however was extremely good at explaining things and that made a lot of difference.\n\nIn the first week we were taught about simple programs like hello world, addition , printf , scanf statements etc. We were given 30 minutes to practice code and it took me a good amount of time to just write a simple hello world program. I used to copy the code from whiteboard and later just type it in into the turbo c editor which looked something like this:\n\nInitially it was all over my head, I didn’t understand a lot of things. I considered my-selves a genius even if i was able to fix the syntax errors.\n\nEventually after about a month, I became quite decent with C and was able to write simple programs on my own.\n\nAfter that school started and I had to quit the class, there was no computer at my home to practice. I remember our computer teacher in school asking us what we did in vacations. He was shocked when I told him I learned C programming language. It was kind of cool to say that, I felt proud the first time.\n\nIn the next 5 years I never had a chance to code because of the unavailability of a computer. I started back later after years when my parents bought me a computer and since then I’ve never looked back.\n\nI went from learning HTML to Java and Python, I was in love with Java until I discovered Python. I still remember learning Java from a big fat book called the Java black book.\n\nLater when I joined college for a CS degree, programming was a child’s play for me. I would finish my lab assignments in minutes and spent most of my time helping other classmates in the lab.\n\nI then started to learn more about web development, different frameworks like bootstrap, Django, Flask etc which were never taught in our college.\n\nI also jumped into android development just as a hobby, however with a crappy laptop it was quite difficult to get the emulator started.\n\nI still remember how I saved money by not having coffee in my college breaks just so that I can buy 1GB data.\n\nBig breakthrough happened when I got a broadband connection, it was now much easier for me to get access to unlimited resources on the internet. I researched and read a ton of blogs, tutorials, videos on youtube etc to learn as much as I could.\n\nSince then there is no looking back and the journey continues till date.\n\nSaurav Sharma's answer to How do I learn Python programming? What are resources?"", 'aiModelVersion': '1'}",0.7427
Paulina Jonušaitė,5y,What is one thing that you can tell me that will make me a better programmer?,"Code duplication is cheaper than wrong abstraction.

At the beginning of any project, the design of the system hinges on a very limited and superficial understanding of the problem domain. As the understanding evolves, so must evolve the domain model. Yet, I have seen multiple occasions where some abstraction that is known to be inadequate is maintained throughout the project due to sunk cost fallacy, with multiple if-statements piled upon it just to force it into working.

Always take a step back and evaluate if the concepts that your domain model reflects are still relevant or meaningful. What you know now is not the same as what you knew back then. Your understanding changes, and sometimes to appropriately reflect that, you need to undo the abstraction, inline its whole logic back into the code, and then see if there is a better way to group things back up into relevant and currently meaningful pieces.

However, bringing this back to the first sentence of this answer, sometimes you simply just don’t need the abstraction. Yes, there may be some bit of code that looks like that other bit of code, but your abstractions must have semantics attached to them. Just because something seems like something else, it doesn’t mean that they are actually related, and by introducing an abstraction, you will tie these things together despite the fact that the similarity is very superficial.

Resist this urge. Unless you can explain very clearly what is the real world meaning of the abstraction, it is much cheaper in the long run to just keep the seemingly duplicate code intact and revisit it later on, when your domain understanding has grown, to see if the two concepts have converged enough to extract some commonalities, or whether they have diverged even further, making the concepts completely incompatible.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/plowigumfbnvz2k7', 'title': 'What is one thing that you can tell me that will make me a better programmer?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'Code duplication is cheaper than wrong abstraction.\n\nAt the beginning of any project, the design of the system hinges on a very limited and superficial understanding of the problem domain. As the understanding evolves, so must evolve the domain model. Yet, I have seen multiple occasions where some abstraction that is known to be inadequate is maintained throughout the project due to sunk cost fallacy, with multiple if-statements piled upon it just to force it into working.\n\nAlways take a step back and evaluate if the concepts that your domain model reflects are still relevant or meaningful. What you know now is not the same as what you knew back then. Your understanding changes, and sometimes to appropriately reflect that, you need to undo the abstraction, inline its whole logic back into the code, and then see if there is a better way to group things back up into relevant and currently meaningful pieces.\n\nHowever, bringing this back to the first sentence of this answer, sometimes you simply just don’t need the abstraction. Yes, there may be some bit of code that looks like that other bit of code, but your abstractions must have semantics attached to them. Just because something seems like something else, it doesn’t mean that they are actually related, and by introducing an abstraction, you will tie these things together despite the fact that the similarity is very superficial.\n\nResist this urge. Unless you can explain very clearly what is the real world meaning of the abstraction, it is much cheaper in the long run to just keep the seemingly duplicate code intact and revisit it later on, when your domain understanding has grown, to see if the two concepts have converged enough to extract some commonalities, or whether they have diverged even further, making the concepts completely incompatible.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983708, 'subscription': 0, 'content': 'Code duplication is cheaper than wrong abstraction.\n\nAt the beginning of any project, the design of the system hinges on a very limited and superficial understanding of the problem domain. As the understanding evolves, so must evolve the domain model. Yet, I have seen multiple occasions where some abstraction that is known to be inadequate is maintained throughout the project due to sunk cost fallacy, with multiple if-statements piled upon it just to force it into working.\n\nAlways take a step back and evaluate if the concepts that your domain model reflects are still relevant or meaningful. What you know now is not the same as what you knew back then. Your understanding changes, and sometimes to appropriately reflect that, you need to undo the abstraction, inline its whole logic back into the code, and then see if there is a better way to group things back up into relevant and currently meaningful pieces.\n\nHowever, bringing this back to the first sentence of this answer, sometimes you simply just don’t need the abstraction. Yes, there may be some bit of code that looks like that other bit of code, but your abstractions must have semantics attached to them. Just because something seems like something else, it doesn’t mean that they are actually related, and by introducing an abstraction, you will tie these things together despite the fact that the similarity is very superficial.\n\nResist this urge. Unless you can explain very clearly what is the real world meaning of the abstraction, it is much cheaper in the long run to just keep the seemingly duplicate code intact and revisit it later on, when your domain understanding has grown, to see if the two concepts have converged enough to extract some commonalities, or whether they have diverged even further, making the concepts completely incompatible.', 'aiModelVersion': '1'}",0.9995
Jonas,5y,"If you designed a programming language to be as evil as possible, what features would it have?","There’s only one way to make a language as evil as possible. And it’s very simple, so I’m surprised that it hasn’t come up so far. The problem with existing approaches is that they are obvious and people just will not use the language.

Here’s the approach to true evil.

Make the language a really worthy replacement of an existing language (C, erlang, …). However, …

… if your program size exceeds 100000 lines, the semantics of some operator changes in some subtle way.

For example, integer division goes from rounding towards zero to rounding towards minus infinity, stores to shared locations no longer emit memory barriers, or some other triviality like this.

Of course this change is not documented anywhere, except that it exists as code in the highly complex and obfuscated optimizing routines of the standard compiler.

If you can not see how this is evil, observe that it is basically impossible to create a MWE for any bugs you have, because the bug disappears when you restrict the size. The bug will also appear as a side effect of a likely completely unrelated change in some other module where you added a feature that pushed the total number of lines over 100k. The help messages will look like this:

I just added a new feature and it broke my program. When I revert the feature in the repo, the bug disappears. Here’s the feature. Help?

If the change is subtle enough, most programs will not see any new behaviors as a consequence of the change; this allows the change to remain undetected for considerably longer, so the bug will appear without warning, without stackoverflow help threads, and so on. This will make it incredibly hard to figure out the source of any bugs.

Unit testing can not catch these bugs, because units are too small. Only the full system is buggy.

Finally, because programmers typically learn the language with tinker-toy examples, they will get used to the “normal” semantics of the operator, and be completely blindsided by the changed behavior when they start working on a large-scale project.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/c3ftu6kvoj14gs29', 'title': 'If you designed a programming language to be as evil as possible, what features would it have?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'There’s only one way to make a language as evil as possible. And it’s very simple, so I’m surprised that it hasn’t come up so far. The problem with existing approaches is that they are obvious and people just will not use the language.\n\nHere’s the approach to true evil.\n\nMake the language a really worthy replacement of an existing language (C, erlang, …). However, …\n\n… if your program size exceeds 100000 lines, the semantics of some operator changes in some subtle way.\n\nFor example, integer division goes from rounding towards zero to rounding towards minus infinity, stores to shared locations no longer emit memory barriers, or some other triviality like this.\n\nOf course this change is not documented anywhere, except that it exists as code in the highly complex and obfuscated optimizing routines of the standard compiler.\n\nIf you can not see how this is evil, observe that it is basically impossible to create a MWE for any bugs you have, because the bug disappears when you restrict the size. The bug will also appear as a side effect of a likely completely unrelated change in some other module where you added a feature that pushed the total number of lines over 100k. The help messages will look like this:\n\nI just added a new feature and it broke my program. When I revert the feature in the repo, the bug disappears. Here’s the feature. Help?\n\nIf the change is subtle enough, most programs will not see any new behaviors as a consequence of the change; this allows the change to remain undetected for considerably longer, so the bug will appear without warning, without stackoverflow help threads, and so on. This will make it incredibly hard to figure out the source of any bugs.\n\nUnit testing can not catch these bugs, because units are too small. Only the full system is buggy.\n\nFinally, because programmers typically learn the language with tinker-toy examples, they will get used to the “normal” semantics of the operator, and be completely blindsided by the changed behavior when they start working on a large-scale project.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983704, 'subscription': 0, 'content': 'There’s only one way to make a language as evil as possible. And it’s very simple, so I’m surprised that it hasn’t come up so far. The problem with existing approaches is that they are obvious and people just will not use the language.\n\nHere’s the approach to true evil.\n\nMake the language a really worthy replacement of an existing language (C, erlang, …). However, …\n\n… if your program size exceeds 100000 lines, the semantics of some operator changes in some subtle way.\n\nFor example, integer division goes from rounding towards zero to rounding towards minus infinity, stores to shared locations no longer emit memory barriers, or some other triviality like this.\n\nOf course this change is not documented anywhere, except that it exists as code in the highly complex and obfuscated optimizing routines of the standard compiler.\n\nIf you can not see how this is evil, observe that it is basically impossible to create a MWE for any bugs you have, because the bug disappears when you restrict the size. The bug will also appear as a side effect of a likely completely unrelated change in some other module where you added a feature that pushed the total number of lines over 100k. The help messages will look like this:\n\nI just added a new feature and it broke my program. When I revert the feature in the repo, the bug disappears. Here’s the feature. Help?\n\nIf the change is subtle enough, most programs will not see any new behaviors as a consequence of the change; this allows the change to remain undetected for considerably longer, so the bug will appear without warning, without stackoverflow help threads, and so on. This will make it incredibly hard to figure out the source of any bugs.\n\nUnit testing can not catch these bugs, because units are too small. Only the full system is buggy.\n\nFinally, because programmers typically learn the language with tinker-toy examples, they will get used to the “normal” semantics of the operator, and be completely blindsided by the changed behavior when they start working on a large-scale project.', 'aiModelVersion': '1'}",0.9998
Victor Dirikebamor,Updated 3y,"Why don't more poor people with internet access teach themselves to code, and earn a more comfortable living? What other barriers may be in play here?","I'm answering this question as a Nigerian and you will know why I'm saying this in the end.

I write about Nigeria and Africa a lot on this platform and others and some persons never fail to complain to me how a Nigerian or some Ghanaian duped them online like I'm some Interpol. I try my possible best to calm them down and to warn them.

Some always suggest this online scammers from Nigeria should turn their evil activities into productive use like doing positive services on the internet if they can't find real jobs.

Yes, finding a real job is like passing through the eye of a needle in Nigeria. It is possible to graduate from college and not have a single place to apply for a job.

This is why I'm answering this question.

No doubt many Nigerians know the computer in and out and they could perform several complex tasks with it. I'm not boasting, when it comes to talent Nigeria is not in short supply. I myself could do several complex tasks with a Computer.

That being cleared out.

Poor people have access to the internet but not like Western countries, there are almost no free internet, you've go to pay for it and from my little research and observations poor countries spend the highest money on data, it burns like wildfire.

There are few or no cafes, bars and lounges who provide free internet. Every byte is paid for.

But the primary reason poor talented people like some Nigerians can't make a living from freelancing is that rich people don't entrust their money to poor people. They won't give you a job if you're from a developing country, they won't give you a chance if you're a Nigerian.

The situation is like a prisoner who goes back to prison after being released just few weeks or months ago because they saw nothing legally productive to do.

The service this persons could perform in the legal way is not needed, it's not available to them, hence some do the unthinkable for survival.

When you teach someone a skill and he's got no opportunity to apply it positively he might use it for the wrong reasons and this is the challenge talented young men in underdeveloped countries face.

I know my reasons here are a bit flimsy but a well thinking man can't just close his eyes and say this challenges doesn't exist.

I've been there. I've been rejected by employers online for a job I could do very well simply because I was a Nigerian.

Just so you know; it's never easy for the poor man in a poor country.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/gfor2lsedixnj5u6', 'title': ""Why don't more poor people with internet access teach themselves to code, and earn a more comfortable living? What other barriers may be in play here?"", 'score': {'original': 0.9999, 'ai': 0.0001}, 'blocks': [{'text': ""I'm answering this question as a Nigerian and you will know why I'm saying this in the end.\n\nI write about Nigeria and Africa a lot on this platform and others and some persons never fail to complain to me how a Nigerian or some Ghanaian duped them online like I'm some Interpol. I try my possible best to calm them down and to warn them.\n\nSome always suggest this online scammers from Nigeria should turn their evil activities into productive use like doing positive services on the internet if they can't find real jobs.\n\nYes, finding a real job is like passing through the eye of a needle in Nigeria. It is possible to graduate from college and not have a single place to apply for a job.\n\nThis is why I'm answering this question.\n\nNo doubt many Nigerians know the computer in and out and they could perform several complex tasks with it. I'm not boasting, when it comes to talent Nigeria is not in short supply. I myself could do several complex tasks with a Computer.\n\nThat being cleared out.\n\nPoor people have access to the internet but not like Western countries, there are almost no free internet, you've go to pay for it and from my little research and observations poor countries spend the highest money on data, it burns like wildfire.\n\nThere are few or no cafes, bars and lounges who provide free internet. Every byte is paid for.\n\nBut the primary reason poor talented people like some Nigerians can't make a living from freelancing is that rich people don't entrust their money to poor people. They won't give you a job if you're from a developing country, they won't give you a chance if you're a Nigerian.\n\nThe situation is like a prisoner who goes back to prison after being released just few weeks or months ago because they saw nothing legally productive to do.\n\nThe service this persons could perform in the legal way is not needed, it's not available to them, hence some do the unthinkable for survival.\n\nWhen you teach someone a skill and he's got no opportunity to apply it positively he might use it for the wrong reasons and this is the challenge talented young men in underdeveloped countries face.\n\nI know my reasons here are a bit flimsy but a well thinking man can't just close his eyes and say this challenges doesn't exist.\n\nI've been there. I've been rejected by employers online for a job I could do very well simply because I was a Nigerian.\n\nJust so you know; it's never easy for the poor man in a poor country."", 'result': {'fake': 0.0001, 'real': 0.9999}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983699, 'subscription': 0, 'content': ""I'm answering this question as a Nigerian and you will know why I'm saying this in the end.\n\nI write about Nigeria and Africa a lot on this platform and others and some persons never fail to complain to me how a Nigerian or some Ghanaian duped them online like I'm some Interpol. I try my possible best to calm them down and to warn them.\n\nSome always suggest this online scammers from Nigeria should turn their evil activities into productive use like doing positive services on the internet if they can't find real jobs.\n\nYes, finding a real job is like passing through the eye of a needle in Nigeria. It is possible to graduate from college and not have a single place to apply for a job.\n\nThis is why I'm answering this question.\n\nNo doubt many Nigerians know the computer in and out and they could perform several complex tasks with it. I'm not boasting, when it comes to talent Nigeria is not in short supply. I myself could do several complex tasks with a Computer.\n\nThat being cleared out.\n\nPoor people have access to the internet but not like Western countries, there are almost no free internet, you've go to pay for it and from my little research and observations poor countries spend the highest money on data, it burns like wildfire.\n\nThere are few or no cafes, bars and lounges who provide free internet. Every byte is paid for.\n\nBut the primary reason poor talented people like some Nigerians can't make a living from freelancing is that rich people don't entrust their money to poor people. They won't give you a job if you're from a developing country, they won't give you a chance if you're a Nigerian.\n\nThe situation is like a prisoner who goes back to prison after being released just few weeks or months ago because they saw nothing legally productive to do.\n\nThe service this persons could perform in the legal way is not needed, it's not available to them, hence some do the unthinkable for survival.\n\nWhen you teach someone a skill and he's got no opportunity to apply it positively he might use it for the wrong reasons and this is the challenge talented young men in underdeveloped countries face.\n\nI know my reasons here are a bit flimsy but a well thinking man can't just close his eyes and say this challenges doesn't exist.\n\nI've been there. I've been rejected by employers online for a job I could do very well simply because I was a Nigerian.\n\nJust so you know; it's never easy for the poor man in a poor country."", 'aiModelVersion': '1'}",0.9999
Joe Seabreeze,8y,What are the three most important things non-programmers should know about programming?,"It's a thankless job, but can be self-rewarding.
It's not easy, specifically when you get paid to do it.
It can be bad for your health if you're not careful (we sit a lot, we stare at a glowing screen all day, we type a lot). But it does retain a healthy brain because we're always solving problems.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/uj23q8v9ot1xak4m', 'title': 'What are the three most important things non-programmers should know about programming?', 'score': {'original': 0.0534, 'ai': 0.9466}, 'blocks': [{'text': ""It's a thankless job, but can be self-rewarding.\nIt's not easy, specifically when you get paid to do it.\nIt can be bad for your health if you're not careful (we sit a lot, we stare at a glowing screen all day, we type a lot). But it does retain a healthy brain because we're always solving problems."", 'result': {'fake': 0.9466, 'real': 0.0534}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983698, 'subscription': 0, 'content': ""It's a thankless job, but can be self-rewarding.\nIt's not easy, specifically when you get paid to do it.\nIt can be bad for your health if you're not careful (we sit a lot, we stare at a glowing screen all day, we type a lot). But it does retain a healthy brain because we're always solving problems."", 'aiModelVersion': '1'}",0.0534
Egor Suvorov,Updated 8y,What are the common mistakes made by beginner competitive programmers?,"Please note that this answer is dedicated to competitive programmers only, as well as some recommendations in it. Competitive programming is not about readability, but about being able to code and debug fast.

And still, the mains problems that I've seen: laziness and do not caring about code style even a little. That's ok if your program gets Accepted on first try, but otherwise you're gonna have a bad time debugging it. In general. So, mistakes (all of them are real stories):


Focusing on easier and 'cooler' things (like using of bitwise operations a lot instead of straightforward mathmatical formulas) instead of making code simpler to read and debug. Not only for them, but for the one who will help them too.

Copy-pasting it all around. ""We don't need no architecture, just a little hack here is not bad. Oh, and here is another one. And here. C'mon, I still can tell you how is this supposed to work, but it doesn't work somewhy, can you help me?"". ""Re-using same code and introduce extra parameter to make it behave little differently in two cases with a bunch of local ifs? Nah, let's just copy this 50-lines procedure and make changes in the new instance."".

Having global counters for local loops. Ex-Pascalists do this a lot more than others. Good luck having recursive calls with that.
Using global variables for passing parameters instead of, well, parameters. EVERYWHERE. Combine this with copy-paste and you get a monster. Like, if you have three big integers stored in arrays name A, B and C, what is the best way to write a procedure for subtracting one from another? Correct, you write two procedures: sab (subtracts B from A and writes result to C), sbc (subtracts C from B and writes result to A). Oh. My. God. Why don't you make it a pass-by-reference-parameter and one procedure instead of two?

Re-using same variable 'because I'm too lazy to declare another one'. So, in this half of program it means 'number of elements in the input' and in the another it serves like 'for' counter.

Naming ALL variables and arrays with single letter. For the sake of typing speed, of course. Like this: f[p2] = c, a[i++] = b;. It can be ok if they would be able to completely understand that and debug it by themselves, but, well, beginners are typically not the case.
No identation. At all. ""Why do I need it, I'm gonna write this, get OK and noone will read this again ever?"". ""Oh, yeah, indentation, I'm gonna add this in my next solution, not in this, it's already too big for formatting"". This applies to non-competitive programmers too. Thank God, we have Python especially for them :)

Concentrating on writing full solution at once, instead of splitting it into several smaller parts and debugging them one-by-one. ""Would you mind looking at my 250-lines program which uses two algorithms? It doesn't work."" - they ask. I ask: ""Which part of your program does not work?"". They answer: ""I don't know, I've just compiled it and it gives wrong answer"". Please, split writing code in small steps, so you can be somehow sure about previous code when writing next.

Trying to go and solve IOI problems 'for training purposes' without enough practice. Imho, it's much better to save this problem for the time of actual IOI training, and start with easier ones - there are a plenty of good problems for beginners, that are interesting and challenging.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/fxgql9p5acyto2m0', 'title': 'What are the common mistakes made by beginner competitive programmers?', 'score': {'original': 0.8233, 'ai': 0.1767}, 'blocks': [{'text': 'Please note that this answer is dedicated to competitive programmers only, as well as some recommendations in it. Competitive programming is not about readability, but about being able to code and debug fast.\n\nAnd still, the mains problems that I\'ve seen: laziness and do not caring about code style even a little. That\'s ok if your program gets Accepted on first try, but otherwise you\'re gonna have a bad time debugging it. In general. So, mistakes (all of them are real stories):\n\n\nFocusing on easier and \'cooler\' things (like using of bitwise operations a lot instead of straightforward mathmatical formulas) instead of making code simpler to read and debug. Not only for them, but for the one who will help them too.\n\nCopy-pasting it all around. ""We don\'t need no architecture, just a little hack here is not bad. Oh, and here is another one. And here. C\'mon, I still can tell you how is this supposed to work, but it doesn\'t work somewhy, can you help me?"". ""Re-using same code and introduce extra parameter to make it behave little differently in two cases with a bunch of local ifs? Nah, let\'s just copy this 50-lines procedure and make changes in the new instance."".\n\nHaving global counters for local loops. Ex-Pascalists do this a lot more than others. Good luck having recursive calls with that.\nUsing global variables for passing parameters instead of, well, parameters. EVERYWHERE. Combine this with copy-paste and you get a monster. Like, if you have three big integers stored in arrays name A, B and C, what is the best way to write a procedure for subtracting one from another? Correct, you write two procedures: sab (subtracts B from A and writes result to C), sbc (subtracts C from B and writes result to A). Oh. My. God. Why don\'t you make it a pass-by-reference-parameter and one procedure instead of two?\n\nRe-using same variable \'because I\'m too lazy to declare another one\'. So, in this half of program it means \'number of elements in the input\' and in the another it serves like \'for\' counter.\n\nNaming ALL variables and arrays with single letter. For the sake of typing speed, of course. Like this: f[p2] = c, a[i++] = b;. It can be ok if they would be able to completely understand that and debug it by themselves, but, well, beginners are typically not the case.\nNo identation. At all. ""Why do I need it, I\'m gonna write this, get OK and noone will read this again ever?"". ""Oh, yeah, indentation, I\'m gonna add this in my next solution, not in this, it\'s already too big for formatting"". This applies to non-competitive programmers too. Thank God, we have Python especially for them :)\n\nConcentrating on writing full solution at once, instead of splitting it into several smaller parts and debugging them one-by-one. ""Would you mind looking at my 250-lines program which uses two algorithms? It doesn\'t work."" - they ask. I ask: ""Which part of your program does not work?"". They answer: ""I don\'t know, I\'ve just compiled it and it gives wrong answer"". Please, split writing code', 'result': {'fake': 0.091, 'real': 0.909}, 'status': 'success'}, {'text': ""in small steps, so you can be somehow sure about previous code when writing next.\n\nTrying to go and solve IOI problems 'for training purposes' without enough practice. Imho, it's much better to save this problem for the time of actual IOI training, and start with easier ones - there are a plenty of good problems for beginners, that are interesting and challenging."", 'result': {'fake': 0.0435, 'real': 0.9565}, 'status': 'success'}], 'credits_used': 6, 'credits': 1983692, 'subscription': 0, 'content': 'Please note that this answer is dedicated to competitive programmers only, as well as some recommendations in it. Competitive programming is not about readability, but about being able to code and debug fast.\n\nAnd still, the mains problems that I\'ve seen: laziness and do not caring about code style even a little. That\'s ok if your program gets Accepted on first try, but otherwise you\'re gonna have a bad time debugging it. In general. So, mistakes (all of them are real stories):\n\n\nFocusing on easier and \'cooler\' things (like using of bitwise operations a lot instead of straightforward mathmatical formulas) instead of making code simpler to read and debug. Not only for them, but for the one who will help them too.\n\nCopy-pasting it all around. ""We don\'t need no architecture, just a little hack here is not bad. Oh, and here is another one. And here. C\'mon, I still can tell you how is this supposed to work, but it doesn\'t work somewhy, can you help me?"". ""Re-using same code and introduce extra parameter to make it behave little differently in two cases with a bunch of local ifs? Nah, let\'s just copy this 50-lines procedure and make changes in the new instance."".\n\nHaving global counters for local loops. Ex-Pascalists do this a lot more than others. Good luck having recursive calls with that.\nUsing global variables for passing parameters instead of, well, parameters. EVERYWHERE. Combine this with copy-paste and you get a monster. Like, if you have three big integers stored in arrays name A, B and C, what is the best way to write a procedure for subtracting one from another? Correct, you write two procedures: sab (subtracts B from A and writes result to C), sbc (subtracts C from B and writes result to A). Oh. My. God. Why don\'t you make it a pass-by-reference-parameter and one procedure instead of two?\n\nRe-using same variable \'because I\'m too lazy to declare another one\'. So, in this half of program it means \'number of elements in the input\' and in the another it serves like \'for\' counter.\n\nNaming ALL variables and arrays with single letter. For the sake of typing speed, of course. Like this: f[p2] = c, a[i++] = b;. It can be ok if they would be able to completely understand that and debug it by themselves, but, well, beginners are typically not the case.\nNo identation. At all. ""Why do I need it, I\'m gonna write this, get OK and noone will read this again ever?"". ""Oh, yeah, indentation, I\'m gonna add this in my next solution, not in this, it\'s already too big for formatting"". This applies to non-competitive programmers too. Thank God, we have Python especially for them :)\n\nConcentrating on writing full solution at once, instead of splitting it into several smaller parts and debugging them one-by-one. ""Would you mind looking at my 250-lines program which uses two algorithms? It doesn\'t work."" - they ask. I ask: ""Which part of your program does not work?"". They answer: ""I don\'t know, I\'ve just compiled it and it gives wrong answer"". Please, split writing code in small steps, so you can be somehow sure about previous code when writing next.\n\nTrying to go and solve IOI problems \'for training purposes\' without enough practice. Imho, it\'s much better to save this problem for the time of actual IOI training, and start with easier ones - there are a plenty of good problems for beginners, that are interesting and challenging.', 'aiModelVersion': '1'}",0.8233
Shubham Saxena,5y,Which programming language is good for testers?,"Here is a list of some good programming languages for testers

1.Javascript

Framework for JavaScript

Cucumber JS:

It is the most popular framework for JavaScript. Writing code is more like writing instructions in Simple English. Its Uniqueness is what you will like the most.

Nightwatch:

Nightwatch is one of the preferred framework for experienced developers. Built using Node.js, Nightwatch is a W3C WebDriver API based automated testing framework for web applications and websites.

Protractor

It is an open source functional automation framework which is also known as E2E testing framework which lets AngularJS web applications.

2. Java

Framework for Java

Gauge:

It supports all kinds of platforms and languages. It also have a strong community support because of which it is very easy to extend via plugins. In addition it also have strong native support for external data source.

TestNG:

It have a very strong community support and it easy to merge test builds. Another reason behind popularity of TestNG is its native support for running test cases parallely. It is annotation based framework that lets you test in arbitrarily big thread pool. It have flexible test configuration.

Junit:

It is one of the most popular open source tool. It also have easy integration with Java IDEs , eclipse, Netbeans.

3. Python

Frameworks for Python

Behave

Behave is built from ground up to support Behavior-driven development (or BDD ) and agile software development. It also helps in easy collaboration between the developers, QA and non-technical in a software project.

Lettuce

It is a also a BDD oriented framework that permits to run automated python tests from plain-text. There is no additional setup needed to setup python compiler.

PyUnit

It is standard unit testing framework module for Python. Based on mature XUnit framework development, PyUnit can reuse setup codes.

4. C#

Frameworks for C#

Nunit

It lets you the test results in readable format and lets the allow testers to debug the automated tests.

Visual studio unit testing framework

Built for the Visual Studio development platform by microsoft, Visual Studio Unit Testing Framework (also know as MSTest), is a very popular tool among .Net developers.

SpecFlow

Specflow is another open source framework that works seamlessly with Gherkin Parse, .Net framework, and even Xamarin. In addition you can also use other C# based libraries with it like NUnit, MStest, xUnit and MbUnit.

5. PHP

Frameworks for PHP

Codeception

Codeception is an Automated Testing Framework that makes the code easy to read, write and debug. It is also called as BDD – Behavior Driven Development.

Behat

Behat is an open-source testing framework that is favoured by developers because of ease of test case management it provides.

SimpleTest

It is used for the unit as well as Web testing framework that supports proxies, SSI, forms, frames etc. it is easy to understand and natively help in tracking of bugs during unit testing.

Source: Top Programming Languages Helpful For Testers","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/1gjy5oxb8zqisc9n', 'title': 'Which programming language is good for testers?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Here is a list of some good programming languages for testers\n\n1.Javascript\n\nFramework for JavaScript\n\nCucumber JS:\n\nIt is the most popular framework for JavaScript. Writing code is more like writing instructions in Simple English. Its Uniqueness is what you will like the most.\n\nNightwatch:\n\nNightwatch is one of the preferred framework for experienced developers. Built using Node.js, Nightwatch is a W3C WebDriver API based automated testing framework for web applications and websites.\n\nProtractor\n\nIt is an open source functional automation framework which is also known as E2E testing framework which lets AngularJS web applications.\n\n2. Java\n\nFramework for Java\n\nGauge:\n\nIt supports all kinds of platforms and languages. It also have a strong community support because of which it is very easy to extend via plugins. In addition it also have strong native support for external data source.\n\nTestNG:\n\nIt have a very strong community support and it easy to merge test builds. Another reason behind popularity of TestNG is its native support for running test cases parallely. It is annotation based framework that lets you test in arbitrarily big thread pool. It have flexible test configuration.\n\nJunit:\n\nIt is one of the most popular open source tool. It also have easy integration with Java IDEs , eclipse, Netbeans.\n\n3. Python\n\nFrameworks for Python\n\nBehave\n\nBehave is built from ground up to support Behavior-driven development (or BDD ) and agile software development. It also helps in easy collaboration between the developers, QA and non-technical in a software project.\n\nLettuce\n\nIt is a also a BDD oriented framework that permits to run automated python tests from plain-text. There is no additional setup needed to setup python compiler.\n\nPyUnit\n\nIt is standard unit testing framework module for Python. Based on mature XUnit framework development, PyUnit can reuse setup codes.\n\n4. C#\n\nFrameworks for C#\n\nNunit\n\nIt lets you the test results in readable format and lets the allow testers to debug the automated tests.\n\nVisual studio unit testing framework\n\nBuilt for the Visual Studio development platform by microsoft, Visual Studio Unit Testing Framework (also know as MSTest), is a very popular tool among .Net developers.\n\nSpecFlow\n\nSpecflow is another open source framework that works seamlessly with Gherkin Parse, .Net framework, and even Xamarin. In addition you can also use other C# based libraries with it like NUnit, MStest, xUnit and MbUnit.\n\n5. PHP\n\nFrameworks for PHP\n\nCodeception\n\nCodeception is an Automated Testing Framework that makes the code easy to read, write and debug. It is also called as BDD – Behavior Driven Development.\n\nBehat\n\nBehat is an open-source testing framework that is favoured by developers because of ease of test case management it provides.\n\nSimpleTest\n\nIt is used for the unit as well as Web testing framework that supports proxies, SSI, forms, frames etc. it is easy to understand and natively help in tracking of bugs during unit testing.\n\nSource: Top Programming Languages Helpful For Testers', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 5, 'credits': 1983687, 'subscription': 0, 'content': 'Here is a list of some good programming languages for testers\n\n1.Javascript\n\nFramework for JavaScript\n\nCucumber JS:\n\nIt is the most popular framework for JavaScript. Writing code is more like writing instructions in Simple English. Its Uniqueness is what you will like the most.\n\nNightwatch:\n\nNightwatch is one of the preferred framework for experienced developers. Built using Node.js, Nightwatch is a W3C WebDriver API based automated testing framework for web applications and websites.\n\nProtractor\n\nIt is an open source functional automation framework which is also known as E2E testing framework which lets AngularJS web applications.\n\n2. Java\n\nFramework for Java\n\nGauge:\n\nIt supports all kinds of platforms and languages. It also have a strong community support because of which it is very easy to extend via plugins. In addition it also have strong native support for external data source.\n\nTestNG:\n\nIt have a very strong community support and it easy to merge test builds. Another reason behind popularity of TestNG is its native support for running test cases parallely. It is annotation based framework that lets you test in arbitrarily big thread pool. It have flexible test configuration.\n\nJunit:\n\nIt is one of the most popular open source tool. It also have easy integration with Java IDEs , eclipse, Netbeans.\n\n3. Python\n\nFrameworks for Python\n\nBehave\n\nBehave is built from ground up to support Behavior-driven development (or BDD ) and agile software development. It also helps in easy collaboration between the developers, QA and non-technical in a software project.\n\nLettuce\n\nIt is a also a BDD oriented framework that permits to run automated python tests from plain-text. There is no additional setup needed to setup python compiler.\n\nPyUnit\n\nIt is standard unit testing framework module for Python. Based on mature XUnit framework development, PyUnit can reuse setup codes.\n\n4. C#\n\nFrameworks for C#\n\nNunit\n\nIt lets you the test results in readable format and lets the allow testers to debug the automated tests.\n\nVisual studio unit testing framework\n\nBuilt for the Visual Studio development platform by microsoft, Visual Studio Unit Testing Framework (also know as MSTest), is a very popular tool among .Net developers.\n\nSpecFlow\n\nSpecflow is another open source framework that works seamlessly with Gherkin Parse, .Net framework, and even Xamarin. In addition you can also use other C# based libraries with it like NUnit, MStest, xUnit and MbUnit.\n\n5. PHP\n\nFrameworks for PHP\n\nCodeception\n\nCodeception is an Automated Testing Framework that makes the code easy to read, write and debug. It is also called as BDD – Behavior Driven Development.\n\nBehat\n\nBehat is an open-source testing framework that is favoured by developers because of ease of test case management it provides.\n\nSimpleTest\n\nIt is used for the unit as well as Web testing framework that supports proxies, SSI, forms, frames etc. it is easy to understand and natively help in tracking of bugs during unit testing.\n\nSource: Top Programming Languages Helpful For Testers', 'aiModelVersion': '1'}",0.9998
Sayed Hajaj,5y,What are the three most important things non-programmers should know about programming?,"We can’t fix your printer. Programming and dealing with printers (and your computer, and your plumbing and whatever else you want us to fix) are different things.
Your idea of what’s easy and what’s complicated to program are probably very inaccurate. Now, having a skewed sense of complexity for a foreign field is perfectly reasonable. What is not so reasonable is adamantly insisting that something is easy without having the skills to do it yourself.
Just because we’re not typing anything doesn’t mean we’re not programming. Typing things is the easier part. Coming up with the solution is done in our heads. It doesn’t look as impressive but it’s important. Interrupt at your own risk.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/7y6uaikgf9e3v2zh', 'title': 'What are the three most important things non-programmers should know about programming?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'We can’t fix your printer. Programming and dealing with printers (and your computer, and your plumbing and whatever else you want us to fix) are different things.\nYour idea of what’s easy and what’s complicated to program are probably very inaccurate. Now, having a skewed sense of complexity for a foreign field is perfectly reasonable. What is not so reasonable is adamantly insisting that something is easy without having the skills to do it yourself.\nJust because we’re not typing anything doesn’t mean we’re not programming. Typing things is the easier part. Coming up with the solution is done in our heads. It doesn’t look as impressive but it’s important. Interrupt at your own risk.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983685, 'subscription': 0, 'content': 'We can’t fix your printer. Programming and dealing with printers (and your computer, and your plumbing and whatever else you want us to fix) are different things.\nYour idea of what’s easy and what’s complicated to program are probably very inaccurate. Now, having a skewed sense of complexity for a foreign field is perfectly reasonable. What is not so reasonable is adamantly insisting that something is easy without having the skills to do it yourself.\nJust because we’re not typing anything doesn’t mean we’re not programming. Typing things is the easier part. Coming up with the solution is done in our heads. It doesn’t look as impressive but it’s important. Interrupt at your own risk.', 'aiModelVersion': '1'}",0.9995
Martin La Grange,Updated 4y,Why were old games programmed in assembly when higher level languages existed?,"Hello there,

There is a yet top-notch flight simulation which was hand-coded in 32-bit Intel i386 Assembly language, and has a number of pilots flying it even yet - including me.

It’s this :

Su-27 Flanker for Windows 95

Don’t let its age stop you - this is a crisp jet flight combat simulator with detail enough to be fascinating even now - and its story contains a twist or two that should demonstrate why assembly coding a game remains an admired high art, even into the present day.

Why was it coded in Assembly language? Well, after you see the features list, the reasons make the application - on modernish hardware and software - admirable.

Modelled Features - all good btw.

Comprehensive, fluid-dynamic modelling of the Su-27 for a very accurate simulation of flight and physics. Your Flanker even pulls contrails, and gas-flow dynamics for accurate stall, turn and flight simulation are delivered in real-time - quite an achievement for a Pentium-1 class machine for which the software was designed.
Equally detailed modelling of other aircraft, ships, ground units, SAMs. All flight surfaces move, the wheel steering works - in short, all possible detail is modelled with dramatic accuracy.
The operational area, the Crimean peninsula, is modelled down to the level of powerlines and cars on the road.
Lighting is dynamic, for different times of day, and year. Clouds, while basic, are compelling to look at and fly.
Real time Goraud-shaded polygonal graphics, which while ancient today, remain crisp and rapid to render on even the most basic hardware back then.
The cockpit features a set of instruments which work with the detail of the real thing.
Most important of all - there is NO lag, and NO impact to speed when running possibly hundreds of objects simultaneously! It’s full speed all the way - and to the sim pilot this is endearing and impressive.

Now for the twists :

Because it is 32-bit Assembly coded, the entire program is TINY - only 12 Megabytes in total ! This is dramatic, insofar as all its competitors were at the time huge - the smallest near-equivalent was literally 10 times the size, disk wise!
Its origin should give you pause - the reason that SAM and Weapon performance is so incredibly accurate is that it began life as a Weapons Simulation Trainer for the Russian Air Force! Yup, this software is a piece of Surplus MILITARY Software!

And entire Su-27 v1.5 installation occupies a princely 30 megabytes of disk space - over half of which is the manual! Then, the mission files themselves (and they can be very dense in terms of units etc.) are kilobytes in size, thanks again to them being encoded in an assembly-language compatible format for processing.

Finally - I can and do run it seamlessly on my Windows 10 PC, as the application is directly addressing the CPU in i386 mode, for all the performance it needs.

It is, to the best of my knowledge, one of the last hand-coded games made in Assembly Language, and one of the most impressive, as it clearly utilising this program stategy for maximum performance and impact.

Its legacy is with us yet in the form of Lock-On: Modern Air Combat, and of course DCS World - which are its lineal descendants.

My 2c worth, and kind regards.

Addendum -

For all those interested, it is possible today to get hold of the whole shooting match of Su-27 releases as hosted on the Archive.

The image hosted is of the CD-ROM containing the videos, missions , etc, as well as versions 1.1 and 1.2 that were released prior to the definitive v 1.5 Squadron Commander’s Edition.

The disc image is 237MB big - big enough to fit on a CD-ROM, of course.

That said, as noted previously - most of this is video in AVI file format, the graphically rich manual (which is big), as well as all sorts of extras. The core simulation is - dinky at 12MB (Sim + mission files)

Feel free to get it here : Su-27 Flanker : Free Download, Borrow, and Streaming : Internet Archive","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/h4doqsazp3ylxrfe', 'title': 'Why were old games programmed in assembly when higher level languages existed?', 'score': {'original': 0.7571, 'ai': 0.2429}, 'blocks': [{'text': 'Hello there,\n\nThere is a yet top-notch flight simulation which was hand-coded in 32-bit Intel i386 Assembly language, and has a number of pilots flying it even yet - including me.\n\nIt’s this :\n\nSu-27 Flanker for Windows 95\n\nDon’t let its age stop you - this is a crisp jet flight combat simulator with detail enough to be fascinating even now - and its story contains a twist or two that should demonstrate why assembly coding a game remains an admired high art, even into the present day.\n\nWhy was it coded in Assembly language? Well, after you see the features list, the reasons make the application - on modernish hardware and software - admirable.\n\nModelled Features - all good btw.\n\nComprehensive, fluid-dynamic modelling of the Su-27 for a very accurate simulation of flight and physics. Your Flanker even pulls contrails, and gas-flow dynamics for accurate stall, turn and flight simulation are delivered in real-time - quite an achievement for a Pentium-1 class machine for which the software was designed.\nEqually detailed modelling of other aircraft, ships, ground units, SAMs. All flight surfaces move, the wheel steering works - in short, all possible detail is modelled with dramatic accuracy.\nThe operational area, the Crimean peninsula, is modelled down to the level of powerlines and cars on the road.\nLighting is dynamic, for different times of day, and year. Clouds, while basic, are compelling to look at and fly.\nReal time Goraud-shaded polygonal graphics, which while ancient today, remain crisp and rapid to render on even the most basic hardware back then.\nThe cockpit features a set of instruments which work with the detail of the real thing.\nMost important of all - there is NO lag, and NO impact to speed when running possibly hundreds of objects simultaneously! It’s full speed all the way - and to the sim pilot this is endearing and impressive.\n\nNow for the twists :\n\nBecause it is 32-bit Assembly coded, the entire program is TINY - only 12 Megabytes in total ! This is dramatic, insofar as all its competitors were at the time huge - the smallest near-equivalent was literally 10 times the size, disk wise!\nIts origin should give you pause - the reason that SAM and Weapon performance is so incredibly accurate is that it began life as a Weapons Simulation Trainer for the Russian Air Force! Yup, this software is a piece of Surplus MILITARY Software!\n\nAnd entire Su-27 v1.5 installation occupies a princely 30 megabytes of disk space - over half of which is the manual! Then, the mission files themselves (and they can be very dense in terms of units etc.) are kilobytes in size, thanks again to them being encoded in an assembly-language compatible format for processing.\n\nFinally - I can and do run it seamlessly on my Windows 10 PC, as the application is directly addressing the CPU in i386 mode, for all the performance it needs.\n\nIt is, to the best of my knowledge, one of the last hand-coded games made in Assembly Language, and one of the most impressive, as it clearly utilising this program stategy for maximum performance and impact.\n\nIts legacy is with', 'result': {'fake': 0.2226, 'real': 0.7774}, 'status': 'success'}, {'text': 'us yet in the form of Lock-On: Modern Air Combat, and of course DCS World - which are its lineal descendants.\n\nMy 2c worth, and kind regards.\n\nAddendum -\n\nFor all those interested, it is possible today to get hold of the whole shooting match of Su-27 releases as hosted on the Archive.\n\nThe image hosted is of the CD-ROM containing the videos, missions , etc, as well as versions 1.1 and 1.2 that were released prior to the definitive v 1.5 Squadron Commander’s Edition.\n\nThe disc image is 237MB big - big enough to fit on a CD-ROM, of course.\n\nThat said, as noted previously - most of this is video in AVI file format, the graphically rich manual (which is big), as well as all sorts of extras. The core simulation is - dinky at 12MB (Sim + mission files)\n\nFeel free to get it here : Su-27 Flanker : Free Download, Borrow, and Streaming : Internet Archive', 'result': {'fake': 0.2924, 'real': 0.7076}, 'status': 'success'}], 'credits_used': 7, 'credits': 1983678, 'subscription': 0, 'content': 'Hello there,\n\nThere is a yet top-notch flight simulation which was hand-coded in 32-bit Intel i386 Assembly language, and has a number of pilots flying it even yet - including me.\n\nIt’s this :\n\nSu-27 Flanker for Windows 95\n\nDon’t let its age stop you - this is a crisp jet flight combat simulator with detail enough to be fascinating even now - and its story contains a twist or two that should demonstrate why assembly coding a game remains an admired high art, even into the present day.\n\nWhy was it coded in Assembly language? Well, after you see the features list, the reasons make the application - on modernish hardware and software - admirable.\n\nModelled Features - all good btw.\n\nComprehensive, fluid-dynamic modelling of the Su-27 for a very accurate simulation of flight and physics. Your Flanker even pulls contrails, and gas-flow dynamics for accurate stall, turn and flight simulation are delivered in real-time - quite an achievement for a Pentium-1 class machine for which the software was designed.\nEqually detailed modelling of other aircraft, ships, ground units, SAMs. All flight surfaces move, the wheel steering works - in short, all possible detail is modelled with dramatic accuracy.\nThe operational area, the Crimean peninsula, is modelled down to the level of powerlines and cars on the road.\nLighting is dynamic, for different times of day, and year. Clouds, while basic, are compelling to look at and fly.\nReal time Goraud-shaded polygonal graphics, which while ancient today, remain crisp and rapid to render on even the most basic hardware back then.\nThe cockpit features a set of instruments which work with the detail of the real thing.\nMost important of all - there is NO lag, and NO impact to speed when running possibly hundreds of objects simultaneously! It’s full speed all the way - and to the sim pilot this is endearing and impressive.\n\nNow for the twists :\n\nBecause it is 32-bit Assembly coded, the entire program is TINY - only 12 Megabytes in total ! This is dramatic, insofar as all its competitors were at the time huge - the smallest near-equivalent was literally 10 times the size, disk wise!\nIts origin should give you pause - the reason that SAM and Weapon performance is so incredibly accurate is that it began life as a Weapons Simulation Trainer for the Russian Air Force! Yup, this software is a piece of Surplus MILITARY Software!\n\nAnd entire Su-27 v1.5 installation occupies a princely 30 megabytes of disk space - over half of which is the manual! Then, the mission files themselves (and they can be very dense in terms of units etc.) are kilobytes in size, thanks again to them being encoded in an assembly-language compatible format for processing.\n\nFinally - I can and do run it seamlessly on my Windows 10 PC, as the application is directly addressing the CPU in i386 mode, for all the performance it needs.\n\nIt is, to the best of my knowledge, one of the last hand-coded games made in Assembly Language, and one of the most impressive, as it clearly utilising this program stategy for maximum performance and impact.\n\nIts legacy is with us yet in the form of Lock-On: Modern Air Combat, and of course DCS World - which are its lineal descendants.\n\nMy 2c worth, and kind regards.\n\nAddendum -\n\nFor all those interested, it is possible today to get hold of the whole shooting match of Su-27 releases as hosted on the Archive.\n\nThe image hosted is of the CD-ROM containing the videos, missions , etc, as well as versions 1.1 and 1.2 that were released prior to the definitive v 1.5 Squadron Commander’s Edition.\n\nThe disc image is 237MB big - big enough to fit on a CD-ROM, of course.\n\nThat said, as noted previously - most of this is video in AVI file format, the graphically rich manual (which is big), as well as all sorts of extras. The core simulation is - dinky at 12MB (Sim + mission files)\n\nFeel free to get it here : Su-27 Flanker : Free Download, Borrow, and Streaming : Internet Archive', 'aiModelVersion': '1'}",0.7571
Alan Mellor,5y,"What is considered good code to rookie programmers, but mediocre to professionals?","Anything terse and/or hard to read, for me.

As a rookie, I used to enjoy it when friends read my code and I had to explain to them how it worked. I enjoyed telling the tale of how I’d shaved a cycle off and saved a byte by using this loophole I’d found.

It made me feel terribly clever and accomplished.

Now, I just feel a failure.

I have not captured my thoughts in the code, which is all there is for the rest of the team to see.

Clever, to me, is putting the effort into writing your code so that it is self-explanatory. So I can see the essence of the problem you solved, why and then how.

That’s the biggest change for me.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/sm6w51gpqych3flo', 'title': 'What is considered good code to rookie programmers, but mediocre to professionals?', 'score': {'original': 0.9984, 'ai': 0.0016}, 'blocks': [{'text': 'Anything terse and/or hard to read, for me.\n\nAs a rookie, I used to enjoy it when friends read my code and I had to explain to them how it worked. I enjoyed telling the tale of how I’d shaved a cycle off and saved a byte by using this loophole I’d found.\n\nIt made me feel terribly clever and accomplished.\n\nNow, I just feel a failure.\n\nI have not captured my thoughts in the code, which is all there is for the rest of the team to see.\n\nClever, to me, is putting the effort into writing your code so that it is self-explanatory. So I can see the essence of the problem you solved, why and then how.\n\nThat’s the biggest change for me.', 'result': {'fake': 0.0016, 'real': 0.9984}, 'status': 'success'}], 'credits_used': 2, 'credits': 1983676, 'subscription': 0, 'content': 'Anything terse and/or hard to read, for me.\n\nAs a rookie, I used to enjoy it when friends read my code and I had to explain to them how it worked. I enjoyed telling the tale of how I’d shaved a cycle off and saved a byte by using this loophole I’d found.\n\nIt made me feel terribly clever and accomplished.\n\nNow, I just feel a failure.\n\nI have not captured my thoughts in the code, which is all there is for the rest of the team to see.\n\nClever, to me, is putting the effort into writing your code so that it is self-explanatory. So I can see the essence of the problem you solved, why and then how.\n\nThat’s the biggest change for me.', 'aiModelVersion': '1'}",0.9984
Ashish Kedia,Updated 6y,How do you balance college with competitive programming? How many hours do you train daily?,"It was hard for me. Maintaining a good grade and doing good in competitive programming is hard. At times, I even thought of giving up one of these because I was burned out.

I had a decent academic performance in my undergrad. I used to take assignments, practicals and tests extremely seriously for most part of my engineering. This meant investing a lot of time. A part of that time felt like a waste to me since I was not learning anything new in that time. On the other side, competitive programming was tempting. It gave me that much needed adrenalin rush. During the time when I was getting comfortable with the academic pressure in university, competitive programming added a new dimension to my learning.

Do competitive programming at night. That’s when you can really focus. Social Life, Good Grades, Competitive Programming -> You can choose only 2 out of them.
Invest time where you think you are learning more. “Perfectionist” often fail to see the bigger scheme of things. There is no point in beautifying you code, it will never be read or used again. Your 100-page report can have a few spelling mistakes. Get over it. You do not have to make it pixel perfect. Especially, when you are not gaining out of your hard work.
Competitive programming is more of a mental exercise. You can think of the solutions even when you are not in-front of computer. You should try to squeeze out time from different parts of your day.
During semester exams, one should prioritize academics. Grades matter for majority of students. If you have multiple backlogs, you will find it difficult to find an employer.
Summer / Winter breaks are best times to focus on competitive programming. You have no academic pressure. You can devote your whole day to competitive programming.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/4zn3vblj8rgc615w', 'title': 'How do you balance college with competitive programming? How many hours do you train daily?', 'score': {'original': 0.9999, 'ai': 0.0001}, 'blocks': [{'text': 'It was hard for me. Maintaining a good grade and doing good in competitive programming is hard. At times, I even thought of giving up one of these because I was burned out.\n\nI had a decent academic performance in my undergrad. I used to take assignments, practicals and tests extremely seriously for most part of my engineering. This meant investing a lot of time. A part of that time felt like a waste to me since I was not learning anything new in that time. On the other side, competitive programming was tempting. It gave me that much needed adrenalin rush. During the time when I was getting comfortable with the academic pressure in university, competitive programming added a new dimension to my learning.\n\nDo competitive programming at night. That’s when you can really focus. Social Life, Good Grades, Competitive Programming -> You can choose only 2 out of them.\nInvest time where you think you are learning more. “Perfectionist” often fail to see the bigger scheme of things. There is no point in beautifying you code, it will never be read or used again. Your 100-page report can have a few spelling mistakes. Get over it. You do not have to make it pixel perfect. Especially, when you are not gaining out of your hard work.\nCompetitive programming is more of a mental exercise. You can think of the solutions even when you are not in-front of computer. You should try to squeeze out time from different parts of your day.\nDuring semester exams, one should prioritize academics. Grades matter for majority of students. If you have multiple backlogs, you will find it difficult to find an employer.\nSummer / Winter breaks are best times to focus on competitive programming. You have no academic pressure. You can devote your whole day to competitive programming.', 'result': {'fake': 0.0001, 'real': 0.9999}, 'status': 'success'}], 'credits_used': 4, 'credits': 1983672, 'subscription': 0, 'content': 'It was hard for me. Maintaining a good grade and doing good in competitive programming is hard. At times, I even thought of giving up one of these because I was burned out.\n\nI had a decent academic performance in my undergrad. I used to take assignments, practicals and tests extremely seriously for most part of my engineering. This meant investing a lot of time. A part of that time felt like a waste to me since I was not learning anything new in that time. On the other side, competitive programming was tempting. It gave me that much needed adrenalin rush. During the time when I was getting comfortable with the academic pressure in university, competitive programming added a new dimension to my learning.\n\nDo competitive programming at night. That’s when you can really focus. Social Life, Good Grades, Competitive Programming -> You can choose only 2 out of them.\nInvest time where you think you are learning more. “Perfectionist” often fail to see the bigger scheme of things. There is no point in beautifying you code, it will never be read or used again. Your 100-page report can have a few spelling mistakes. Get over it. You do not have to make it pixel perfect. Especially, when you are not gaining out of your hard work.\nCompetitive programming is more of a mental exercise. You can think of the solutions even when you are not in-front of computer. You should try to squeeze out time from different parts of your day.\nDuring semester exams, one should prioritize academics. Grades matter for majority of students. If you have multiple backlogs, you will find it difficult to find an employer.\nSummer / Winter breaks are best times to focus on competitive programming. You have no academic pressure. You can devote your whole day to competitive programming.', 'aiModelVersion': '1'}",0.9999
Alan Kay,3y,What thought process would lead one to invent object-oriented programming?,"(Per Paul Hudson: “Maybe Alan Kay would answer. Since he did!”)

Well, OK.

In 1992, I was asked to write a history of what I actually did by the ACM for their second “History Of Programming Languages” conference. There are several versions online, including at Bret Victor’s site: “The Early History Of Smalltalk
”. This should satisfy those who want more detail.

For the purposes here for Quora, (a) I did coin the phrase “object oriented programming” for what I was working on in 1966, but (b) I thought of what I was doing was a kind of “rotation” and generalization of an idea I had seen in a variety of forms since my days as:

a biologist
then as a programmer in the Air Force starting in 1961: a way to make a “semantic file system”
then in the hardware of the B5000 computer
in the large, as processes in “multi-programmed” and “time-shared” operating systems
most startlingly in Ivan Sutherland’s Sketchpad
in a more prosaic practical form in Simula
and as done with entire computers on networks (as in the upcoming ARPAnet by my research community).

What hit me in Nov 1966 was ridiculously, absurdly simple: “that, if you can have enough computers which can intercommunicate, this is all you need to define anything that can be done on a computer by any other means”. This is because each computer is universal, etc.

Putting aside the practical difficulties — I was basically a lazy mathematician, so it was fairly easy to detach from the industrious pragmatist I had to be as a programmer — this was very attractive as an idea, because it scaled much better than the traditional ideas of procedures and data structures as building blocks.

And it was so much cleaner, and so much more amenable to whole systems designs.

And so amenable to thinking in terms of “designing and programming simulations”. This last was from the two systems I saw within a week of each other that pushed me over the edge: Sketchpad and the first Simula — both of which were essentially set up to simulate complex entities containing many interrelated processes.

Another very attractive feature of having everything being made from “semantic software computers intercommunicating via messaging” is that some ugly properties of “data” could not only be fixed, but even eliminated. For example, standard hardware and programming languages which map closely to them can give rise to simple arrays, but not to “data structures” that are just a little more complicated — like sparse matrices — and stacks and queues, etc. These are easy to do if these are instead “processes” and get to decide internally what the “assignment arrow” should mean.

And this can lead to something much nicer than “data” that still has state but no race conditions on it. For example, inside the object it can decide to version the histories if it wants, it can do “atomic transactions”, it can only allow viewing when all of its relationships are consistent. And many more. The data idea was always a bad one, and this new semantic building block would allow objects to progress through time — and “learn” etc. — but would be much safer.

And then there is the idea of simulation itself, where the whole idea of “data” and “state” starts to get eclipsed by “competent objects” that can cooperate, much more like biological cells and human societies can.

So, the thought processes that led to this were basically “systems thought processes” that were about being able to easily define systems of processes: any kinds of systems of any kinds of processes.

This will not resemble much of what most readers will associate with OOP — in the sense of language like C++, Java, etc.

Quite a bit of the disconnect is in point of view/perspective. C++ and Java etc. use objects mainly to define new things that are very like data structures, and the programming that is done is generally very data structure like (e.g. “setters” turn any kind of entity back into a data structure that can be imperatively munged by anyone). Technically, this is actually “Abstract Data Structures” and though a subset of what can be done with objects, is a divergence from the intent.

The picture I delineated above allows a good systems designer to design a good system and make it, even if very large. It’s obviously that much of the benefit of the idea will be lost if skilled systems design is not employed.

An important side point is that the strength and generality of the definitional aspects of this paradigm can be quite independent of programming style (this is the central key of what “simulation of systems” means).

An object can perfectly simulate a function, procedure, a data structure, etc., so everything old can be covered completely, but it can also simulate very smart agencies and agents, to provide much stronger ways of doing things.

The flaw in how things have played out is that very few in computing actually put in the effort to grok the implications of “universal scalable systems of processes”, and instead have clung to very old and poorly scalable ways to program.

At Parc, we got a tremendous boost in what we could conceive and write in very few lines of code because we tried to use as much as possible about what we understood about this new way to organize and program complex systems. (Today, there is more understood about this, but even the first time around, we were constantly amazed at what was possible.)","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/z81u0rospn2dkfcw', 'title': 'What thought process would lead one to invent object-oriented programming?', 'score': {'original': 0.3594, 'ai': 0.6406}, 'blocks': [{'text': '(Per Paul Hudson: “Maybe Alan Kay would answer. Since he did!”)\n\nWell, OK.\n\nIn 1992, I was asked to write a history of what I actually did by the ACM for their second “History Of Programming Languages” conference. There are several versions online, including at Bret Victor’s site: “The Early History Of Smalltalk\n”. This should satisfy those who want more detail.\n\nFor the purposes here for Quora, (a) I did coin the phrase “object oriented programming” for what I was working on in 1966, but (b) I thought of what I was doing was a kind of “rotation” and generalization of an idea I had seen in a variety of forms since my days as:\n\na biologist\nthen as a programmer in the Air Force starting in 1961: a way to make a “semantic file system”\nthen in the hardware of the B5000 computer\nin the large, as processes in “multi-programmed” and “time-shared” operating systems\nmost startlingly in Ivan Sutherland’s Sketchpad\nin a more prosaic practical form in Simula\nand as done with entire computers on networks (as in the upcoming ARPAnet by my research community).\n\nWhat hit me in Nov 1966 was ridiculously, absurdly simple: “that, if you can have enough computers which can intercommunicate, this is all you need to define anything that can be done on a computer by any other means”. This is because each computer is universal, etc.\n\nPutting aside the practical difficulties — I was basically a lazy mathematician, so it was fairly easy to detach from the industrious pragmatist I had to be as a programmer — this was very attractive as an idea, because it scaled much better than the traditional ideas of procedures and data structures as building blocks.\n\nAnd it was so much cleaner, and so much more amenable to whole systems designs.\n\nAnd so amenable to thinking in terms of “designing and programming simulations”. This last was from the two systems I saw within a week of each other that pushed me over the edge: Sketchpad and the first Simula — both of which were essentially set up to simulate complex entities containing many interrelated processes.\n\nAnother very attractive feature of having everything being made from “semantic software computers intercommunicating via messaging” is that some ugly properties of “data” could not only be fixed, but even eliminated. For example, standard hardware and programming languages which map closely to them can give rise to simple arrays, but not to “data structures” that are just a little more complicated — like sparse matrices — and stacks and queues, etc. These are easy to do if these are instead “processes” and get to decide internally what the “assignment arrow” should mean.\n\nAnd this can lead to something much nicer than “data” that still has state but no race conditions on it. For example, inside the object it can decide to version the histories if it wants, it can do “atomic transactions”, it can only allow viewing when all of its relationships are consistent. And many more. The data idea was always a bad one, and this new semantic building block would allow objects to progress through time — and “learn”', 'result': {'fake': 0.0384, 'real': 0.9616}, 'status': 'success'}, {'text': 'etc. — but would be much safer.\n\nAnd then there is the idea of simulation itself, where the whole idea of “data” and “state” starts to get eclipsed by “competent objects” that can cooperate, much more like biological cells and human societies can.\n\nSo, the thought processes that led to this were basically “systems thought processes” that were about being able to easily define systems of processes: any kinds of systems of any kinds of processes.\n\nThis will not resemble much of what most readers will associate with OOP — in the sense of language like C++, Java, etc.\n\nQuite a bit of the disconnect is in point of view/perspective. C++ and Java etc. use objects mainly to define new things that are very like data structures, and the programming that is done is generally very data structure like (e.g. “setters” turn any kind of entity back into a data structure that can be imperatively munged by anyone). Technically, this is actually “Abstract Data Structures” and though a subset of what can be done with objects, is a divergence from the intent.\n\nThe picture I delineated above allows a good systems designer to design a good system and make it, even if very large. It’s obviously that much of the benefit of the idea will be lost if skilled systems design is not employed.\n\nAn important side point is that the strength and generality of the definitional aspects of this paradigm can be quite independent of programming style (this is the central key of what “simulation of systems” means).\n\nAn object can perfectly simulate a function, procedure, a data structure, etc., so everything old can be covered completely, but it can also simulate very smart agencies and agents, to provide much stronger ways of doing things.\n\nThe flaw in how things have played out is that very few in computing actually put in the effort to grok the implications of “universal scalable systems of processes”, and instead have clung to very old and poorly scalable ways to program.\n\nAt Parc, we got a tremendous boost in what we could conceive and write in very few lines of code because we tried to use as much as possible about what we understood about this new way to organize and program complex systems. (Today, there is more understood about this, but even the first time around, we were constantly amazed at what was possible.)', 'result': {'fake': 0.3078, 'real': 0.6922}, 'status': 'success'}], 'credits_used': 10, 'credits': 1983662, 'subscription': 0, 'content': '(Per Paul Hudson: “Maybe Alan Kay would answer. Since he did!”)\n\nWell, OK.\n\nIn 1992, I was asked to write a history of what I actually did by the ACM for their second “History Of Programming Languages” conference. There are several versions online, including at Bret Victor’s site: “The Early History Of Smalltalk\n”. This should satisfy those who want more detail.\n\nFor the purposes here for Quora, (a) I did coin the phrase “object oriented programming” for what I was working on in 1966, but (b) I thought of what I was doing was a kind of “rotation” and generalization of an idea I had seen in a variety of forms since my days as:\n\na biologist\nthen as a programmer in the Air Force starting in 1961: a way to make a “semantic file system”\nthen in the hardware of the B5000 computer\nin the large, as processes in “multi-programmed” and “time-shared” operating systems\nmost startlingly in Ivan Sutherland’s Sketchpad\nin a more prosaic practical form in Simula\nand as done with entire computers on networks (as in the upcoming ARPAnet by my research community).\n\nWhat hit me in Nov 1966 was ridiculously, absurdly simple: “that, if you can have enough computers which can intercommunicate, this is all you need to define anything that can be done on a computer by any other means”. This is because each computer is universal, etc.\n\nPutting aside the practical difficulties — I was basically a lazy mathematician, so it was fairly easy to detach from the industrious pragmatist I had to be as a programmer — this was very attractive as an idea, because it scaled much better than the traditional ideas of procedures and data structures as building blocks.\n\nAnd it was so much cleaner, and so much more amenable to whole systems designs.\n\nAnd so amenable to thinking in terms of “designing and programming simulations”. This last was from the two systems I saw within a week of each other that pushed me over the edge: Sketchpad and the first Simula — both of which were essentially set up to simulate complex entities containing many interrelated processes.\n\nAnother very attractive feature of having everything being made from “semantic software computers intercommunicating via messaging” is that some ugly properties of “data” could not only be fixed, but even eliminated. For example, standard hardware and programming languages which map closely to them can give rise to simple arrays, but not to “data structures” that are just a little more complicated — like sparse matrices — and stacks and queues, etc. These are easy to do if these are instead “processes” and get to decide internally what the “assignment arrow” should mean.\n\nAnd this can lead to something much nicer than “data” that still has state but no race conditions on it. For example, inside the object it can decide to version the histories if it wants, it can do “atomic transactions”, it can only allow viewing when all of its relationships are consistent. And many more. The data idea was always a bad one, and this new semantic building block would allow objects to progress through time — and “learn” etc. — but would be much safer.\n\nAnd then there is the idea of simulation itself, where the whole idea of “data” and “state” starts to get eclipsed by “competent objects” that can cooperate, much more like biological cells and human societies can.\n\nSo, the thought processes that led to this were basically “systems thought processes” that were about being able to easily define systems of processes: any kinds of systems of any kinds of processes.\n\nThis will not resemble much of what most readers will associate with OOP — in the sense of language like C++, Java, etc.\n\nQuite a bit of the disconnect is in point of view/perspective. C++ and Java etc. use objects mainly to define new things that are very like data structures, and the programming that is done is generally very data structure like (e.g. “setters” turn any kind of entity back into a data structure that can be imperatively munged by anyone). Technically, this is actually “Abstract Data Structures” and though a subset of what can be done with objects, is a divergence from the intent.\n\nThe picture I delineated above allows a good systems designer to design a good system and make it, even if very large. It’s obviously that much of the benefit of the idea will be lost if skilled systems design is not employed.\n\nAn important side point is that the strength and generality of the definitional aspects of this paradigm can be quite independent of programming style (this is the central key of what “simulation of systems” means).\n\nAn object can perfectly simulate a function, procedure, a data structure, etc., so everything old can be covered completely, but it can also simulate very smart agencies and agents, to provide much stronger ways of doing things.\n\nThe flaw in how things have played out is that very few in computing actually put in the effort to grok the implications of “universal scalable systems of processes”, and instead have clung to very old and poorly scalable ways to program.\n\nAt Parc, we got a tremendous boost in what we could conceive and write in very few lines of code because we tried to use as much as possible about what we understood about this new way to organize and program complex systems. (Today, there is more understood about this, but even the first time around, we were constantly amazed at what was possible.)', 'aiModelVersion': '1'}",0.3594
Joe Zbiciak,4y,Why should we use recursion in programming languages if we could just use for and while loops instead?,"You could always use loops instead of recursion.

Try writing a binary tree traversal as a loop sometime. It's not difficult, although you may be surprised by some of the corner conditions you encounter. Then compare it to the recursive function implementation. Which one is clearer and easier to follow?

With the loop-based version, it turns out that you still have recursion. It's just data recursion. You have to build a stack manually. With code recursion, the compiler does it for you.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/aw6q1hxcbe4zjsk0', 'title': 'Why should we use recursion in programming languages if we could just use for and while loops instead?', 'score': {'original': 0.9594, 'ai': 0.0406}, 'blocks': [{'text': ""You could always use loops instead of recursion.\n\nTry writing a binary tree traversal as a loop sometime. It's not difficult, although you may be surprised by some of the corner conditions you encounter. Then compare it to the recursive function implementation. Which one is clearer and easier to follow?\n\nWith the loop-based version, it turns out that you still have recursion. It's just data recursion. You have to build a stack manually. With code recursion, the compiler does it for you."", 'result': {'fake': 0.0406, 'real': 0.9594}, 'status': 'success'}], 'credits_used': 1, 'credits': 1983661, 'subscription': 0, 'content': ""You could always use loops instead of recursion.\n\nTry writing a binary tree traversal as a loop sometime. It's not difficult, although you may be surprised by some of the corner conditions you encounter. Then compare it to the recursive function implementation. Which one is clearer and easier to follow?\n\nWith the loop-based version, it turns out that you still have recursion. It's just data recursion. You have to build a stack manually. With code recursion, the compiler does it for you."", 'aiModelVersion': '1'}",0.9594
