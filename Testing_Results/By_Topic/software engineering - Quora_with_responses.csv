Authors,Time,Questions,Answers,api_response,originality_score
Anonymous,Updated 5y,Is it true that road-side food stall owners earn more than average software engineers in India?,"Yes, my dad is one of them. Writing here anonymously as I don’t want to reveal my identity and also I know I will get more bashing from you guys for this answer.

I’m now 22years old. In the year 1999, my dad lost his job in a cotton mill as supervisor. He has 6 siblings and he is the youngest of them. He left all his relatives in hometown and came to Bangalore with my mom and me.

I need to explain my dad’s characteristics here. He has entrepreneurial ability from childhood and a foodie by gene. He thought restaurant is the right profession for him and Bangalore was that time growing city with a lot of opportunities. He also knows my mom as a good cook. He also had some cash with him which my mom’s dad gave him as dowry.

With that cash he started a roadside 4 wheeler cart shop which sells only ‘Thatte idly’ along with chutneys and Sambar. In Bangalore, there are a lot of Tamilians and North Indians who likes Tamil style sambar which was very rare to get that time. Being a Tamilian, my dad makes that kind of Sambar and it was an instant hit it seems. IT people also started coming to our carts as my dad made sure the food served there is with good hygiene.

He soon opened a juice shop called ‘Ganesh juice corner’ and employed my dad’s siblings. Long story short in 7 years he managed to open 5 idly carts and 4 juice shops in the city. Till this time he never had a PAN card and never paid tax for his earnings. He is very generous and employed all our family members in our businesses.

It was in the year 2009 he thought of taking his business to next level. He visited some factories in China and bought doughnut, churros , popcorn making machines. He started new business model by renting out these for a day and made money out of those. So all those popcorn vendors you see Bangalore, most of them are employed by my father. They rent our machines for 1000 a day and they make profit around 500 everyday.

Coming back to the current situation, he is earning more than 8 lakhs per month and started paying taxes a few years back. My dad made me enroll in one of the top private BSchools in a dream that I will take his business to next level.

I know being with him will give me more knowledge than any MBA degree.

Edit: Sorry guys for not replying to your comments. I just came to quora today after 4 days and still going through your comments.

Thought of quickly answer to couple of common questions - There are many Ganesh juice shops in Bangalore and everything is not own by us and my dad was not the first one to start that brand.

Why am I anonymous - my dad has faced too much hatred in his life. People assume things as he got quick growth financially. There were many cheaters, back stabbers he had to come across everyday in his life. We believe in living simple and he made sure we never show off of what we have. Even in my friends circle, I’m known only as a middle class person inspite of my dad earning much.

Finally, one common thing I noticed in your comments, which I want to clarify. You guys assumed me as a guy may be because I told that I’m doing MBA. I’m a girl - daddy’s girl :) He never treated me differently than my brother and gave me all the privileges in studies and understanding his businesses. I used to spend weekends with him working in all our shops so as my little brother.

P.S: I don’t bother about any negative comments about my father and I don’t care replying to that.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/184h7jmzdl6xqt3p', 'title': 'Is it true that road-side food stall owners earn more than average software engineers in India?', 'score': {'original': 0.7251, 'ai': 0.2749}, 'blocks': [{'text': 'Yes, my dad is one of them. Writing here anonymously as I don’t want to reveal my identity and also I know I will get more bashing from you guys for this answer.\n\nI’m now 22years old. In the year 1999, my dad lost his job in a cotton mill as supervisor. He has 6 siblings and he is the youngest of them. He left all his relatives in hometown and came to Bangalore with my mom and me.\n\nI need to explain my dad’s characteristics here. He has entrepreneurial ability from childhood and a foodie by gene. He thought restaurant is the right profession for him and Bangalore was that time growing city with a lot of opportunities. He also knows my mom as a good cook. He also had some cash with him which my mom’s dad gave him as dowry.\n\nWith that cash he started a roadside 4 wheeler cart shop which sells only ‘Thatte idly’ along with chutneys and Sambar. In Bangalore, there are a lot of Tamilians and North Indians who likes Tamil style sambar which was very rare to get that time. Being a Tamilian, my dad makes that kind of Sambar and it was an instant hit it seems. IT people also started coming to our carts as my dad made sure the food served there is with good hygiene.\n\nHe soon opened a juice shop called ‘Ganesh juice corner’ and employed my dad’s siblings. Long story short in 7 years he managed to open 5 idly carts and 4 juice shops in the city. Till this time he never had a PAN card and never paid tax for his earnings. He is very generous and employed all our family members in our businesses.\n\nIt was in the year 2009 he thought of taking his business to next level. He visited some factories in China and bought doughnut, churros , popcorn making machines. He started new business model by renting out these for a day and made money out of those. So all those popcorn vendors you see Bangalore, most of them are employed by my father. They rent our machines for 1000 a day and they make profit around 500 everyday.\n\nComing back to the current situation, he is earning more than 8 lakhs per month and started paying taxes a few years back. My dad made me enroll in one of the top private BSchools in a dream that I will take his business to next level.\n\nI know being with him will give me more knowledge than any MBA degree.\n\nEdit: Sorry guys for not replying to your comments. I just came to quora today after 4 days and still going through your comments.\n\nThought of quickly answer to couple of common questions - There are many Ganesh juice shops in Bangalore and everything is not own by us and my dad was not the first one to start that brand.\n\nWhy am I anonymous - my dad has faced too much hatred in his life. People assume things as he got quick growth financially. There were many cheaters, back stabbers he', 'result': {'fake': 0.3088, 'real': 0.6912}, 'status': 'success'}, {'text': 'had to come across everyday in his life. We believe in living simple and he made sure we never show off of what we have. Even in my friends circle, I’m known only as a middle class person inspite of my dad earning much.\n\nFinally, one common thing I noticed in your comments, which I want to clarify. You guys assumed me as a guy may be because I told that I’m doing MBA. I’m a girl - daddy’s girl :) He never treated me differently than my brother and gave me all the privileges in studies and understanding his businesses. I used to spend weekends with him working in all our shops so as my little brother.\n\nP.S: I don’t bother about any negative comments about my father and I don’t care replying to that.', 'result': {'fake': 0.6929, 'real': 0.3071}, 'status': 'success'}], 'credits_used': 7, 'credits': 1984380, 'subscription': 0, 'content': 'Yes, my dad is one of them. Writing here anonymously as I don’t want to reveal my identity and also I know I will get more bashing from you guys for this answer.\n\nI’m now 22years old. In the year 1999, my dad lost his job in a cotton mill as supervisor. He has 6 siblings and he is the youngest of them. He left all his relatives in hometown and came to Bangalore with my mom and me.\n\nI need to explain my dad’s characteristics here. He has entrepreneurial ability from childhood and a foodie by gene. He thought restaurant is the right profession for him and Bangalore was that time growing city with a lot of opportunities. He also knows my mom as a good cook. He also had some cash with him which my mom’s dad gave him as dowry.\n\nWith that cash he started a roadside 4 wheeler cart shop which sells only ‘Thatte idly’ along with chutneys and Sambar. In Bangalore, there are a lot of Tamilians and North Indians who likes Tamil style sambar which was very rare to get that time. Being a Tamilian, my dad makes that kind of Sambar and it was an instant hit it seems. IT people also started coming to our carts as my dad made sure the food served there is with good hygiene.\n\nHe soon opened a juice shop called ‘Ganesh juice corner’ and employed my dad’s siblings. Long story short in 7 years he managed to open 5 idly carts and 4 juice shops in the city. Till this time he never had a PAN card and never paid tax for his earnings. He is very generous and employed all our family members in our businesses.\n\nIt was in the year 2009 he thought of taking his business to next level. He visited some factories in China and bought doughnut, churros , popcorn making machines. He started new business model by renting out these for a day and made money out of those. So all those popcorn vendors you see Bangalore, most of them are employed by my father. They rent our machines for 1000 a day and they make profit around 500 everyday.\n\nComing back to the current situation, he is earning more than 8 lakhs per month and started paying taxes a few years back. My dad made me enroll in one of the top private BSchools in a dream that I will take his business to next level.\n\nI know being with him will give me more knowledge than any MBA degree.\n\nEdit: Sorry guys for not replying to your comments. I just came to quora today after 4 days and still going through your comments.\n\nThought of quickly answer to couple of common questions - There are many Ganesh juice shops in Bangalore and everything is not own by us and my dad was not the first one to start that brand.\n\nWhy am I anonymous - my dad has faced too much hatred in his life. People assume things as he got quick growth financially. There were many cheaters, back stabbers he had to come across everyday in his life. We believe in living simple and he made sure we never show off of what we have. Even in my friends circle, I’m known only as a middle class person inspite of my dad earning much.\n\nFinally, one common thing I noticed in your comments, which I want to clarify. You guys assumed me as a guy may be because I told that I’m doing MBA. I’m a girl - daddy’s girl :) He never treated me differently than my brother and gave me all the privileges in studies and understanding his businesses. I used to spend weekends with him working in all our shops so as my little brother.\n\nP.S: I don’t bother about any negative comments about my father and I don’t care replying to that.', 'aiModelVersion': '1'}",0.7251
Lucas Radaelli,8y,How does a visually impaired computer programmer program?,"I am totally blind and I work for Google, writing changes to the ranking algorithm. As part of my experience, and I believe from many other blind programmers, the way that we program is not that different from our sighted colleagues. I use most of the time a text editor (which is emacs and an extension called emacspeak, which makes emacs talk), and a browser to look some internal pages of Google with documentation and stuff.

The main difference here is that we either hear what is on the screen, or read with the help of a braille display. I can not comment on using a braille display because I have never had one in my life (too expensive), but I can give some idea how is to program just hearing.

The biggest challenge of programming just by ear is that you need to memorize a lot of stuff. You move line by line, hearing the entire line. You can move word by word and hear them, or character by character. The point is, you see, at a given time, just a small fraction of what is on the screen. You can't start programming, look up in the function definition what is the name of the variable being passed. You memorize it. If you want to check the function definition, again, I would set a marker, look for the definition, read it, and come back. As you can notice, this may take a few precious seconds, so improving your memory skills is a good thing here.

I like to program with emacspeak because it gives me a lot of cool things when programming in c++, for example. In this program there is the notion of voice styles, and it will read variables, functions and different element of the language with a voice with a different pitch. This makes things easier to identify what is what. consider this as the audio highlighting of code.

As a last comment, a curiosity:
Blind programmers do not use indentation. We normally finish the code and indent it later, as it brings no advantage for us.
then you might ask:
what about python?
I like python a lot, and even the indentation part does not make me thing differently. I create some techniques, like, jump a line at the end of each indentation block, so I can know very fast when the block has ended. When reading code from others, I can set an option in my screen reader to tell the indentation level, but I find this a little bit annoying, because for each line that you read, it will say the number of spaces present on that line.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/g4eliwk7fzsbv396', 'title': 'How does a visually impaired computer programmer program?', 'score': {'original': 0.9999, 'ai': 0.0001}, 'blocks': [{'text': ""I am totally blind and I work for Google, writing changes to the ranking algorithm. As part of my experience, and I believe from many other blind programmers, the way that we program is not that different from our sighted colleagues. I use most of the time a text editor (which is emacs and an extension called emacspeak, which makes emacs talk), and a browser to look some internal pages of Google with documentation and stuff.\n\nThe main difference here is that we either hear what is on the screen, or read with the help of a braille display. I can not comment on using a braille display because I have never had one in my life (too expensive), but I can give some idea how is to program just hearing.\n\nThe biggest challenge of programming just by ear is that you need to memorize a lot of stuff. You move line by line, hearing the entire line. You can move word by word and hear them, or character by character. The point is, you see, at a given time, just a small fraction of what is on the screen. You can't start programming, look up in the function definition what is the name of the variable being passed. You memorize it. If you want to check the function definition, again, I would set a marker, look for the definition, read it, and come back. As you can notice, this may take a few precious seconds, so improving your memory skills is a good thing here.\n\nI like to program with emacspeak because it gives me a lot of cool things when programming in c++, for example. In this program there is the notion of voice styles, and it will read variables, functions and different element of the language with a voice with a different pitch. This makes things easier to identify what is what. consider this as the audio highlighting of code.\n\nAs a last comment, a curiosity:\nBlind programmers do not use indentation. We normally finish the code and indent it later, as it brings no advantage for us.\nthen you might ask:\nwhat about python?\nI like python a lot, and even the indentation part does not make me thing differently. I create some techniques, like, jump a line at the end of each indentation block, so I can know very fast when the block has ended. When reading code from others, I can set an option in my screen reader to tell the indentation level, but I find this a little bit annoying, because for each line that you read, it will say the number of spaces present on that line."", 'result': {'fake': 0.0001, 'real': 0.9999}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984375, 'subscription': 0, 'content': ""I am totally blind and I work for Google, writing changes to the ranking algorithm. As part of my experience, and I believe from many other blind programmers, the way that we program is not that different from our sighted colleagues. I use most of the time a text editor (which is emacs and an extension called emacspeak, which makes emacs talk), and a browser to look some internal pages of Google with documentation and stuff.\n\nThe main difference here is that we either hear what is on the screen, or read with the help of a braille display. I can not comment on using a braille display because I have never had one in my life (too expensive), but I can give some idea how is to program just hearing.\n\nThe biggest challenge of programming just by ear is that you need to memorize a lot of stuff. You move line by line, hearing the entire line. You can move word by word and hear them, or character by character. The point is, you see, at a given time, just a small fraction of what is on the screen. You can't start programming, look up in the function definition what is the name of the variable being passed. You memorize it. If you want to check the function definition, again, I would set a marker, look for the definition, read it, and come back. As you can notice, this may take a few precious seconds, so improving your memory skills is a good thing here.\n\nI like to program with emacspeak because it gives me a lot of cool things when programming in c++, for example. In this program there is the notion of voice styles, and it will read variables, functions and different element of the language with a voice with a different pitch. This makes things easier to identify what is what. consider this as the audio highlighting of code.\n\nAs a last comment, a curiosity:\nBlind programmers do not use indentation. We normally finish the code and indent it later, as it brings no advantage for us.\nthen you might ask:\nwhat about python?\nI like python a lot, and even the indentation part does not make me thing differently. I create some techniques, like, jump a line at the end of each indentation block, so I can know very fast when the block has ended. When reading code from others, I can set an option in my screen reader to tell the indentation level, but I find this a little bit annoying, because for each line that you read, it will say the number of spaces present on that line."", 'aiModelVersion': '1'}",0.9999
Alan Mellor,2y,"Is coding going to be obsolete in the near future? With the announcement of GitHub copilot, I fear that this might be the case.","Nope, and copilot proves it.

Copilot does an ok job of filling in a method - if (and only if) you write a clear enough description of it as a comment.

What copilot does not do is tell you what method to write next. Or what class. Or what the responsibility splits should be. Or when to use an interface. Or whether the coupling is too high. Or the cyclomatic complexity. Or how to test. Or what for.

In short, copilot does zero programming.

Novice see that code inside a function is being spat out. After you’ve designed a few software systems, you see that this is the least important set of decisions you can make - the inside of the function. What it is responsible for, and how it links to the rest of the code is programming.

Once I can just press enter on copilot, and it write the next method, next class, next database DDL script, next dockerfile, next terraform, next unit test, next integration test - then I’ll pay attention. From the dole queue.

Not before.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/61ypqb2zfrgc0jdx', 'title': 'Is coding going to be obsolete in the near future? With the announcement of GitHub copilot, I fear that this might be the case.', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Nope, and copilot proves it.\n\nCopilot does an ok job of filling in a method - if (and only if) you write a clear enough description of it as a comment.\n\nWhat copilot does not do is tell you what method to write next. Or what class. Or what the responsibility splits should be. Or when to use an interface. Or whether the coupling is too high. Or the cyclomatic complexity. Or how to test. Or what for.\n\nIn short, copilot does zero programming.\n\nNovice see that code inside a function is being spat out. After you’ve designed a few software systems, you see that this is the least important set of decisions you can make - the inside of the function. What it is responsible for, and how it links to the rest of the code is programming.\n\nOnce I can just press enter on copilot, and it write the next method, next class, next database DDL script, next dockerfile, next terraform, next unit test, next integration test - then I’ll pay attention. From the dole queue.\n\nNot before.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984373, 'subscription': 0, 'content': 'Nope, and copilot proves it.\n\nCopilot does an ok job of filling in a method - if (and only if) you write a clear enough description of it as a comment.\n\nWhat copilot does not do is tell you what method to write next. Or what class. Or what the responsibility splits should be. Or when to use an interface. Or whether the coupling is too high. Or the cyclomatic complexity. Or how to test. Or what for.\n\nIn short, copilot does zero programming.\n\nNovice see that code inside a function is being spat out. After you’ve designed a few software systems, you see that this is the least important set of decisions you can make - the inside of the function. What it is responsible for, and how it links to the rest of the code is programming.\n\nOnce I can just press enter on copilot, and it write the next method, next class, next database DDL script, next dockerfile, next terraform, next unit test, next integration test - then I’ll pay attention. From the dole queue.\n\nNot before.', 'aiModelVersion': '1'}",0.9998
Kurt Guntheroth,5y,What is your favorite software bug/fault horror story?,"Debugging a C language program containing a hand-written mark-sweep garbage collector. Under the right conditions, a function would crash the third time it was invoked.

The bug itself wasn’t so bad. It did take me five days to find it, looking for clues through a 5Mb log file. That wasn’t so bad. What was horrible was my boss’s boss sitting in my office, saying, “Kurt, we really need to find this bug. Whatever resources you need, let me know. Kurt, we really need to find this bug…” I knew perfectly well that the only thing that was going to find this bug was me patiently looking for clues until I figured it out. Nobody else knew the code.

If you are ever tempted to sit in a co-worker’s office until he produces something, please don’t. Take my word for it, it doesn’t help.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/07sn9pu4yb6w5xoh', 'title': 'What is your favorite software bug/fault horror story?', 'score': {'original': 0.9988, 'ai': 0.0012}, 'blocks': [{'text': 'Debugging a C language program containing a hand-written mark-sweep garbage collector. Under the right conditions, a function would crash the third time it was invoked.\n\nThe bug itself wasn’t so bad. It did take me five days to find it, looking for clues through a 5Mb log file. That wasn’t so bad. What was horrible was my boss’s boss sitting in my office, saying, “Kurt, we really need to find this bug. Whatever resources you need, let me know. Kurt, we really need to find this bug…” I knew perfectly well that the only thing that was going to find this bug was me patiently looking for clues until I figured it out. Nobody else knew the code.\n\nIf you are ever tempted to sit in a co-worker’s office until he produces something, please don’t. Take my word for it, it doesn’t help.', 'result': {'fake': 0.0012, 'real': 0.9988}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984371, 'subscription': 0, 'content': 'Debugging a C language program containing a hand-written mark-sweep garbage collector. Under the right conditions, a function would crash the third time it was invoked.\n\nThe bug itself wasn’t so bad. It did take me five days to find it, looking for clues through a 5Mb log file. That wasn’t so bad. What was horrible was my boss’s boss sitting in my office, saying, “Kurt, we really need to find this bug. Whatever resources you need, let me know. Kurt, we really need to find this bug…” I knew perfectly well that the only thing that was going to find this bug was me patiently looking for clues until I figured it out. Nobody else knew the code.\n\nIf you are ever tempted to sit in a co-worker’s office until he produces something, please don’t. Take my word for it, it doesn’t help.', 'aiModelVersion': '1'}",0.9988
Anonymous,6y,Am I wasting my life as a software engineer in the US?,"As an engineer who came to India for good - I could highlight you on what I underwent during this process.

I went to US to do my Masters in 2006 and by 2008 I had an offer with one of the most reputed companies working on Virtual Machines. It was a tremendous opportunity with great package and stocks. I got married in few months and my wife and I enjoyed our times in Bay Area - visiting around CA and infact around US. We had an excellent set of friends and communities and trust me that was an ideal setup anyone would like to have.

Then what happened? Even if my best days in US and worst days in India - I never had a feeling that one was better than the other. It all belongs to the thought - “Where do you want to be? and Why?”. Trust me - it doesn’t matter if its India or US - people can survive and do well and both the lands have the ability to provide the people who land up there.

My wife and I were expecting our first born and it was the time my mom needed my presence with her. She wasn’t able to feel at ease in US, as she had always been an independent person, going around places herself. Age started catching with her and she was in no mood to explore things and adopt to new things and life style in US. She had been a great support for me and my growth in my life, despite my dad’s demise during my teens. Thankfully - we are a closely knitted family and the vibe between all 3 of us(my mom, myself and my wife) are good and my wife suggested me - if its just 3 of us - why cant we be together. Life provided us with good friends and people around. It took only 2 days for us to decide where we wanted to be. My wife and I said to ourselves - exactly 6 months from now - we will be in India. All I requested my mom was to move to a different city (From chennai to Bangalore) - as the opportunities are much better in the later, for which she happily agreed.

What I did before leaving US?

Spoke to my manager and asked for a transfer to Bangalore office. The team agreed and initiated it.
The day I said I wanted to move back to India - I got an email from the immigration team to submit the documents for the first stage of GreenCard (haha). My wife and I laughed reading that and I politely declined their offer quoting my transfer as the reason.
Tried getting hold of good Ob/Gyns doctors in India and ensured that there would be a good doctor to take care when my wife lands up in India - which we were able to get thankfully.
Helped my wife to go to India and we had our friends and relatives and my mom there who took care of her.
I sold my items, terminated my lease, distributed my items to my friends and left US.

What happened in India?

Reached India exactly 2 weeks before my first born entering our lives and spent the entire 2 weeks with my wife and mom.
After my son was born, I spent some time with him and started our move towards bangalore and setted up things in Bangalore. In 2 months all of them joined me there.
Bangalore truly contributed to my career life. I left the company ~ 2 years after I came here. Worked on several start-ups and I can confidently work anywhere and with anyone without any fear. I was able to make decisions fast - without the H1B/L1B fear and without cutting corners or yielding to petty politics. This is truly an advantage if you belong to a place where you can make “free” decisions. It doesn’t matter if its US or India. For me, I could make such decisions only in India.
Infact 2 of the companies that I worked in India offered me to transfer to US if I want. I politely declined it. One such conversation happened 2 months before.
My son is 7 years old now and while I’m writing this blog - my mom is talking about a funny incident that she underwent with my son to someone on the other side of the phone conversation with her. This would have not happened if I had been in US and I see true sense of happiness in this. Well this is what all of us wanted.
My wife had never been much interested with industry life - She found her passion with education and she is now working as a school teacher with a very successful record and she is working on getting her educational degrees parallely. Happy to see that she is super occupied and doing what she loves.
My career progressed towards Tech Manager role/Architect role and I’m enjoying the work culture here
I travel to US atleast once in an year for release meetings or to develop rapport between Bangalore and US teams. I spend time catching up with all my friends and we never missed each other.

Did I ever regret coming back to India?

No. Because - I never had a feeling that one country was better than the other, w.r.t to US and India and thankfully my wife was in the same wavelength. Its based on your requirements - you decide the place.

To answer your question

What do you want in life? Why US and why not India or vice-versa? Spend time contemplating on yourself and understand what will make you happy. As some say - The grass is always greener on the other side. I have seen a lot of folks coming to India, trying to imitate Mohan Bhargav (Thats the shahrukh khan’s name in Swades right? ;-) ) and ended up being a confused citizen than a clear immigrant. So, give yourself sometime - think twice thrice, even 100 times. But, never turn back on your decision once have decided concretely.

All the best!","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/chy2afwdi8e1s3z4', 'title': 'Am I wasting my life as a software engineer in the US?', 'score': {'original': 0.51556666666667, 'ai': 0.48443333333333}, 'blocks': [{'text': 'As an engineer who came to India for good - I could highlight you on what I underwent during this process.\n\nI went to US to do my Masters in 2006 and by 2008 I had an offer with one of the most reputed companies working on Virtual Machines. It was a tremendous opportunity with great package and stocks. I got married in few months and my wife and I enjoyed our times in Bay Area - visiting around CA and infact around US. We had an excellent set of friends and communities and trust me that was an ideal setup anyone would like to have.\n\nThen what happened? Even if my best days in US and worst days in India - I never had a feeling that one was better than the other. It all belongs to the thought - “Where do you want to be? and Why?”. Trust me - it doesn’t matter if its India or US - people can survive and do well and both the lands have the ability to provide the people who land up there.\n\nMy wife and I were expecting our first born and it was the time my mom needed my presence with her. She wasn’t able to feel at ease in US, as she had always been an independent person, going around places herself. Age started catching with her and she was in no mood to explore things and adopt to new things and life style in US. She had been a great support for me and my growth in my life, despite my dad’s demise during my teens. Thankfully - we are a closely knitted family and the vibe between all 3 of us(my mom, myself and my wife) are good and my wife suggested me - if its just 3 of us - why cant we be together. Life provided us with good friends and people around. It took only 2 days for us to decide where we wanted to be. My wife and I said to ourselves - exactly 6 months from now - we will be in India. All I requested my mom was to move to a different city (From chennai to Bangalore) - as the opportunities are much better in the later, for which she happily agreed.\n\nWhat I did before leaving US?\n\nSpoke to my manager and asked for a transfer to Bangalore office. The team agreed and initiated it.\nThe day I said I wanted to move back to India - I got an email from the immigration team to submit the documents for the first stage of GreenCard (haha). My wife and I laughed reading that and I politely declined their offer quoting my transfer as the reason.\nTried getting hold of good Ob/Gyns doctors in India and ensured that there would be a good doctor to take care when my wife lands up in India - which we were able to get thankfully.\nHelped my wife to go to India and we had our friends and relatives and my mom there who took care of her.\nI sold my items, terminated', 'result': {'fake': 0.1426, 'real': 0.8574}, 'status': 'success'}, {'text': 'my lease, distributed my items to my friends and left US.\n\nWhat happened in India?\n\nReached India exactly 2 weeks before my first born entering our lives and spent the entire 2 weeks with my wife and mom.\nAfter my son was born, I spent some time with him and started our move towards bangalore and setted up things in Bangalore. In 2 months all of them joined me there.\nBangalore truly contributed to my career life. I left the company ~ 2 years after I came here. Worked on several start-ups and I can confidently work anywhere and with anyone without any fear. I was able to make decisions fast - without the H1B/L1B fear and without cutting corners or yielding to petty politics. This is truly an advantage if you belong to a place where you can make “free” decisions. It doesn’t matter if its US or India. For me, I could make such decisions only in India.\nInfact 2 of the companies that I worked in India offered me to transfer to US if I want. I politely declined it. One such conversation happened 2 months before.\nMy son is 7 years old now and while I’m writing this blog - my mom is talking about a funny incident that she underwent with my son to someone on the other side of the phone conversation with her. This would have not happened if I had been in US and I see true sense of happiness in this. Well this is what all of us wanted.\nMy wife had never been much interested with industry life - She found her passion with education and she is now working as a school teacher with a very successful record and she is working on getting her educational degrees parallely. Happy to see that she is super occupied and doing what she loves.\nMy career progressed towards Tech Manager role/Architect role and I’m enjoying the work culture here\nI travel to US atleast once in an year for release meetings or to develop rapport between Bangalore and US teams. I spend time catching up with all my friends and we never missed each other.\n\nDid I ever regret coming back to India?\n\nNo. Because - I never had a feeling that one country was better than the other, w.r.t to US and India and thankfully my wife was in the same wavelength. Its based on your requirements - you decide the place.\n\nTo answer your question\n\nWhat do you want in life? Why US and why not India or vice-versa? Spend time contemplating on yourself and understand what will make you happy. As some say - The grass is always greener on the other side. I have seen a lot of folks coming to India, trying to imitate Mohan Bhargav (Thats the shahrukh khan’s name in Swades right? ;-) ) and ended up being a confused citizen than a clear immigrant. So, give yourself sometime - think twice thrice, even 100 times. But, never turn back on your decision once have decided concretely.\n\nAll the best!', 'result': {'fake': 0.0161, 'real': 0.9839}, 'status': 'success'}], 'credits_used': 11, 'credits': 1984360, 'subscription': 0, 'content': 'As an engineer who came to India for good - I could highlight you on what I underwent during this process.\n\nI went to US to do my Masters in 2006 and by 2008 I had an offer with one of the most reputed companies working on Virtual Machines. It was a tremendous opportunity with great package and stocks. I got married in few months and my wife and I enjoyed our times in Bay Area - visiting around CA and infact around US. We had an excellent set of friends and communities and trust me that was an ideal setup anyone would like to have.\n\nThen what happened? Even if my best days in US and worst days in India - I never had a feeling that one was better than the other. It all belongs to the thought - “Where do you want to be? and Why?”. Trust me - it doesn’t matter if its India or US - people can survive and do well and both the lands have the ability to provide the people who land up there.\n\nMy wife and I were expecting our first born and it was the time my mom needed my presence with her. She wasn’t able to feel at ease in US, as she had always been an independent person, going around places herself. Age started catching with her and she was in no mood to explore things and adopt to new things and life style in US. She had been a great support for me and my growth in my life, despite my dad’s demise during my teens. Thankfully - we are a closely knitted family and the vibe between all 3 of us(my mom, myself and my wife) are good and my wife suggested me - if its just 3 of us - why cant we be together. Life provided us with good friends and people around. It took only 2 days for us to decide where we wanted to be. My wife and I said to ourselves - exactly 6 months from now - we will be in India. All I requested my mom was to move to a different city (From chennai to Bangalore) - as the opportunities are much better in the later, for which she happily agreed.\n\nWhat I did before leaving US?\n\nSpoke to my manager and asked for a transfer to Bangalore office. The team agreed and initiated it.\nThe day I said I wanted to move back to India - I got an email from the immigration team to submit the documents for the first stage of GreenCard (haha). My wife and I laughed reading that and I politely declined their offer quoting my transfer as the reason.\nTried getting hold of good Ob/Gyns doctors in India and ensured that there would be a good doctor to take care when my wife lands up in India - which we were able to get thankfully.\nHelped my wife to go to India and we had our friends and relatives and my mom there who took care of her.\nI sold my items, terminated my lease, distributed my items to my friends and left US.\n\nWhat happened in India?\n\nReached India exactly 2 weeks before my first born entering our lives and spent the entire 2 weeks with my wife and mom.\nAfter my son was born, I spent some time with him and started our move towards bangalore and setted up things in Bangalore. In 2 months all of them joined me there.\nBangalore truly contributed to my career life. I left the company ~ 2 years after I came here. Worked on several start-ups and I can confidently work anywhere and with anyone without any fear. I was able to make decisions fast - without the H1B/L1B fear and without cutting corners or yielding to petty politics. This is truly an advantage if you belong to a place where you can make “free” decisions. It doesn’t matter if its US or India. For me, I could make such decisions only in India.\nInfact 2 of the companies that I worked in India offered me to transfer to US if I want. I politely declined it. One such conversation happened 2 months before.\nMy son is 7 years old now and while I’m writing this blog - my mom is talking about a funny incident that she underwent with my son to someone on the other side of the phone conversation with her. This would have not happened if I had been in US and I see true sense of happiness in this. Well this is what all of us wanted.\nMy wife had never been much interested with industry life - She found her passion with education and she is now working as a school teacher with a very successful record and she is working on getting her educational degrees parallely. Happy to see that she is super occupied and doing what she loves.\nMy career progressed towards Tech Manager role/Architect role and I’m enjoying the work culture here\nI travel to US atleast once in an year for release meetings or to develop rapport between Bangalore and US teams. I spend time catching up with all my friends and we never missed each other.\n\nDid I ever regret coming back to India?\n\nNo. Because - I never had a feeling that one country was better than the other, w.r.t to US and India and thankfully my wife was in the same wavelength. Its based on your requirements - you decide the place.\n\nTo answer your question\n\nWhat do you want in life? Why US and why not India or vice-versa? Spend time contemplating on yourself and understand what will make you happy. As some say - The grass is always greener on the other side. I have seen a lot of folks coming to India, trying to imitate Mohan Bhargav (Thats the shahrukh khan’s name in Swades right? ;-) ) and ended up being a confused citizen than a clear immigrant. So, give yourself sometime - think twice thrice, even 100 times. But, never turn back on your decision once have decided concretely.\n\nAll the best!', 'aiModelVersion': '1'}",0.51556666666667
Khalid Cawl,6y,Which programmer do you hire: the one who programs a messy program in three hours or the other who does a well-structured program in twelve?,"When I was doing my internship, we were given a 5 weeks long project. Before making any useful contributions to the company’s systems, we were asked to write a small demo app that would resemble some of the functionalities of their software (a very small subset). I had confidence in myself that I was a fast developer. I wanted to complete every new task as quickly as possible. The other intern (let us call him Fei) was quite slow, he would take a lot of time before writing any code. He would often delete huge chunks of code and rewrite it. Fei seemed to worry less about the deadline. We then had a meeting with the senior developers whereby we were asked to discuss the design of our code. My design was trivial (imagine a few GOD classes that did everything).

Fei’s design, on the other hand, was a thing of beauty. It seemed complicated and I didn’t understand it at the time, but he knew what he was doing. My mentor came to my desk after the meeting and recommended me to discuss with Fei and ask him why he did what he did and how it is different from my design. My mentor asked me how I would change my program if a requirement came that asked to draw shapes that can’t be colored or moved etc. I had learned that it would require a change in nearly every file that I wrote. Fei’s design? He showed me that he just needed to create an interface and plug it in here and there (dependency injection, anyone?).

I learned an important lesson that time. The fast developer will deliver you the requirement you want quickly and it might not even have any bugs. But unless it is a throw-away code, there will certainly be change of requirements. Applying those changes quickly and being able to do regression testing easily is something that will be almost impossible. This developer will leave you a pile of technical debt that will be made even worse by the future programmers of that project (because you are catching a deadline, right?).

Fei had two goals:

1. Write good quality code that is easily understandable

2. Write code that will be easy for others to change

I would hire Fei any day and fire myself.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ghq68lw7p50ndtj9', 'title': 'Which programmer do you hire: the one who programs a messy program in three hours or the other who does a well-structured program in twelve?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'When I was doing my internship, we were given a 5 weeks long project. Before making any useful contributions to the company’s systems, we were asked to write a small demo app that would resemble some of the functionalities of their software (a very small subset). I had confidence in myself that I was a fast developer. I wanted to complete every new task as quickly as possible. The other intern (let us call him Fei) was quite slow, he would take a lot of time before writing any code. He would often delete huge chunks of code and rewrite it. Fei seemed to worry less about the deadline. We then had a meeting with the senior developers whereby we were asked to discuss the design of our code. My design was trivial (imagine a few GOD classes that did everything).\n\nFei’s design, on the other hand, was a thing of beauty. It seemed complicated and I didn’t understand it at the time, but he knew what he was doing. My mentor came to my desk after the meeting and recommended me to discuss with Fei and ask him why he did what he did and how it is different from my design. My mentor asked me how I would change my program if a requirement came that asked to draw shapes that can’t be colored or moved etc. I had learned that it would require a change in nearly every file that I wrote. Fei’s design? He showed me that he just needed to create an interface and plug it in here and there (dependency injection, anyone?).\n\nI learned an important lesson that time. The fast developer will deliver you the requirement you want quickly and it might not even have any bugs. But unless it is a throw-away code, there will certainly be change of requirements. Applying those changes quickly and being able to do regression testing easily is something that will be almost impossible. This developer will leave you a pile of technical debt that will be made even worse by the future programmers of that project (because you are catching a deadline, right?).\n\nFei had two goals:\n\n1. Write good quality code that is easily understandable\n\n2. Write code that will be easy for others to change\n\nI would hire Fei any day and fire myself.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984356, 'subscription': 0, 'content': 'When I was doing my internship, we were given a 5 weeks long project. Before making any useful contributions to the company’s systems, we were asked to write a small demo app that would resemble some of the functionalities of their software (a very small subset). I had confidence in myself that I was a fast developer. I wanted to complete every new task as quickly as possible. The other intern (let us call him Fei) was quite slow, he would take a lot of time before writing any code. He would often delete huge chunks of code and rewrite it. Fei seemed to worry less about the deadline. We then had a meeting with the senior developers whereby we were asked to discuss the design of our code. My design was trivial (imagine a few GOD classes that did everything).\n\nFei’s design, on the other hand, was a thing of beauty. It seemed complicated and I didn’t understand it at the time, but he knew what he was doing. My mentor came to my desk after the meeting and recommended me to discuss with Fei and ask him why he did what he did and how it is different from my design. My mentor asked me how I would change my program if a requirement came that asked to draw shapes that can’t be colored or moved etc. I had learned that it would require a change in nearly every file that I wrote. Fei’s design? He showed me that he just needed to create an interface and plug it in here and there (dependency injection, anyone?).\n\nI learned an important lesson that time. The fast developer will deliver you the requirement you want quickly and it might not even have any bugs. But unless it is a throw-away code, there will certainly be change of requirements. Applying those changes quickly and being able to do regression testing easily is something that will be almost impossible. This developer will leave you a pile of technical debt that will be made even worse by the future programmers of that project (because you are catching a deadline, right?).\n\nFei had two goals:\n\n1. Write good quality code that is easily understandable\n\n2. Write code that will be easy for others to change\n\nI would hire Fei any day and fire myself.', 'aiModelVersion': '1'}",0.9995
Bruce F. Webster,1y,What is the darkest part of a software developer’s career?,"Roughly 20 years ago, I was brought into a Fortune 50 corporation to lead a small team to review a troubled software project. This was a major re-engineering project to replace an assortment of legacy software systems with a unified architecture and code base. The project was being jointly run by two very large, well-known consulting organizations. Their original winning bid was that the project would take two (2) years and cost $180 million.

It had now been going on for four (4) years, had cost $500 million to date, and there was zero working code in production. There was also no chief architect and, frankly, no system architecture. There was also no head of quality and no actual SQA organization.

We spent three months on our review. Our original assignment was to “figure out how to get the system under development into production ASAP.” Instead, our findings were that widescale rearchitecting, redesign, and recoding would be needed, not to mention honest-to-goodness SQA on every level.

I remember presenting the findings to a room of about 30 corporate (client, not consulting firm) managers involved in the project at various levels, from the executive VP over the project down to various team leads. As I spoke, I was fascinated to see three broad groups of reactions:

Increasingly hostile and angry looks on the faces of some of the higher-level managers (including the EVP).
Shocked and horrified looks on the faces of those who truly did not know how bad things were.
Faint smiles and nods from those whom, I assume, did know how bad things really were but had been unable to get anyone to listen.

The EVP left the room while I was still presenting — I was later told that he was trying to track down and destroy every copy of my presentation and my more detailed 45-page report.

That was pretty much the end of my engagement for that client. I came away experiencing something close to professional depression. I had already been reviewing troubled or failed IT projects for several years, but I could not fathom the sheer incompetence and, frankly, dishonesty by large big-name firms that could result in spending four years and half a billion dollars with no production code.

I got over it.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/dbfzoiqy9c3k8vlp', 'title': 'What is the darkest part of a software developer’s career?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'Roughly 20 years ago, I was brought into a Fortune 50 corporation to lead a small team to review a troubled software project. This was a major re-engineering project to replace an assortment of legacy software systems with a unified architecture and code base. The project was being jointly run by two very large, well-known consulting organizations. Their original winning bid was that the project would take two (2) years and cost $180 million.\n\nIt had now been going on for four (4) years, had cost $500 million to date, and there was zero working code in production. There was also no chief architect and, frankly, no system architecture. There was also no head of quality and no actual SQA organization.\n\nWe spent three months on our review. Our original assignment was to “figure out how to get the system under development into production ASAP.” Instead, our findings were that widescale rearchitecting, redesign, and recoding would be needed, not to mention honest-to-goodness SQA on every level.\n\nI remember presenting the findings to a room of about 30 corporate (client, not consulting firm) managers involved in the project at various levels, from the executive VP over the project down to various team leads. As I spoke, I was fascinated to see three broad groups of reactions:\n\nIncreasingly hostile and angry looks on the faces of some of the higher-level managers (including the EVP).\nShocked and horrified looks on the faces of those who truly did not know how bad things were.\nFaint smiles and nods from those whom, I assume, did know how bad things really were but had been unable to get anyone to listen.\n\nThe EVP left the room while I was still presenting — I was later told that he was trying to track down and destroy every copy of my presentation and my more detailed 45-page report.\n\nThat was pretty much the end of my engagement for that client. I came away experiencing something close to professional depression. I had already been reviewing troubled or failed IT projects for several years, but I could not fathom the sheer incompetence and, frankly, dishonesty by large big-name firms that could result in spending four years and half a billion dollars with no production code.\n\nI got over it.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984352, 'subscription': 0, 'content': 'Roughly 20 years ago, I was brought into a Fortune 50 corporation to lead a small team to review a troubled software project. This was a major re-engineering project to replace an assortment of legacy software systems with a unified architecture and code base. The project was being jointly run by two very large, well-known consulting organizations. Their original winning bid was that the project would take two (2) years and cost $180 million.\n\nIt had now been going on for four (4) years, had cost $500 million to date, and there was zero working code in production. There was also no chief architect and, frankly, no system architecture. There was also no head of quality and no actual SQA organization.\n\nWe spent three months on our review. Our original assignment was to “figure out how to get the system under development into production ASAP.” Instead, our findings were that widescale rearchitecting, redesign, and recoding would be needed, not to mention honest-to-goodness SQA on every level.\n\nI remember presenting the findings to a room of about 30 corporate (client, not consulting firm) managers involved in the project at various levels, from the executive VP over the project down to various team leads. As I spoke, I was fascinated to see three broad groups of reactions:\n\nIncreasingly hostile and angry looks on the faces of some of the higher-level managers (including the EVP).\nShocked and horrified looks on the faces of those who truly did not know how bad things were.\nFaint smiles and nods from those whom, I assume, did know how bad things really were but had been unable to get anyone to listen.\n\nThe EVP left the room while I was still presenting — I was later told that he was trying to track down and destroy every copy of my presentation and my more detailed 45-page report.\n\nThat was pretty much the end of my engagement for that client. I came away experiencing something close to professional depression. I had already been reviewing troubled or failed IT projects for several years, but I could not fathom the sheer incompetence and, frankly, dishonesty by large big-name firms that could result in spending four years and half a billion dollars with no production code.\n\nI got over it.', 'aiModelVersion': '1'}",0.9996
Reyansh Mishra,5y,"If almost everyone can learn programming for free, why is the salary relatively very high?","I can actually give you perfect analogy for it.

Consider the below image.

Now even if you have not studied civil engineering still you will be able to build it right? Almost anyone with basic knowledge and thinking can build this small little structure?

Now have a look at below image.

Now to build something like above takes a lot of knowledge experience.

So even if you can learn programming all by yourself but being good at it is really hard.

You get paid as a programmer just because of the skill you have doesn’t really matter how you acquired it.

|REY|","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/yk4ulonz6vwr58d2', 'title': 'If almost everyone can learn programming for free, why is the salary relatively very high?', 'score': {'original': 0.9989, 'ai': 0.0011}, 'blocks': [{'text': 'I can actually give you perfect analogy for it.\n\nConsider the below image.\n\nNow even if you have not studied civil engineering still you will be able to build it right? Almost anyone with basic knowledge and thinking can build this small little structure?\n\nNow have a look at below image.\n\nNow to build something like above takes a lot of knowledge experience.\n\nSo even if you can learn programming all by yourself but being good at it is really hard.\n\nYou get paid as a programmer just because of the skill you have doesn’t really matter how you acquired it.\n\n|REY|', 'result': {'fake': 0.0011, 'real': 0.9989}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984350, 'subscription': 0, 'content': 'I can actually give you perfect analogy for it.\n\nConsider the below image.\n\nNow even if you have not studied civil engineering still you will be able to build it right? Almost anyone with basic knowledge and thinking can build this small little structure?\n\nNow have a look at below image.\n\nNow to build something like above takes a lot of knowledge experience.\n\nSo even if you can learn programming all by yourself but being good at it is really hard.\n\nYou get paid as a programmer just because of the skill you have doesn’t really matter how you acquired it.\n\n|REY|', 'aiModelVersion': '1'}",0.9989
Tikhon Jelvis,5y,"As a software engineer, is there really a benefit to writing well organized, well written code? Is the extra effort worth it to companies, knowing some lower quality code can give a working product in less time and resources?","In my experience, there is a level of code quality that benefits any project on any timescale—and it’s a level above 90% of the code I see in the wild.

I am talking basic hygiene:

clear, descriptive naming
consistent organization—code laid out based on how it should be understood
intelligent grouping—functions, types, classes, modules and so on
sane layout—short lines and enough whitespace
documentation—the what and the why is explained for each organizational unit of your code

If you do this, you will save yourself time, tomorrow if not today. I am not exaggerating.

Clean code will help you avoid whole classes of bugs and the corresponding drawn-out, frustrating debugging sessions. I learned this the hard way, by cutting corners on clean code and then struggling to fix stupid mistakes or add simple features the same week (if not the same day). It took me multiple projects to draw this connection—after all, most of the mistakes (even the really stupid ones), were, well, just bugs. Even the cleanest of code will have bugs! The aspect it took me years to fully understand was how a lack of code hygiene actively bred bugs and made debugging harder than it had to be.

One dynamic that keeps people from realizing this is that they mentally separate the time it takes to write code from the time it takes to debug it. I sympathize: I do the same thing. In my mind, I’m “finished” when I write the final line of my program even before I test it at all. The revision and debugging that happens after the first draft—which can take longer than the initial stage—is its own entity. The fact that the code is unusably broken until I iron out all the obvious problems doesn’t come into it.

That’s not how reality works, but that’s how it feels. Feeling done prematurely skews your own understanding of how long a project took. Writing quick-and-dirty code, you might “finish” a feature in three hours and then spend four more debugging it; with clean code, it might take you four hours to write the code but only one to debug it—holistically, the latter is much faster, but if you’re mentally comparing the time it took you to feel “finished”, the quick-and-dirty version comes out ahead.

It gets better. Adhering to the rules of basic hygiene I outlined above doesn’t carry a real cost—or at least it shouldn’t. Except for writing documentation, nothing I outlined requires extra work: it only requires healthy habits. Write code right the first time. If you haven’t built up the right habits, writing clean code takes mental energy slowing you down. After you have, you’ll do it without thinking and clean code won’t cost a thing. Even writing code documentation (the kind I described, anyway) should not require significant extra time—all you have to do is put in writing¹ what you’re already thinking about as you’re writing your code. After all, you wouldn’t start writing a function without a general idea of what the function does or why it’s needed, would you?

The short-term benefit of writing documentation is in the writing, not the reading. It’s like taking notes in college: even if you didn’t refer to your notes to study, taking them forced you to pay attention and put what you were learning in context. I write a short paragraph describing each function or type I’m introducing before I write any code. Sometimes I end up with a bunch of documented stubs before implementing anything in a module. This approach stops me from punting on fundamental questions like “what am I doing?” and “why am I doing it?”. I need some level of clarity before I dive into coding, which keeps me focused, prevents me from wasting time on unneeded functionality and keeps the high-level organization of me code coherent even if I spend most of my time focused on the tress rather than the forest.

Writing messy code will not give you a working product in less time. Instead, it will make your work unfocused and will mire you down in unnecessary debugging.

Do you want death marches? Because that’s how you get death marches².

You need to develop good habits. That’s on you. Personally, I believe these habits are a low bar we should expect every professional programmer to pass—the fact that most don’t is a real shame. (It’s also eminently human: humans are not good at forcing themselves to spend energy now to build healthy habits for the long term. And building habits does take real work!)

There are levels of clean code beyond what I outlined. Software projects need relatively comprehensive automated tests. Core abstractions should be well thought-out and fit the naturally fit the domain. Projects should be extensible in the right places, without so much abstraction that the cost outweighs the benefits.

If abstraction is what you mean by “clean” code, it is certainly possible to go overboard—abstractions that are absolutely necessary for enterprise code expected to last years or decades with a large team can be actively counterproductive for a small project by a handful of developers, and abstractions for that small project might get in the way of a one-off script by a researcher. Poorly designed, overly complex abstractions are straight-up counterproductive, regardless of the scope of the project. Making this tradeoff well is difficult; the best results require a rare combination of experience, taste and creativity.

But that’s not true for code hygiene, which is largely systematic and benefits everyone, from the researcher writing a one-off script³ to the largest software projects in the world. Don’t trick yourself into writing unhygienic code just because your project doesn’t need too many levels of abstraction. Both of these notions might be described as “clean code”, but they are fundamentally different.

footnote
¹ This is also the reason I believe that knowing how to touch type is important for programmers. Touch-typing for code is not a big deal, but if you have trouble typing up a paragraph, you’re not going to write nearly as much documentation as you should. Even when you know exactly what to write, it will still take too much energy and willpower if the physical act of writing is difficult. So learn touch typing well enough so that you don’t have to think about it! No need to be a speed demon—you just have to be comfortable.

² Death marches lead to a vicious cycle. The problem started because you ran into issues with your code that were hard to solve. You work 60+ hour weeks and don’t get enough sleep. Because you’re overworked and underslept, you write worse code, which leads to more bugs, which leads to more overtime spent debugging. A few weeks in and you’re accomplishing less in absolute terms than you would have had you stuck to ~40 hour weeks. I’m not talking about less per hour, I am talking less overall. And ruining your health to boot. Don’t do it.

³ I’ve talked to a lot of researchers who don’t realize this: it is worth writing clean, organized code even if you only plan to run a script once for a paper. The dynamic is the same as for software engineers: on average, you will get your script working faster (less time spent debugging), and all it takes is having the habit of writing code well right off the bat. The habits are worth developing for everyone who ever writes code, not just professional programmers.

One-off scripts are rarely truly one-off.

At minimum, your research needs to be reproducible. Academia is slow to realize that software is as critical to reproduction as data—and even sharing data is not universal—but sharing research code for reproducibility is becoming more and more common, and not just in CS.

Cleaner code will also improve the quality of your research. Here’s a story that repeats across countless papers in different disciplines: you have a new idea to test or a new benchmark to run, but the paper deadline is in two days, and your paper is barely half-done. (Of course.) Perhaps you met a colleague in the hallway who pointed you to a relevant paper you hadn’t seen earlier. Perhaps you realize that your approach has a potential weakness you have to watch out for. How much work would it take you to run the new analysis or extend your benchmark suite? If you wrote clean, reproducible code, it might take you an hour to try your new idea. Maybe you add it to your paper, maybe you don’t, but it made your research more robust. On the other hand, if you wrote truly one-off code, you won’t have the time or energy to try anything new with a deadline looming. The code being a one-off script became a self-fulfilling prophecy—if you hadn’t written it as a one-off, it wouldn’t have been a one-off. If you’re in the habit of treating all your research code as one-offs, you probably don’t even notice all the opportunities you’re missing.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/jmz4v056f8qn1cph', 'title': 'As a software engineer, is there really a benefit to writing well organized, well written code? Is the extra effort worth it to companies, knowing some lower quality code can give a working product in less time and resources?', 'score': {'original': 0.99686666666667, 'ai': 0.0031333333333333}, 'blocks': [{'text': 'In my experience, there is a level of code quality that benefits any project on any timescale—and it’s a level above 90% of the code I see in the wild.\n\nI am talking basic hygiene:\n\nclear, descriptive naming\nconsistent organization—code laid out based on how it should be understood\nintelligent grouping—functions, types, classes, modules and so on\nsane layout—short lines and enough whitespace\ndocumentation—the what and the why is explained for each organizational unit of your code\n\nIf you do this, you will save yourself time, tomorrow if not today. I am not exaggerating.\n\nClean code will help you avoid whole classes of bugs and the corresponding drawn-out, frustrating debugging sessions. I learned this the hard way, by cutting corners on clean code and then struggling to fix stupid mistakes or add simple features the same week (if not the same day). It took me multiple projects to draw this connection—after all, most of the mistakes (even the really stupid ones), were, well, just bugs. Even the cleanest of code will have bugs! The aspect it took me years to fully understand was how a lack of code hygiene actively bred bugs and made debugging harder than it had to be.\n\nOne dynamic that keeps people from realizing this is that they mentally separate the time it takes to write code from the time it takes to debug it. I sympathize: I do the same thing. In my mind, I’m “finished” when I write the final line of my program even before I test it at all. The revision and debugging that happens after the first draft—which can take longer than the initial stage—is its own entity. The fact that the code is unusably broken until I iron out all the obvious problems doesn’t come into it.\n\nThat’s not how reality works, but that’s how it feels. Feeling done prematurely skews your own understanding of how long a project took. Writing quick-and-dirty code, you might “finish” a feature in three hours and then spend four more debugging it; with clean code, it might take you four hours to write the code but only one to debug it—holistically, the latter is much faster, but if you’re mentally comparing the time it took you to feel “finished”, the quick-and-dirty version comes out ahead.\n\nIt gets better. Adhering to the rules of basic hygiene I outlined above doesn’t carry a real cost—or at least it shouldn’t. Except for writing documentation, nothing I outlined requires extra work: it only requires healthy habits. Write code right the first time. If you haven’t built up the right habits, writing clean code takes mental energy slowing you down. After you have, you’ll do it without thinking and clean code won’t cost a thing. Even writing code documentation (the kind I described, anyway) should not require significant extra time—all you have to do is put in writing¹ what you’re already thinking about as you’re writing your code. After all, you wouldn’t start writing a function without a general idea of what the function does or why it’s needed, would you?\n\nThe short-term benefit of writing documentation is in the writing, not the', 'result': {'fake': 0.014, 'real': 0.986}, 'status': 'success'}, {'text': 'reading. It’s like taking notes in college: even if you didn’t refer to your notes to study, taking them forced you to pay attention and put what you were learning in context. I write a short paragraph describing each function or type I’m introducing before I write any code. Sometimes I end up with a bunch of documented stubs before implementing anything in a module. This approach stops me from punting on fundamental questions like “what am I doing?” and “why am I doing it?”. I need some level of clarity before I dive into coding, which keeps me focused, prevents me from wasting time on unneeded functionality and keeps the high-level organization of me code coherent even if I spend most of my time focused on the tress rather than the forest.\n\nWriting messy code will not give you a working product in less time. Instead, it will make your work unfocused and will mire you down in unnecessary debugging.\n\nDo you want death marches? Because that’s how you get death marches².\n\nYou need to develop good habits. That’s on you. Personally, I believe these habits are a low bar we should expect every professional programmer to pass—the fact that most don’t is a real shame. (It’s also eminently human: humans are not good at forcing themselves to spend energy now to build healthy habits for the long term. And building habits does take real work!)\n\nThere are levels of clean code beyond what I outlined. Software projects need relatively comprehensive automated tests. Core abstractions should be well thought-out and fit the naturally fit the domain. Projects should be extensible in the right places, without so much abstraction that the cost outweighs the benefits.\n\nIf abstraction is what you mean by “clean” code, it is certainly possible to go overboard—abstractions that are absolutely necessary for enterprise code expected to last years or decades with a large team can be actively counterproductive for a small project by a handful of developers, and abstractions for that small project might get in the way of a one-off script by a researcher. Poorly designed, overly complex abstractions are straight-up counterproductive, regardless of the scope of the project. Making this tradeoff well is difficult; the best results require a rare combination of experience, taste and creativity.\n\nBut that’s not true for code hygiene, which is largely systematic and benefits everyone, from the researcher writing a one-off script³ to the largest software projects in the world. Don’t trick yourself into writing unhygienic code just because your project doesn’t need too many levels of abstraction. Both of these notions might be described as “clean code”, but they are fundamentally different.\n\nfootnote\n¹ This is also the reason I believe that knowing how to touch type is important for programmers. Touch-typing for code is not a big deal, but if you have trouble typing up a paragraph, you’re not going to write nearly as much documentation as you should. Even when you know exactly what to write, it will still take too much energy and willpower if the physical act of writing is difficult. So learn touch', 'result': {'fake': 0.0683, 'real': 0.9317}, 'status': 'success'}, {'text': 'typing well enough so that you don’t have to think about it! No need to be a speed demon—you just have to be comfortable.\n\n² Death marches lead to a vicious cycle. The problem started because you ran into issues with your code that were hard to solve. You work 60+ hour weeks and don’t get enough sleep. Because you’re overworked and underslept, you write worse code, which leads to more bugs, which leads to more overtime spent debugging. A few weeks in and you’re accomplishing less in absolute terms than you would have had you stuck to ~40 hour weeks. I’m not talking about less per hour, I am talking less overall. And ruining your health to boot. Don’t do it.\n\n³ I’ve talked to a lot of researchers who don’t realize this: it is worth writing clean, organized code even if you only plan to run a script once for a paper. The dynamic is the same as for software engineers: on average, you will get your script working faster (less time spent debugging), and all it takes is having the habit of writing code well right off the bat. The habits are worth developing for everyone who ever writes code, not just professional programmers.\n\nOne-off scripts are rarely truly one-off.\n\nAt minimum, your research needs to be reproducible. Academia is slow to realize that software is as critical to reproduction as data—and even sharing data is not universal—but sharing research code for reproducibility is becoming more and more common, and not just in CS.\n\nCleaner code will also improve the quality of your research. Here’s a story that repeats across countless papers in different disciplines: you have a new idea to test or a new benchmark to run, but the paper deadline is in two days, and your paper is barely half-done. (Of course.) Perhaps you met a colleague in the hallway who pointed you to a relevant paper you hadn’t seen earlier. Perhaps you realize that your approach has a potential weakness you have to watch out for. How much work would it take you to run the new analysis or extend your benchmark suite? If you wrote clean, reproducible code, it might take you an hour to try your new idea. Maybe you add it to your paper, maybe you don’t, but it made your research more robust. On the other hand, if you wrote truly one-off code, you won’t have the time or energy to try anything new with a deadline looming. The code being a one-off script became a self-fulfilling prophecy—if you hadn’t written it as a one-off, it wouldn’t have been a one-off. If you’re in the habit of treating all your research code as one-offs, you probably don’t even notice all the opportunities you’re missing.', 'result': {'fake': 0.0102, 'real': 0.9898}, 'status': 'success'}], 'credits_used': 16, 'credits': 1984334, 'subscription': 0, 'content': 'In my experience, there is a level of code quality that benefits any project on any timescale—and it’s a level above 90% of the code I see in the wild.\n\nI am talking basic hygiene:\n\nclear, descriptive naming\nconsistent organization—code laid out based on how it should be understood\nintelligent grouping—functions, types, classes, modules and so on\nsane layout—short lines and enough whitespace\ndocumentation—the what and the why is explained for each organizational unit of your code\n\nIf you do this, you will save yourself time, tomorrow if not today. I am not exaggerating.\n\nClean code will help you avoid whole classes of bugs and the corresponding drawn-out, frustrating debugging sessions. I learned this the hard way, by cutting corners on clean code and then struggling to fix stupid mistakes or add simple features the same week (if not the same day). It took me multiple projects to draw this connection—after all, most of the mistakes (even the really stupid ones), were, well, just bugs. Even the cleanest of code will have bugs! The aspect it took me years to fully understand was how a lack of code hygiene actively bred bugs and made debugging harder than it had to be.\n\nOne dynamic that keeps people from realizing this is that they mentally separate the time it takes to write code from the time it takes to debug it. I sympathize: I do the same thing. In my mind, I’m “finished” when I write the final line of my program even before I test it at all. The revision and debugging that happens after the first draft—which can take longer than the initial stage—is its own entity. The fact that the code is unusably broken until I iron out all the obvious problems doesn’t come into it.\n\nThat’s not how reality works, but that’s how it feels. Feeling done prematurely skews your own understanding of how long a project took. Writing quick-and-dirty code, you might “finish” a feature in three hours and then spend four more debugging it; with clean code, it might take you four hours to write the code but only one to debug it—holistically, the latter is much faster, but if you’re mentally comparing the time it took you to feel “finished”, the quick-and-dirty version comes out ahead.\n\nIt gets better. Adhering to the rules of basic hygiene I outlined above doesn’t carry a real cost—or at least it shouldn’t. Except for writing documentation, nothing I outlined requires extra work: it only requires healthy habits. Write code right the first time. If you haven’t built up the right habits, writing clean code takes mental energy slowing you down. After you have, you’ll do it without thinking and clean code won’t cost a thing. Even writing code documentation (the kind I described, anyway) should not require significant extra time—all you have to do is put in writing¹ what you’re already thinking about as you’re writing your code. After all, you wouldn’t start writing a function without a general idea of what the function does or why it’s needed, would you?\n\nThe short-term benefit of writing documentation is in the writing, not the reading. It’s like taking notes in college: even if you didn’t refer to your notes to study, taking them forced you to pay attention and put what you were learning in context. I write a short paragraph describing each function or type I’m introducing before I write any code. Sometimes I end up with a bunch of documented stubs before implementing anything in a module. This approach stops me from punting on fundamental questions like “what am I doing?” and “why am I doing it?”. I need some level of clarity before I dive into coding, which keeps me focused, prevents me from wasting time on unneeded functionality and keeps the high-level organization of me code coherent even if I spend most of my time focused on the tress rather than the forest.\n\nWriting messy code will not give you a working product in less time. Instead, it will make your work unfocused and will mire you down in unnecessary debugging.\n\nDo you want death marches? Because that’s how you get death marches².\n\nYou need to develop good habits. That’s on you. Personally, I believe these habits are a low bar we should expect every professional programmer to pass—the fact that most don’t is a real shame. (It’s also eminently human: humans are not good at forcing themselves to spend energy now to build healthy habits for the long term. And building habits does take real work!)\n\nThere are levels of clean code beyond what I outlined. Software projects need relatively comprehensive automated tests. Core abstractions should be well thought-out and fit the naturally fit the domain. Projects should be extensible in the right places, without so much abstraction that the cost outweighs the benefits.\n\nIf abstraction is what you mean by “clean” code, it is certainly possible to go overboard—abstractions that are absolutely necessary for enterprise code expected to last years or decades with a large team can be actively counterproductive for a small project by a handful of developers, and abstractions for that small project might get in the way of a one-off script by a researcher. Poorly designed, overly complex abstractions are straight-up counterproductive, regardless of the scope of the project. Making this tradeoff well is difficult; the best results require a rare combination of experience, taste and creativity.\n\nBut that’s not true for code hygiene, which is largely systematic and benefits everyone, from the researcher writing a one-off script³ to the largest software projects in the world. Don’t trick yourself into writing unhygienic code just because your project doesn’t need too many levels of abstraction. Both of these notions might be described as “clean code”, but they are fundamentally different.\n\nfootnote\n¹ This is also the reason I believe that knowing how to touch type is important for programmers. Touch-typing for code is not a big deal, but if you have trouble typing up a paragraph, you’re not going to write nearly as much documentation as you should. Even when you know exactly what to write, it will still take too much energy and willpower if the physical act of writing is difficult. So learn touch typing well enough so that you don’t have to think about it! No need to be a speed demon—you just have to be comfortable.\n\n² Death marches lead to a vicious cycle. The problem started because you ran into issues with your code that were hard to solve. You work 60+ hour weeks and don’t get enough sleep. Because you’re overworked and underslept, you write worse code, which leads to more bugs, which leads to more overtime spent debugging. A few weeks in and you’re accomplishing less in absolute terms than you would have had you stuck to ~40 hour weeks. I’m not talking about less per hour, I am talking less overall. And ruining your health to boot. Don’t do it.\n\n³ I’ve talked to a lot of researchers who don’t realize this: it is worth writing clean, organized code even if you only plan to run a script once for a paper. The dynamic is the same as for software engineers: on average, you will get your script working faster (less time spent debugging), and all it takes is having the habit of writing code well right off the bat. The habits are worth developing for everyone who ever writes code, not just professional programmers.\n\nOne-off scripts are rarely truly one-off.\n\nAt minimum, your research needs to be reproducible. Academia is slow to realize that software is as critical to reproduction as data—and even sharing data is not universal—but sharing research code for reproducibility is becoming more and more common, and not just in CS.\n\nCleaner code will also improve the quality of your research. Here’s a story that repeats across countless papers in different disciplines: you have a new idea to test or a new benchmark to run, but the paper deadline is in two days, and your paper is barely half-done. (Of course.) Perhaps you met a colleague in the hallway who pointed you to a relevant paper you hadn’t seen earlier. Perhaps you realize that your approach has a potential weakness you have to watch out for. How much work would it take you to run the new analysis or extend your benchmark suite? If you wrote clean, reproducible code, it might take you an hour to try your new idea. Maybe you add it to your paper, maybe you don’t, but it made your research more robust. On the other hand, if you wrote truly one-off code, you won’t have the time or energy to try anything new with a deadline looming. The code being a one-off script became a self-fulfilling prophecy—if you hadn’t written it as a one-off, it wouldn’t have been a one-off. If you’re in the habit of treating all your research code as one-offs, you probably don’t even notice all the opportunities you’re missing.', 'aiModelVersion': '1'}",0.99686666666667
Dave Voorhis,3y,How long did it take for you to feel like you were no longer a beginner in computer programming?,"I’ve been programming for over forty years, and I’m hoping the “beginner” feeling will pass in a decade or so.

Actually, it kind of comes and goes in waves, like nausea.

I’ll be working on a thing, and I’ll be thinking to myself, oh god, why doesn’t this work? IT’S SO SIMPLE. Why aren’t the foo instances being retrieved from fooContainerPrimary? I’M PUTTING THEM IN RIGHT HERE!!! I must be an idiot. That’s it — I’m an idiot. A useless idiot. A rank beginner, noob, brainless, IDIOT! I shouldn’t even be here. I AM FUCKING USELESS!! I should just get up, leave my laptop behind so someone can have a laptop, and get a job at the coffee shop across the street. Except I’d SUCK AT THAT TOO. Oh god why did I ever think I could be a programmer? I AM WORTHLESS FILTH! I AM SCUM! I AM WORSE THAN WORTHLE-

Oh, wait. The foo instances are in fooContainerSecondary, not fooContainerPrimary. I’ll just change the reference… [*type type type*] …here, and run tests again and…

I AM GOD! I AM THE GOD OF PROGRAMMMING! I ROCK! I ROOOOOCKKK!!!! [*insert vulgar hip-thrust motions here*] UNGH! YEAH! TAKE THAT, CODE! TAKE THAT AND THAT AND THAT! THAT’S ME DOING YOU, CODE! I MAKE OPERATING SYSTEMS IN MY SLEEP! I FART OUT ALGORITHMS! I OWN THIS!!!! I AM TH-

…Oh…

…why isn’t the last test passing?

WHY IS IT NOT WORKING?!?? WHAT KIND OF WORTHLESS, INFANTILE, IDIOTIC FLOORWIPE SCUM WOULDN’T BE ABLE TO GET THIS TRIVIAL BEGINNER CODE WORKING??!? WHY CAN’T I DO THIS??!?? … .. .

And so on.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/sodntp5yiwqb439v', 'title': 'How long did it take for you to feel like you were no longer a beginner in computer programming?', 'score': {'original': 0.9991, 'ai': 0.0009}, 'blocks': [{'text': 'I’ve been programming for over forty years, and I’m hoping the “beginner” feeling will pass in a decade or so.\n\nActually, it kind of comes and goes in waves, like nausea.\n\nI’ll be working on a thing, and I’ll be thinking to myself, oh god, why doesn’t this work? IT’S SO SIMPLE. Why aren’t the foo instances being retrieved from fooContainerPrimary? I’M PUTTING THEM IN RIGHT HERE!!! I must be an idiot. That’s it — I’m an idiot. A useless idiot. A rank beginner, noob, brainless, IDIOT! I shouldn’t even be here. I AM FUCKING USELESS!! I should just get up, leave my laptop behind so someone can have a laptop, and get a job at the coffee shop across the street. Except I’d SUCK AT THAT TOO. Oh god why did I ever think I could be a programmer? I AM WORTHLESS FILTH! I AM SCUM! I AM WORSE THAN WORTHLE-\n\nOh, wait. The foo instances are in fooContainerSecondary, not fooContainerPrimary. I’ll just change the reference… [*type type type*] …here, and run tests again and…\n\nI AM GOD! I AM THE GOD OF PROGRAMMMING! I ROCK! I ROOOOOCKKK!!!! [*insert vulgar hip-thrust motions here*] UNGH! YEAH! TAKE THAT, CODE! TAKE THAT AND THAT AND THAT! THAT’S ME DOING YOU, CODE! I MAKE OPERATING SYSTEMS IN MY SLEEP! I FART OUT ALGORITHMS! I OWN THIS!!!! I AM TH-\n\n…Oh…\n\n…why isn’t the last test passing?\n\nWHY IS IT NOT WORKING?!?? WHAT KIND OF WORTHLESS, INFANTILE, IDIOTIC FLOORWIPE SCUM WOULDN’T BE ABLE TO GET THIS TRIVIAL BEGINNER CODE WORKING??!? WHY CAN’T I DO THIS??!?? … .. .\n\nAnd so on.', 'result': {'fake': 0.0009, 'real': 0.9991}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984331, 'subscription': 0, 'content': 'I’ve been programming for over forty years, and I’m hoping the “beginner” feeling will pass in a decade or so.\n\nActually, it kind of comes and goes in waves, like nausea.\n\nI’ll be working on a thing, and I’ll be thinking to myself, oh god, why doesn’t this work? IT’S SO SIMPLE. Why aren’t the foo instances being retrieved from fooContainerPrimary? I’M PUTTING THEM IN RIGHT HERE!!! I must be an idiot. That’s it — I’m an idiot. A useless idiot. A rank beginner, noob, brainless, IDIOT! I shouldn’t even be here. I AM FUCKING USELESS!! I should just get up, leave my laptop behind so someone can have a laptop, and get a job at the coffee shop across the street. Except I’d SUCK AT THAT TOO. Oh god why did I ever think I could be a programmer? I AM WORTHLESS FILTH! I AM SCUM! I AM WORSE THAN WORTHLE-\n\nOh, wait. The foo instances are in fooContainerSecondary, not fooContainerPrimary. I’ll just change the reference… [*type type type*] …here, and run tests again and…\n\nI AM GOD! I AM THE GOD OF PROGRAMMMING! I ROCK! I ROOOOOCKKK!!!! [*insert vulgar hip-thrust motions here*] UNGH! YEAH! TAKE THAT, CODE! TAKE THAT AND THAT AND THAT! THAT’S ME DOING YOU, CODE! I MAKE OPERATING SYSTEMS IN MY SLEEP! I FART OUT ALGORITHMS! I OWN THIS!!!! I AM TH-\n\n…Oh…\n\n…why isn’t the last test passing?\n\nWHY IS IT NOT WORKING?!?? WHAT KIND OF WORTHLESS, INFANTILE, IDIOTIC FLOORWIPE SCUM WOULDN’T BE ABLE TO GET THIS TRIVIAL BEGINNER CODE WORKING??!? WHY CAN’T I DO THIS??!?? … .. .\n\nAnd so on.', 'aiModelVersion': '1'}",0.9991
Dmitry Murashenkov,Updated 5y,What's the best code you've seen a professional programmer write? How does it compare to the average programmer?,"Professional programmer’s code:

//Here we address strange issue that was seen on 
//production a few times, but is not reproduced  
//localy. User can be mysteriously logged out after 
//clicking Back button. This seems related to recent 
//changes to redirect scheme upon order confirmation. 
login(currentUser()); 

Average programmer’s code:

//Hotfix - don't ask 
login(currentUser()); 

Professional programmer’s commit message:

Fix memory leak in connection pool 
 
We've seen connections leaking from the pool 
if any query had already been executed through 
it and then exception is thrown. 
 
The root causes was found in ConnectionPool.addExceptionHook() 
method that ignored certain types of exceptions. 

Average programmer’s commit message:

Small fix 

Professional programmer’s test naming:

login_shouldThrowUserNotFoundException_ifUserAbsentInDB() 
login_shouldSetCurrentUser_ifLoginSuccessfull() 
login_shouldRecordAuditMessage_uponUnsuccessfullLogin() 

Average programmer’s test naming:

testLogin1() 
testLogin2() 
testLogin3() 

After first few years of programming, when the urge to put some cool looking construct only you can understand into every block of code wears off, you’ll likely come to the conclusion that these examples are actually the code you want to encounter when opening a new project.

If we look at the apps written by good vs average programmers (not talking about total beginners) the code itself is not that much different, but if small conveniences everywhere allow you to avoid frustration while reading it - it is likely written by a professional.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/p26h5jqzovr4wnk7', 'title': ""What's the best code you've seen a professional programmer write? How does it compare to the average programmer?"", 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': ""Professional programmer’s code:\n\n//Here we address strange issue that was seen on\xa0\n//production a few times, but is not reproduced \xa0\n//localy. User can be mysteriously logged out after\xa0\n//clicking Back button. This seems related to recent\xa0\n//changes to redirect scheme upon order confirmation.\xa0\nlogin(currentUser());\xa0\n\nAverage programmer’s code:\n\n//Hotfix - don't ask\xa0\nlogin(currentUser());\xa0\n\nProfessional programmer’s commit message:\n\nFix memory leak in connection pool\xa0\n\xa0\nWe've seen connections leaking from the pool\xa0\nif any query had already been executed through\xa0\nit and then exception is thrown.\xa0\n\xa0\nThe root causes was found in ConnectionPool.addExceptionHook()\xa0\nmethod that ignored certain types of exceptions.\xa0\n\nAverage programmer’s commit message:\n\nSmall fix\xa0\n\nProfessional programmer’s test naming:\n\nlogin_shouldThrowUserNotFoundException_ifUserAbsentInDB()\xa0\nlogin_shouldSetCurrentUser_ifLoginSuccessfull()\xa0\nlogin_shouldRecordAuditMessage_uponUnsuccessfullLogin()\xa0\n\nAverage programmer’s test naming:\n\ntestLogin1()\xa0\ntestLogin2()\xa0\ntestLogin3()\xa0\n\nAfter first few years of programming, when the urge to put some cool looking construct only you can understand into every block of code wears off, you’ll likely come to the conclusion that these examples are actually the code you want to encounter when opening a new project.\n\nIf we look at the apps written by good vs average programmers (not talking about total beginners) the code itself is not that much different, but if small conveniences everywhere allow you to avoid frustration while reading it - it is likely written by a professional."", 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984328, 'subscription': 0, 'content': ""Professional programmer’s code:\n\n//Here we address strange issue that was seen on\xa0\n//production a few times, but is not reproduced \xa0\n//localy. User can be mysteriously logged out after\xa0\n//clicking Back button. This seems related to recent\xa0\n//changes to redirect scheme upon order confirmation.\xa0\nlogin(currentUser());\xa0\n\nAverage programmer’s code:\n\n//Hotfix - don't ask\xa0\nlogin(currentUser());\xa0\n\nProfessional programmer’s commit message:\n\nFix memory leak in connection pool\xa0\n\xa0\nWe've seen connections leaking from the pool\xa0\nif any query had already been executed through\xa0\nit and then exception is thrown.\xa0\n\xa0\nThe root causes was found in ConnectionPool.addExceptionHook()\xa0\nmethod that ignored certain types of exceptions.\xa0\n\nAverage programmer’s commit message:\n\nSmall fix\xa0\n\nProfessional programmer’s test naming:\n\nlogin_shouldThrowUserNotFoundException_ifUserAbsentInDB()\xa0\nlogin_shouldSetCurrentUser_ifLoginSuccessfull()\xa0\nlogin_shouldRecordAuditMessage_uponUnsuccessfullLogin()\xa0\n\nAverage programmer’s test naming:\n\ntestLogin1()\xa0\ntestLogin2()\xa0\ntestLogin3()\xa0\n\nAfter first few years of programming, when the urge to put some cool looking construct only you can understand into every block of code wears off, you’ll likely come to the conclusion that these examples are actually the code you want to encounter when opening a new project.\n\nIf we look at the apps written by good vs average programmers (not talking about total beginners) the code itself is not that much different, but if small conveniences everywhere allow you to avoid frustration while reading it - it is likely written by a professional."", 'aiModelVersion': '1'}",0.9995
Dr. Balaji Viswanathan,4y,"If almost everyone can learn programming for free, why is the salary relatively very high?","If almost everyone can run, why is Usain Bolt so highly paid?

If almost everyone can paint, why is Picasso so highly valued?

Highly paid programmers are like top notch athletes and artists — they have a mastery over their skill.

When I got into college I asked a senior a question — now that everyone has a Java book, would programming be commoditized. He said while everyone can learn basic Java syntax, only the very best can convert that syntax & commands to solve a customer problem.

Just as anyone can run, anyone can write a basic program and run:

python myfirstprogram.py 

No one is going to pay someone for that. From there to be able to grow up to build your own unique art, that requires a lot of intelligence, patience, perseverance and practice. People pay high salaries for that.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/3yfk9tva2rswpdmu', 'title': 'If almost everyone can learn programming for free, why is the salary relatively very high?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'If almost everyone can run, why is Usain Bolt so highly paid?\n\nIf almost everyone can paint, why is Picasso so highly valued?\n\nHighly paid programmers are like top notch athletes and artists — they have a mastery over their skill.\n\nWhen I got into college I asked a senior a question — now that everyone has a Java book, would programming be commoditized. He said while everyone can learn basic Java syntax, only the very best can convert that syntax & commands to solve a customer problem.\n\nJust as anyone can run, anyone can write a basic program and run:\n\npython myfirstprogram.py \n\nNo one is going to pay someone for that. From there to be able to grow up to build your own unique art, that requires a lot of intelligence, patience, perseverance and practice. People pay high salaries for that.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984326, 'subscription': 0, 'content': 'If almost everyone can run, why is Usain Bolt so highly paid?\n\nIf almost everyone can paint, why is Picasso so highly valued?\n\nHighly paid programmers are like top notch athletes and artists — they have a mastery over their skill.\n\nWhen I got into college I asked a senior a question — now that everyone has a Java book, would programming be commoditized. He said while everyone can learn basic Java syntax, only the very best can convert that syntax & commands to solve a customer problem.\n\nJust as anyone can run, anyone can write a basic program and run:\n\npython myfirstprogram.py \n\nNo one is going to pay someone for that. From there to be able to grow up to build your own unique art, that requires a lot of intelligence, patience, perseverance and practice. People pay high salaries for that.', 'aiModelVersion': '1'}",0.9996
Kurt Guntheroth,4y,"A senior software engineer told me not to make functions and to have all of my code in my main method because it's faster. I argued that this makes the code way too unreadable, redundant, and messy. Who is right?","Saving run time by writing code inline is an example of being penny-wise and pound-foolish.

It is true that function calls each cost a minute amount of extra time that would not be spent if the code was all in line. Does this difference matter? Is it 1%, or is it 0.001%? Usually the latter.

But what is faster to develop? A piece of software divided up into logical functions, or one that is a single humongous file of wall-to-wall code with no obvious starts or stops? That tiny decrease in speed usually buys you a ton of ease-of-development. It’s a worthwhile trade.

When the code is done, you can profile it, and if one function is called too many times, you can inline that one function. There are usually one or two functions that take an appreciable amount of time, and the rest don’t. So optimizing at the end is vastly more efficient.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wg1z7l0j9yv2bmn5', 'title': ""A senior software engineer told me not to make functions and to have all of my code in my main method because it's faster. I argued that this makes the code way too unreadable, redundant, and messy. Who is right?"", 'score': {'original': 0.9938, 'ai': 0.0062}, 'blocks': [{'text': 'Saving run time by writing code inline is an example of being penny-wise and pound-foolish.\n\nIt is true that function calls each cost a minute amount of extra time that would not be spent if the code was all in line. Does this difference matter? Is it 1%, or is it 0.001%? Usually the latter.\n\nBut what is faster to develop? A piece of software divided up into logical functions, or one that is a single humongous file of wall-to-wall code with no obvious starts or stops? That tiny decrease in speed usually buys you a ton of ease-of-development. It’s a worthwhile trade.\n\nWhen the code is done, you can profile it, and if one function is called too many times, you can inline that one function. There are usually one or two functions that take an appreciable amount of time, and the rest don’t. So optimizing at the end is vastly more efficient.', 'result': {'fake': 0.0062, 'real': 0.9938}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984324, 'subscription': 0, 'content': 'Saving run time by writing code inline is an example of being penny-wise and pound-foolish.\n\nIt is true that function calls each cost a minute amount of extra time that would not be spent if the code was all in line. Does this difference matter? Is it 1%, or is it 0.001%? Usually the latter.\n\nBut what is faster to develop? A piece of software divided up into logical functions, or one that is a single humongous file of wall-to-wall code with no obvious starts or stops? That tiny decrease in speed usually buys you a ton of ease-of-development. It’s a worthwhile trade.\n\nWhen the code is done, you can profile it, and if one function is called too many times, you can inline that one function. There are usually one or two functions that take an appreciable amount of time, and the rest don’t. So optimizing at the end is vastly more efficient.', 'aiModelVersion': '1'}",0.9938
Ben Podgursky,4y,What harsh truths did you learn during your first year working as a software developer?,"You will miss opportunities to make a lot of money, and it will feel bad.

(I’m cheating — this sinks in at 2–3 years).

Engineers in the Bay Area have options.

I started at Rapleaf in 2011. Over the ~8 years I worked this semi-continuous job out of college, Rapleaf floundered around for a while, spun off into LiveRamp, got acquired by Acxiom, un-acquired Acxiom to operate as a public company, and I left with coworkers to found a startup. My options did well and were treated very fairly; I did well by any real-world metric. All while making great friends, and working with great people.

But because I worked in San Francisco, I had friends and acquaintances who made foresightful job changes, and did very, very well.

One of the first engineers I worked with at Rapleaf left shortly after I signed my full-time offer, about December 2011, to work for a company I had never heard of — named Pinterest.

“Pinterest?” I thought. “That sounds dumb. It’s just a message board with pictures? Surely our business of selling cold hard data is a more lucrative business”

Pinterest is now worth over $10 billion. I did not (and frankly, still do not) see the value or the need for a message board with pictures. He did, and that insight paid well.

A sales coworker at LiveRamp — and he was very good at selling — left LiveRamp to work for AppLovin.

“AppLovin? That name sounds like it’s from Superbad” I thought. “Why does the world need another mobile ad network? Surely supplying data for ad networks is a more defensible position.”

About a year and a half later, AppLovin was worth $1.5 billion. The world did, it turns out, need another mobile ad network.

I have other similar stories. I had other friends and colleagues who took the plunge years ahead of me, and either founded their own startups or joined as early-early employees. The jury is still out on many of them, but many will do well. Some very, very well. They would have done comfortably at any other late-stage-startup or enterprise, but instead saw a market opportunity and seized it.

So the “harsh truth” is — very good software engineers who put in the work will do well anywhere. They will make generous salaries and have comfortable lives. But the engineers who work hard, but who can also look forward and see where their work will really pay dividends, can multiply their payout 10x, 20x, or more.

That wasn’t me, at the time, but I’m doing my best now.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/q2uxj3th657ndorw', 'title': 'What harsh truths did you learn during your first year working as a software developer?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'You will miss opportunities to make a lot of money, and it will feel bad.\n\n(I’m cheating — this sinks in at 2–3 years).\n\nEngineers in the Bay Area have options.\n\nI started at Rapleaf in 2011. Over the ~8 years I worked this semi-continuous job out of college, Rapleaf floundered around for a while, spun off into LiveRamp, got acquired by Acxiom, un-acquired Acxiom to operate as a public company, and I left with coworkers to found a startup. My options did well and were treated very fairly; I did well by any real-world metric. All while making great friends, and working with great people.\n\nBut because I worked in San Francisco, I had friends and acquaintances who made foresightful job changes, and did very, very well.\n\nOne of the first engineers I worked with at Rapleaf left shortly after I signed my full-time offer, about December 2011, to work for a company I had never heard of — named Pinterest.\n\n“Pinterest?” I thought. “That sounds dumb. It’s just a message board with pictures? Surely our business of selling cold hard data is a more lucrative business”\n\nPinterest is now worth over $10 billion. I did not (and frankly, still do not) see the value or the need for a message board with pictures. He did, and that insight paid well.\n\nA sales coworker at LiveRamp — and he was very good at selling — left LiveRamp to work for AppLovin.\n\n“AppLovin? That name sounds like it’s from Superbad” I thought. “Why does the world need another mobile ad network? Surely supplying data for ad networks is a more defensible position.”\n\nAbout a year and a half later, AppLovin was worth $1.5 billion. The world did, it turns out, need another mobile ad network.\n\nI have other similar stories. I had other friends and colleagues who took the plunge years ahead of me, and either founded their own startups or joined as early-early employees. The jury is still out on many of them, but many will do well. Some very, very well. They would have done comfortably at any other late-stage-startup or enterprise, but instead saw a market opportunity and seized it.\n\nSo the “harsh truth” is — very good software engineers who put in the work will do well anywhere. They will make generous salaries and have comfortable lives. But the engineers who work hard, but who can also look forward and see where their work will really pay dividends, can multiply their payout 10x, 20x, or more.\n\nThat wasn’t me, at the time, but I’m doing my best now.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984319, 'subscription': 0, 'content': 'You will miss opportunities to make a lot of money, and it will feel bad.\n\n(I’m cheating — this sinks in at 2–3 years).\n\nEngineers in the Bay Area have options.\n\nI started at Rapleaf in 2011. Over the ~8 years I worked this semi-continuous job out of college, Rapleaf floundered around for a while, spun off into LiveRamp, got acquired by Acxiom, un-acquired Acxiom to operate as a public company, and I left with coworkers to found a startup. My options did well and were treated very fairly; I did well by any real-world metric. All while making great friends, and working with great people.\n\nBut because I worked in San Francisco, I had friends and acquaintances who made foresightful job changes, and did very, very well.\n\nOne of the first engineers I worked with at Rapleaf left shortly after I signed my full-time offer, about December 2011, to work for a company I had never heard of — named Pinterest.\n\n“Pinterest?” I thought. “That sounds dumb. It’s just a message board with pictures? Surely our business of selling cold hard data is a more lucrative business”\n\nPinterest is now worth over $10 billion. I did not (and frankly, still do not) see the value or the need for a message board with pictures. He did, and that insight paid well.\n\nA sales coworker at LiveRamp — and he was very good at selling — left LiveRamp to work for AppLovin.\n\n“AppLovin? That name sounds like it’s from Superbad” I thought. “Why does the world need another mobile ad network? Surely supplying data for ad networks is a more defensible position.”\n\nAbout a year and a half later, AppLovin was worth $1.5 billion. The world did, it turns out, need another mobile ad network.\n\nI have other similar stories. I had other friends and colleagues who took the plunge years ahead of me, and either founded their own startups or joined as early-early employees. The jury is still out on many of them, but many will do well. Some very, very well. They would have done comfortably at any other late-stage-startup or enterprise, but instead saw a market opportunity and seized it.\n\nSo the “harsh truth” is — very good software engineers who put in the work will do well anywhere. They will make generous salaries and have comfortable lives. But the engineers who work hard, but who can also look forward and see where their work will really pay dividends, can multiply their payout 10x, 20x, or more.\n\nThat wasn’t me, at the time, but I’m doing my best now.', 'aiModelVersion': '1'}",0.9998
Harish Shivaraman,9y,What is the best comment in source code that you have ever encountered?,"Go to Flipkart's website right now and right click on the homepage. Select Inspect Element which opens up the Chrome Developer Tool window. Click on ""Console"" and you'll be seeing this :   A closer view :  I find this cool. What do you think  ?","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/v87rko6fa1xq0gpc', 'title': 'What is the best comment in source code that you have ever encountered?', 'score': {'original': 0.9944, 'ai': 0.0056}, 'blocks': [{'text': 'Go to Flipkart\'s website right now and right click on the homepage. Select Inspect Element which opens up the Chrome Developer Tool window. Click on ""Console"" and you\'ll be seeing this :   A closer view :  I find this cool. What do you think  ?', 'result': {'fake': 0.0089, 'real': 0.9911}, 'status': 'success'}], 'credits_used': 1, 'credits': 1984318, 'subscription': 0, 'content': 'Go to Flipkart\'s website right now and right click on the homepage. Select Inspect Element which opens up the Chrome Developer Tool window. Click on ""Console"" and you\'ll be seeing this :   A closer view :  I find this cool. What do you think  ?', 'aiModelVersion': '1'}",0.9944
Alan Kay,2y,Should writing code be fun?,"I wrote this in a comment to Ian Joyner’s answer. Here it is as an answer. Ian used a great quote by Al Perlis (the first Turing Award winner) about “Computer Science”:

""I think that it's extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shafted every now and then, and after a while we began to take their complaints seriously. We began to feel as if we really were responsible for the successful, error-free perfect use of these machines. I don't think we are. I think we're responsible for stretching them, setting them off in new directions, and keeping fun in the house. I hope the field of computer science never loses its sense of fun."" ~ Alan Perlis

Bringing Al Perlis’ comment up to the present time, where “Computer Science” is kind of a sloppy term for “pretty much everything”, instead of the very strict sense of “Science” (as in “Real Science”) that he had in mind …

Note that in the larger world of highly developed disciplines, we want the airplane we are flying in to be designed by *serious engineers*, whose version of the Hippocratic Oath is “The bridge must not fall, the airplane must not crash …”, rather than scientists or mathematicians who will generally learn more from a crash — and from playing around in general — than when everything goes well.

The “fun” of engineering — and boy it really is fun to design and make things that really work well and help humanity along — is very different from the “fun” of science and math. Having “fun” is very much being able to do what you choose to do really well.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ynf0rsg83tmo6i1j', 'title': 'Should writing code be fun?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'I wrote this in a comment to Ian Joyner’s answer. Here it is as an answer. Ian used a great quote by Al Perlis (the first Turing Award winner) about “Computer Science”:\n\n""I think that it\'s extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shafted every now and then, and after a while we began to take their complaints seriously. We began to feel as if we really were responsible for the successful, error-free perfect use of these machines. I don\'t think we are. I think we\'re responsible for stretching them, setting them off in new directions, and keeping fun in the house. I hope the field of computer science never loses its sense of fun."" ~ Alan Perlis\n\nBringing Al Perlis’ comment up to the present time, where “Computer Science” is kind of a sloppy term for “pretty much everything”, instead of the very strict sense of “Science” (as in “Real Science”) that he had in mind …\n\nNote that in the larger world of highly developed disciplines, we want the airplane we are flying in to be designed by *serious engineers*, whose version of the Hippocratic Oath is “The bridge must not fall, the airplane must not crash …”, rather than scientists or mathematicians who will generally learn more from a crash — and from playing around in general — than when everything goes well.\n\nThe “fun” of engineering — and boy it really is fun to design and make things that really work well and help humanity along — is very different from the “fun” of science and math. Having “fun” is very much being able to do what you choose to do really well.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984315, 'subscription': 0, 'content': 'I wrote this in a comment to Ian Joyner’s answer. Here it is as an answer. Ian used a great quote by Al Perlis (the first Turing Award winner) about “Computer Science”:\n\n""I think that it\'s extraordinarily important that we in computer science keep fun in computing. When it started out, it was an awful lot of fun. Of course, the paying customers got shafted every now and then, and after a while we began to take their complaints seriously. We began to feel as if we really were responsible for the successful, error-free perfect use of these machines. I don\'t think we are. I think we\'re responsible for stretching them, setting them off in new directions, and keeping fun in the house. I hope the field of computer science never loses its sense of fun."" ~ Alan Perlis\n\nBringing Al Perlis’ comment up to the present time, where “Computer Science” is kind of a sloppy term for “pretty much everything”, instead of the very strict sense of “Science” (as in “Real Science”) that he had in mind …\n\nNote that in the larger world of highly developed disciplines, we want the airplane we are flying in to be designed by *serious engineers*, whose version of the Hippocratic Oath is “The bridge must not fall, the airplane must not crash …”, rather than scientists or mathematicians who will generally learn more from a crash — and from playing around in general — than when everything goes well.\n\nThe “fun” of engineering — and boy it really is fun to design and make things that really work well and help humanity along — is very different from the “fun” of science and math. Having “fun” is very much being able to do what you choose to do really well.', 'aiModelVersion': '1'}",0.9998
Dan Shappir,4y,What is the most ludicrous feature you were asked to code as a software engineer?,"Way back in 1996 I joined a hot new startup as employee #9. This startup had developed technology which made it possible to identify when a home’s Internet connection became unused, and to instantly start utilizing it to download content. And then when the connection was in use again, that download would immediately be suspended. This made it possible to download large content in the background, in chunks, without degrading the experience of people who were using that Internet connection, say to browse the web.

I was on the client team, working on the development of this software, optimizing the data transfer, and the compression of the content. It was very cool to see various applications of this technology, such as downloading large media content, which would otherwise be untenable, given the quality of connections back then. Once the content was fully downloaded, the user was prompted to open it, e.g. to play a downloaded video. And since that content was fully local, it played quickly, without buffering and stuttering.

Since it was 1996, coming on 1997, we decided to develop clients of Windows 95, and forgo Windows 3.11. This made it possible for us to use the new Win32 API, and the latest version MFC
 as the application framework. Consequently, the development process was fairly pleasant and rapid. We were making great strides, and the software was on track to hit the market. But then Softbank
 happened.

Softbank (yeah, the same guys now entangled in the WeWork kerfuffle) was brought in to invest money in the company, and apparently they liked what they saw. They were willing to invest several million dollars at a good valuation. But it turned out they had an important demand for us to agree to before they were willing to hand out the cash: we had to back-port our software so that it would run on Windows 3.11.

You see, Softbank’s genius analysts had determined that it would take Microsoft years to push Windows 95 into the market. As a result, they concluded, people and organizations would continue to rely heavily on Windows 3.11 for years to come, and well into the 2000s. Therefore they demanded that we commit to properly support that platform as a prerequisite for their investment. And so I, and two other developers were put into a team, and tasked with implementing that back-port.

It took the three of us a whole year to build it. Getting it to function properly on that hack of an operating system was a hell of a task, but we succeeded. We deployed it into production, and since it was an Internet client, we were able to track usage numbers: several months into production we had all of three users! I don’t think we ever got over 10 users before we killed that version about a year later.

And so we spent three man-years on a product that though deployed to production, never saw any noticeable use. The alternative cost to the company was significant, and really hurt us. But we did get several million dollars of Softbank money, and a few years later, we went public on the Nasdaq. By the year 2000 the company reached a valuation of over two billion dollars!

And then the bubble burst …

Fortunately for me, I had managed to cash out a portion of my stock options by then. Also I had gotten to work on several very interesting projects in that company, after that doomed one. As a result, I now have pleasant memories of that period. Except for that one, year long waste of time.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/1t2znx3i6pfbvsgq', 'title': 'What is the most ludicrous feature you were asked to code as a software engineer?', 'score': {'original': 0.8357, 'ai': 0.1643}, 'blocks': [{'text': 'Way back in 1996 I joined a hot new startup as employee #9. This startup had developed technology which made it possible to identify when a home’s Internet connection became unused, and to instantly start utilizing it to download content. And then when the connection was in use again, that download would immediately be suspended. This made it possible to download large content in the background, in chunks, without degrading the experience of people who were using that Internet connection, say to browse the web.\n\nI was on the client team, working on the development of this software, optimizing the data transfer, and the compression of the content. It was very cool to see various applications of this technology, such as downloading large media content, which would otherwise be untenable, given the quality of connections back then. Once the content was fully downloaded, the user was prompted to open it, e.g. to play a downloaded video. And since that content was fully local, it played quickly, without buffering and stuttering.\n\nSince it was 1996, coming on 1997, we decided to develop clients of Windows 95, and forgo Windows 3.11. This made it possible for us to use the new Win32 API, and the latest version MFC\n as the application framework. Consequently, the development process was fairly pleasant and rapid. We were making great strides, and the software was on track to hit the market. But then Softbank\n happened.\n\nSoftbank (yeah, the same guys now entangled in the WeWork kerfuffle) was brought in to invest money in the company, and apparently they liked what they saw. They were willing to invest several million dollars at a good valuation. But it turned out they had an important demand for us to agree to before they were willing to hand out the cash: we had to back-port our software so that it would run on Windows 3.11.\n\nYou see, Softbank’s genius analysts had determined that it would take Microsoft years to push Windows 95 into the market. As a result, they concluded, people and organizations would continue to rely heavily on Windows 3.11 for years to come, and well into the 2000s. Therefore they demanded that we commit to properly support that platform as a prerequisite for their investment. And so I, and two other developers were put into a team, and tasked with implementing that back-port.\n\nIt took the three of us a whole year to build it. Getting it to function properly on that hack of an operating system was a hell of a task, but we succeeded. We deployed it into production, and since it was an Internet client, we were able to track usage numbers: several months into production we had all of three users! I don’t think we ever got over 10 users before we killed that version about a year later.\n\nAnd so we spent three man-years on a product that though deployed to production, never saw any noticeable use. The alternative cost to the company was significant, and really hurt us. But we did get several million dollars of Softbank money, and a few', 'result': {'fake': 0.1644, 'real': 0.8356}, 'status': 'success'}, {'text': 'years later, we went public on the Nasdaq. By the year 2000 the company reached a valuation of over two billion dollars!\n\nAnd then the bubble burst …\n\nFortunately for me, I had managed to cash out a portion of my stock options by then. Also I had gotten to work on several very interesting projects in that company, after that doomed one. As a result, I now have pleasant memories of that period. Except for that one, year long waste of time.', 'result': {'fake': 0.0398, 'real': 0.9602}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984309, 'subscription': 0, 'content': 'Way back in 1996 I joined a hot new startup as employee #9. This startup had developed technology which made it possible to identify when a home’s Internet connection became unused, and to instantly start utilizing it to download content. And then when the connection was in use again, that download would immediately be suspended. This made it possible to download large content in the background, in chunks, without degrading the experience of people who were using that Internet connection, say to browse the web.\n\nI was on the client team, working on the development of this software, optimizing the data transfer, and the compression of the content. It was very cool to see various applications of this technology, such as downloading large media content, which would otherwise be untenable, given the quality of connections back then. Once the content was fully downloaded, the user was prompted to open it, e.g. to play a downloaded video. And since that content was fully local, it played quickly, without buffering and stuttering.\n\nSince it was 1996, coming on 1997, we decided to develop clients of Windows 95, and forgo Windows 3.11. This made it possible for us to use the new Win32 API, and the latest version MFC\n as the application framework. Consequently, the development process was fairly pleasant and rapid. We were making great strides, and the software was on track to hit the market. But then Softbank\n happened.\n\nSoftbank (yeah, the same guys now entangled in the WeWork kerfuffle) was brought in to invest money in the company, and apparently they liked what they saw. They were willing to invest several million dollars at a good valuation. But it turned out they had an important demand for us to agree to before they were willing to hand out the cash: we had to back-port our software so that it would run on Windows 3.11.\n\nYou see, Softbank’s genius analysts had determined that it would take Microsoft years to push Windows 95 into the market. As a result, they concluded, people and organizations would continue to rely heavily on Windows 3.11 for years to come, and well into the 2000s. Therefore they demanded that we commit to properly support that platform as a prerequisite for their investment. And so I, and two other developers were put into a team, and tasked with implementing that back-port.\n\nIt took the three of us a whole year to build it. Getting it to function properly on that hack of an operating system was a hell of a task, but we succeeded. We deployed it into production, and since it was an Internet client, we were able to track usage numbers: several months into production we had all of three users! I don’t think we ever got over 10 users before we killed that version about a year later.\n\nAnd so we spent three man-years on a product that though deployed to production, never saw any noticeable use. The alternative cost to the company was significant, and really hurt us. But we did get several million dollars of Softbank money, and a few years later, we went public on the Nasdaq. By the year 2000 the company reached a valuation of over two billion dollars!\n\nAnd then the bubble burst …\n\nFortunately for me, I had managed to cash out a portion of my stock options by then. Also I had gotten to work on several very interesting projects in that company, after that doomed one. As a result, I now have pleasant memories of that period. Except for that one, year long waste of time.', 'aiModelVersion': '1'}",0.8357
Richard Muller,Updated 6y,Is coding really boring and hard?,"Coding is the ultimate computer game. It is you vs. the computer. You are trying to enslave it, to get it to do exactly what you want it to do. It resists in every way possible; it is worse than a teenager at finding tiny little minuscule things you didn’t get precisely right and using them to defeat you. Sometimes they hide what they did and it is your struggle to find it and correct it.

Then the ultimate joy: your program runs, and gives an answer that looks right (but it might not be exactly what you expected). You’ve won! You enslaved the computer, if only on this one task. You defeated it! Congratulations! Show your friends. Celebrate.

Coding is certainly hard. But it is never boring.

Time to move on to the next level, and to program something more challenging.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/9t2soqx73n04pid8', 'title': 'Is coding really boring and hard?', 'score': {'original': 0.1565, 'ai': 0.8435}, 'blocks': [{'text': 'Coding is the ultimate computer game. It is you vs. the computer. You are trying to enslave it, to get it to do exactly what you want it to do. It resists in every way possible; it is worse than a teenager at finding tiny little minuscule things you didn’t get precisely right and using them to defeat you. Sometimes they hide what they did and it is your struggle to find it and correct it.\n\nThen the ultimate joy: your program runs, and gives an answer that looks right (but it might not be exactly what you expected). You’ve won! You enslaved the computer, if only on this one task. You defeated it! Congratulations! Show your friends. Celebrate.\n\nCoding is certainly hard. But it is never boring.\n\nTime to move on to the next level, and to program something more challenging.', 'result': {'fake': 0.8435, 'real': 0.1565}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984307, 'subscription': 0, 'content': 'Coding is the ultimate computer game. It is you vs. the computer. You are trying to enslave it, to get it to do exactly what you want it to do. It resists in every way possible; it is worse than a teenager at finding tiny little minuscule things you didn’t get precisely right and using them to defeat you. Sometimes they hide what they did and it is your struggle to find it and correct it.\n\nThen the ultimate joy: your program runs, and gives an answer that looks right (but it might not be exactly what you expected). You’ve won! You enslaved the computer, if only on this one task. You defeated it! Congratulations! Show your friends. Celebrate.\n\nCoding is certainly hard. But it is never boring.\n\nTime to move on to the next level, and to program something more challenging.', 'aiModelVersion': '1'}",0.1565
Alan Mellor,2y,"Coding interviews that don’t ask DS/Algorithmic brain teasers, rather they give you an assignment based on real life software engineering problems (""hiring without whiteboards"" they say) - Are they good enough to judge a candidate's potential?","Our company has run interviews where three of us work together on a simple coding kata.

There’s a starting brief, a utility class and an initial failing unit test. You can choose to delete it and start another way if you want.

As we work together, we learn a lot about how you think, your code and design style, your approach to testing, naming, technical knowledge, clean code. We see what you do when you hit a problem. How you Google details. And what you are like to work with.

This is a very inclusive test. Experienced devs can give us a masterclass in how to write great code and talk us through the trade offs. They can show off TDD and SOLID.

less experienced devs can show they have the basics covered: decent enough code.

We add a normal talk interview to this.

So far, we’ve not had bad hires. Candidates report they enjoyed it more than exam paper or whiteboard style.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/3m21luygvi64ohqe', 'title': 'Coding interviews that don’t ask DS/Algorithmic brain teasers, rather they give you an assignment based on real life software engineering problems (""hiring without whiteboards"" they say) - Are they good enough to judge a candidate\'s potential?', 'score': {'original': 0.9983, 'ai': 0.0017}, 'blocks': [{'text': 'Our company has run interviews where three of us work together on a simple coding kata.\n\nThere’s a starting brief, a utility class and an initial failing unit test. You can choose to delete it and start another way if you want.\n\nAs we work together, we learn a lot about how you think, your code and design style, your approach to testing, naming, technical knowledge, clean code. We see what you do when you hit a problem. How you Google details. And what you are like to work with.\n\nThis is a very inclusive test. Experienced devs can give us a masterclass in how to write great code and talk us through the trade offs. They can show off TDD and SOLID.\n\nless experienced devs can show they have the basics covered: decent enough code.\n\nWe add a normal talk interview to this.\n\nSo far, we’ve not had bad hires. Candidates report they enjoyed it more than exam paper or whiteboard style.', 'result': {'fake': 0.0017, 'real': 0.9983}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984305, 'subscription': 0, 'content': 'Our company has run interviews where three of us work together on a simple coding kata.\n\nThere’s a starting brief, a utility class and an initial failing unit test. You can choose to delete it and start another way if you want.\n\nAs we work together, we learn a lot about how you think, your code and design style, your approach to testing, naming, technical knowledge, clean code. We see what you do when you hit a problem. How you Google details. And what you are like to work with.\n\nThis is a very inclusive test. Experienced devs can give us a masterclass in how to write great code and talk us through the trade offs. They can show off TDD and SOLID.\n\nless experienced devs can show they have the basics covered: decent enough code.\n\nWe add a normal talk interview to this.\n\nSo far, we’ve not had bad hires. Candidates report they enjoyed it more than exam paper or whiteboard style.', 'aiModelVersion': '1'}",0.9983
David Seidman,4y,Do all the free food and perks offered by tech giants really increase a software engineer’s productivity?,"Yes, and they help with teamwork too.

Breakfast usually closes early and dinner opens late. This helps nudge people towards working a few extras minutes, which can easily turn into an extra hour per day.

Employees can take what feels like a long lunch and it'll still only take 45 minutes end to end. And it makes it easy to eat and work at your desk.

But, in practice, many teams eat together. It's great for building teamwork and camaraderie, and you often wind up discussing work.

It's actually not very expensive for Google to provide this benefit, because they can buy in huge quantities and because food just isn't that expensive compared to a software engineer’s salary.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/vyjp3l9t1dahi6x0', 'title': 'Do all the free food and perks offered by tech giants really increase a software engineer’s productivity?', 'score': {'original': 0.9904, 'ai': 0.0096}, 'blocks': [{'text': ""Yes, and they help with teamwork too.\n\nBreakfast usually closes early and dinner opens late. This helps nudge people towards working a few extras minutes, which can easily turn into an extra hour per day.\n\nEmployees can take what feels like a long lunch and it'll still only take 45 minutes end to end. And it makes it easy to eat and work at your desk.\n\nBut, in practice, many teams eat together. It's great for building teamwork and camaraderie, and you often wind up discussing work.\n\nIt's actually not very expensive for Google to provide this benefit, because they can buy in huge quantities and because food just isn't that expensive compared to a software engineer’s salary."", 'result': {'fake': 0.0096, 'real': 0.9904}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984303, 'subscription': 0, 'content': ""Yes, and they help with teamwork too.\n\nBreakfast usually closes early and dinner opens late. This helps nudge people towards working a few extras minutes, which can easily turn into an extra hour per day.\n\nEmployees can take what feels like a long lunch and it'll still only take 45 minutes end to end. And it makes it easy to eat and work at your desk.\n\nBut, in practice, many teams eat together. It's great for building teamwork and camaraderie, and you often wind up discussing work.\n\nIt's actually not very expensive for Google to provide this benefit, because they can buy in huge quantities and because food just isn't that expensive compared to a software engineer’s salary."", 'aiModelVersion': '1'}",0.9904
Xin Li,4y,"What screams ""You're a mediocre software engineer""?","One common trait of a mediocre engineer is someone who fixes a problem by applying a superficial patch, without understanding the root cause. Say you had the following code:

final dataManager = getDataManager(…); 
dataManager.loadStuff(); 

Everything worked great for the first 6 months, and then suddenly dataManager started being occasionally null, and line 2 started throwing null pointer exceptions. A mediocre engineer might simply insert a null check like this:

final dataManager = getDataManager(…); 
if (dataManager == null) return; 
dataManager.loadStuff(); 

A good engineer would dig deeper to fully understand the cause of the null. After the investigation, the correct solution may still be adding a simple null check. But until you do that, you don’t know what’s really going on.

You do this kind of lazy fixes often enough, and your system becomes incredibly brittle, with all kinds of strange edge case behaviors.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/mobf5hdj1v0usk8c', 'title': 'What screams ""You\'re a mediocre software engineer""?', 'score': {'original': 0.9961, 'ai': 0.0039}, 'blocks': [{'text': 'One common trait of a mediocre engineer is someone who fixes a problem by applying a superficial patch, without understanding the root cause. Say you had the following code:\n\nfinal dataManager = getDataManager(…);\xa0\ndataManager.loadStuff();\xa0\n\nEverything worked great for the first 6 months, and then suddenly dataManager started being occasionally null, and line 2 started throwing null pointer exceptions. A mediocre engineer might simply insert a null check like this:\n\nfinal dataManager = getDataManager(…);\xa0\nif (dataManager == null) return;\xa0\ndataManager.loadStuff();\xa0\n\nA good engineer would dig deeper to fully understand the cause of the null. After the investigation, the correct solution may still be adding a simple null check. But until you do that, you don’t know what’s really going on.\n\nYou do this kind of lazy fixes often enough, and your system becomes incredibly brittle, with all kinds of strange edge case behaviors.', 'result': {'fake': 0.0039, 'real': 0.9961}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984301, 'subscription': 0, 'content': 'One common trait of a mediocre engineer is someone who fixes a problem by applying a superficial patch, without understanding the root cause. Say you had the following code:\n\nfinal dataManager = getDataManager(…);\xa0\ndataManager.loadStuff();\xa0\n\nEverything worked great for the first 6 months, and then suddenly dataManager started being occasionally null, and line 2 started throwing null pointer exceptions. A mediocre engineer might simply insert a null check like this:\n\nfinal dataManager = getDataManager(…);\xa0\nif (dataManager == null) return;\xa0\ndataManager.loadStuff();\xa0\n\nA good engineer would dig deeper to fully understand the cause of the null. After the investigation, the correct solution may still be adding a simple null check. But until you do that, you don’t know what’s really going on.\n\nYou do this kind of lazy fixes often enough, and your system becomes incredibly brittle, with all kinds of strange edge case behaviors.', 'aiModelVersion': '1'}",0.9961
Mike Lewis,Updated 2y,What are the main reasons that even good software engineers don’t get hired?,"In my case,

I’m too old. I had just finished a contract writing air traffic control software for Lockheed Martin and applied to do the same at Thales. They turned me down on the basis that there were “too many jobs” on my résumé. I explained that there were a lot of jobs because I was a contractor but they wouldn’t budge. I suspect their “too many jobs” is a legal way of saying I’m too old. That was a big shock to me as Lockheed Martin said I got the job because I had a lot of experience. They wanted someone with more than twenty years experience so they didn’t kill people.
Inappropriate interview questions. When I applied for an embedded programming position, I was asked computer science questions such as how to write a Sudoku solver and how to solve the eight queens problem. (Apparently, you can’t solve the one queen problem and scale up ;-) There were no embedded programming questions like the various kinds of I/O, how to squeeze the last ounce of performance out of a slow CPU, when to use DMA, how to use JTAG, a CRO or a protocol analyser, how to change just a few bits in a register reliably or how to handle big and little endian problems. My background is electronic engineering which I have found very useful when writing embedded programs, not computer science.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/jkxrn23wgilpoufz', 'title': 'What are the main reasons that even good software engineers don’t get hired?', 'score': {'original': 0.7513, 'ai': 0.2487}, 'blocks': [{'text': 'In my case,\n\nI’m too old. I had just finished a contract writing air traffic control software for Lockheed Martin and applied to do the same at Thales. They turned me down on the basis that there were “too many jobs” on my résumé. I explained that there were a lot of jobs because I was a contractor but they wouldn’t budge. I suspect their “too many jobs” is a legal way of saying I’m too old. That was a big shock to me as Lockheed Martin said I got the job because I had a lot of experience. They wanted someone with more than twenty years experience so they didn’t kill people.\nInappropriate interview questions. When I applied for an embedded programming position, I was asked computer science questions such as how to write a Sudoku solver and how to solve the eight queens problem. (Apparently, you can’t solve the one queen problem and scale up ;-) There were no embedded programming questions like the various kinds of I/O, how to squeeze the last ounce of performance out of a slow CPU, when to use DMA, how to use JTAG, a CRO or a protocol analyser, how to change just a few bits in a register reliably or how to handle big and little endian problems. My background is electronic engineering which I have found very useful when writing embedded programs, not computer science.', 'result': {'fake': 0.2487, 'real': 0.7513}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984298, 'subscription': 0, 'content': 'In my case,\n\nI’m too old. I had just finished a contract writing air traffic control software for Lockheed Martin and applied to do the same at Thales. They turned me down on the basis that there were “too many jobs” on my résumé. I explained that there were a lot of jobs because I was a contractor but they wouldn’t budge. I suspect their “too many jobs” is a legal way of saying I’m too old. That was a big shock to me as Lockheed Martin said I got the job because I had a lot of experience. They wanted someone with more than twenty years experience so they didn’t kill people.\nInappropriate interview questions. When I applied for an embedded programming position, I was asked computer science questions such as how to write a Sudoku solver and how to solve the eight queens problem. (Apparently, you can’t solve the one queen problem and scale up ;-) There were no embedded programming questions like the various kinds of I/O, how to squeeze the last ounce of performance out of a slow CPU, when to use DMA, how to use JTAG, a CRO or a protocol analyser, how to change just a few bits in a register reliably or how to handle big and little endian problems. My background is electronic engineering which I have found very useful when writing embedded programs, not computer science.', 'aiModelVersion': '1'}",0.7513
Praveen Jaya Kumar,Updated 4y,What is it like to be a software engineer in India?,"Born.
Study.
Getting placed.
Joining.
Project allocation.
Code.
Commit.
Build & Deploy.
Fix defects.
Escalation mails.
Please finish mandatory trainings.
Please fill your time sheet.
Standup meetings.
Status calls.
Shall I share my screen?
Am I audible?
We will let you know.
Sorry, I was on mute.
Sweets at my desk.
Team lunch / dinner.
Team outing.
I will be on sick leave today.
Please transfer ₹100 for XXX's birthday cake cutting.
Please transfer ₹150 for XXX's farewell cake cutting.
Knowledge Transfer (KT).
Reverse KT.
Performance discussion.
Hike. ( not always )
Promotion.
Onsite opportunities. ( depends on project )
Today is my last day. Keep in touch. My personal email id is xxx@xxx.com.
Steps 3 to 30 on loop. ( Job switches )
Death.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/sze95wxvubt3yjc2', 'title': 'What is it like to be a software engineer in India?', 'score': {'original': 0.9979, 'ai': 0.0021}, 'blocks': [{'text': ""Born.\nStudy.\nGetting placed.\nJoining.\nProject allocation.\nCode.\nCommit.\nBuild & Deploy.\nFix defects.\nEscalation mails.\nPlease finish mandatory trainings.\nPlease fill your time sheet.\nStandup meetings.\nStatus calls.\nShall I share my screen?\nAm I audible?\nWe will let you know.\nSorry, I was on mute.\nSweets at my desk.\nTeam lunch / dinner.\nTeam outing.\nI will be on sick leave today.\nPlease transfer ₹100 for XXX's birthday cake cutting.\nPlease transfer ₹150 for XXX's farewell cake cutting.\nKnowledge Transfer (KT).\nReverse KT.\nPerformance discussion.\nHike. ( not always )\nPromotion.\nOnsite opportunities. ( depends on project )\nToday is my last day. Keep in touch. My personal email id is xxx@xxx.com.\nSteps 3 to 30 on loop. ( Job switches )\nDeath."", 'result': {'fake': 0.0021, 'real': 0.9979}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984296, 'subscription': 0, 'content': ""Born.\nStudy.\nGetting placed.\nJoining.\nProject allocation.\nCode.\nCommit.\nBuild & Deploy.\nFix defects.\nEscalation mails.\nPlease finish mandatory trainings.\nPlease fill your time sheet.\nStandup meetings.\nStatus calls.\nShall I share my screen?\nAm I audible?\nWe will let you know.\nSorry, I was on mute.\nSweets at my desk.\nTeam lunch / dinner.\nTeam outing.\nI will be on sick leave today.\nPlease transfer ₹100 for XXX's birthday cake cutting.\nPlease transfer ₹150 for XXX's farewell cake cutting.\nKnowledge Transfer (KT).\nReverse KT.\nPerformance discussion.\nHike. ( not always )\nPromotion.\nOnsite opportunities. ( depends on project )\nToday is my last day. Keep in touch. My personal email id is xxx@xxx.com.\nSteps 3 to 30 on loop. ( Job switches )\nDeath."", 'aiModelVersion': '1'}",0.9979
Søren Holstebroe,4y,"As a software engineer, what makes you roll your eyes every time you hear it?","Password rules.

A puppy dies every time a user gets the dreaded “your password should contain at least one number, one special character and one capital letter”.

So you have this nice high entropy alphabet with 26 unique chars that are easy to remember and you force the user to replace one or more of those with low entropy chars (about 5 for common chosen numbers and about 5 for typical special chars) that are difficult to remember. Even password cracker scripts from the early nineties knew how to append a capital letter and 1,2,3,9,0 or #.!,% at either end of the password when brute forcing.

Or as XKCD said it:","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/83n1glt4fkxp67ja', 'title': 'As a software engineer, what makes you roll your eyes every time you hear it?', 'score': {'original': 0.9973, 'ai': 0.0027}, 'blocks': [{'text': 'Password rules.\n\nA puppy dies every time a user gets the dreaded “your password should contain at least one number, one special character and one capital letter”.\n\nSo you have this nice high entropy alphabet with 26 unique chars that are easy to remember and you force the user to replace one or more of those with low entropy chars (about 5 for common chosen numbers and about 5 for typical special chars) that are difficult to remember. Even password cracker scripts from the early nineties knew how to append a capital letter and 1,2,3,9,0 or #.!,% at either end of the password when brute forcing.\n\nOr as XKCD said it:', 'result': {'fake': 0.0027, 'real': 0.9973}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984294, 'subscription': 0, 'content': 'Password rules.\n\nA puppy dies every time a user gets the dreaded “your password should contain at least one number, one special character and one capital letter”.\n\nSo you have this nice high entropy alphabet with 26 unique chars that are easy to remember and you force the user to replace one or more of those with low entropy chars (about 5 for common chosen numbers and about 5 for typical special chars) that are difficult to remember. Even password cracker scripts from the early nineties knew how to append a capital letter and 1,2,3,9,0 or #.!,% at either end of the password when brute forcing.\n\nOr as XKCD said it:', 'aiModelVersion': '1'}",0.9973
Brian Bi,5y,How does Google get new software engineers up to speed?,"At Google, it’s generally believed that it takes around 6 to 12 months for a Noogler (new Googler) to become productive—the first few months are an investment by the company in Nooglers, in the hope that they will eventually create net value for the company. What happens in those first few months varies. As Sam Hansen points out, the first two weeks are reserved for training courses, but even then there is a lot of variation. Only the first week is really mandatory; your manager can let you know which of the courses in the second week would be relevant to your work, and which ones would not. For example, there are two well-known courses about the back end at Google—one about search, and one about ads. I did not attend the one about ads, since Google Scholar does not display any ads. Attending courses is not necessarily limited to the first two weeks, either; some courses do not run that often.

There’s an (informal?) policy at Google that each Noogler can (with manager approval) buy three books on the company’s dime to help them learn subject matter relevant to their work. Some Nooglers may want to read a book from The Definitive C++ Book Guide and List
 cover-to-cover, for example. I didn’t need to study the basics of C++ when I arrived, but I did get C++ Concurrency in Action by Anthony Williams, and spent some time reading it before I realized that it wasn’t really that relevant. (I’ve never had to use atomic variables or lock-free data structures, although my TL does tell me to be mindful of the costs of locking sometimes.)

Some Nooglers are informally assigned a mentor on their team, someone they’re encouraged to approach when they don’t know how to do something (and, believe me, this happens a lot during the first 6 months). Some are not. I suspect your experience will be much better if you do have a mentor, but I don’t know how you can guarantee that. (Google is a big company, and the World Wide Web unfortunately doesn’t have intel on all the teams within Google.)

All Nooglers will be assigned “starter projects” at first, gradually moving on to more technically complex projects. There’s no sharp dividing line between “starter projects” and “real projects”. One of my teammates was assigned, as his first project, something that my manager and TL believed would be a starter project, but turned out to be massively more complex than anticipated, and took a full two years to properly complete. I, on the other hand, was assigned a series of fairly small projects for the first year and a half of my tenure at Google, before I was ready for a major project where I made most of the design decisions myself.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wfnmgath23091r4i', 'title': 'How does Google get new software engineers up to speed?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'At Google, it’s generally believed that it takes around 6 to 12 months for a Noogler (new Googler) to become productive—the first few months are an investment by the company in Nooglers, in the hope that they will eventually create net value for the company. What happens in those first few months varies. As Sam Hansen points out, the first two weeks are reserved for training courses, but even then there is a lot of variation. Only the first week is really mandatory; your manager can let you know which of the courses in the second week would be relevant to your work, and which ones would not. For example, there are two well-known courses about the back end at Google—one about search, and one about ads. I did not attend the one about ads, since Google Scholar does not display any ads. Attending courses is not necessarily limited to the first two weeks, either; some courses do not run that often.\n\nThere’s an (informal?) policy at Google that each Noogler can (with manager approval) buy three books on the company’s dime to help them learn subject matter relevant to their work. Some Nooglers may want to read a book from The Definitive C++ Book Guide and List\n cover-to-cover, for example. I didn’t need to study the basics of C++ when I arrived, but I did get C++ Concurrency in Action by Anthony Williams, and spent some time reading it before I realized that it wasn’t really that relevant. (I’ve never had to use atomic variables or lock-free data structures, although my TL does tell me to be mindful of the costs of locking sometimes.)\n\nSome Nooglers are informally assigned a mentor on their team, someone they’re encouraged to approach when they don’t know how to do something (and, believe me, this happens a lot during the first 6 months). Some are not. I suspect your experience will be much better if you do have a mentor, but I don’t know how you can guarantee that. (Google is a big company, and the World Wide Web unfortunately doesn’t have intel on all the teams within Google.)\n\nAll Nooglers will be assigned “starter projects” at first, gradually moving on to more technically complex projects. There’s no sharp dividing line between “starter projects” and “real projects”. One of my teammates was assigned, as his first project, something that my manager and TL believed would be a starter project, but turned out to be massively more complex than anticipated, and took a full two years to properly complete. I, on the other hand, was assigned a series of fairly small projects for the first year and a half of my tenure at Google, before I was ready for a major project where I made most of the design decisions myself.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984289, 'subscription': 0, 'content': 'At Google, it’s generally believed that it takes around 6 to 12 months for a Noogler (new Googler) to become productive—the first few months are an investment by the company in Nooglers, in the hope that they will eventually create net value for the company. What happens in those first few months varies. As Sam Hansen points out, the first two weeks are reserved for training courses, but even then there is a lot of variation. Only the first week is really mandatory; your manager can let you know which of the courses in the second week would be relevant to your work, and which ones would not. For example, there are two well-known courses about the back end at Google—one about search, and one about ads. I did not attend the one about ads, since Google Scholar does not display any ads. Attending courses is not necessarily limited to the first two weeks, either; some courses do not run that often.\n\nThere’s an (informal?) policy at Google that each Noogler can (with manager approval) buy three books on the company’s dime to help them learn subject matter relevant to their work. Some Nooglers may want to read a book from The Definitive C++ Book Guide and List\n cover-to-cover, for example. I didn’t need to study the basics of C++ when I arrived, but I did get C++ Concurrency in Action by Anthony Williams, and spent some time reading it before I realized that it wasn’t really that relevant. (I’ve never had to use atomic variables or lock-free data structures, although my TL does tell me to be mindful of the costs of locking sometimes.)\n\nSome Nooglers are informally assigned a mentor on their team, someone they’re encouraged to approach when they don’t know how to do something (and, believe me, this happens a lot during the first 6 months). Some are not. I suspect your experience will be much better if you do have a mentor, but I don’t know how you can guarantee that. (Google is a big company, and the World Wide Web unfortunately doesn’t have intel on all the teams within Google.)\n\nAll Nooglers will be assigned “starter projects” at first, gradually moving on to more technically complex projects. There’s no sharp dividing line between “starter projects” and “real projects”. One of my teammates was assigned, as his first project, something that my manager and TL believed would be a starter project, but turned out to be massively more complex than anticipated, and took a full two years to properly complete. I, on the other hand, was assigned a series of fairly small projects for the first year and a half of my tenure at Google, before I was ready for a major project where I made most of the design decisions myself.', 'aiModelVersion': '1'}",0.9996
Sean Kernan,4y,What are some examples of little known software giants?,"Because of Quora, I have a lot of Indian connections on basically every social platform I operate on.

Specifically, I began noticing a number of Indians on Instagram that were wandering around in Ireland. It caught my attention, “Indians in Ireland?”

Not what I was expecting. It seems like the opposite place I’d expect to see Indians. I’m of Irish descent so it was particularly interesting.

The trend of seeing this continued, after doing some digging, I now have full clarity on:

Ireland is a software engineering powerhouse.

Who woulda thunk?

It started more than 60 years ago, IBM and a number of other US Software companies set up satellite offices in Dublin. From there, a tech culture emerged, and Ireland’s young population began filtering into the software engineering sector.

As those companies began growing, they began reaching abroad to find software talent.

Hmmm. Where can you find a large population, with a gajillion software engineers?

Aha!

India!

And thus—many top Indian students find themselves in the emerald isle.

Ireland has more than 900 software companies. But specifically, US companies like Google, Facebook, and Twitter use Ireland as a home base for European services. (Source: What attracts big tech companies to Ireland. Bryant, Martin)

As mentioned before, the ecosystem of talent started in Ireland and is already there. Tech companies love building offices next to each other so that they can poach talent. Additionally, taxes are low in Ireland and the business laws are very favorable to tech companies.

And thus, the tiny island of Ireland is a software supergiant. They export more than $18 billion in software revenue each year.

If you are going to work abroad, I wouldn’t blame you for choosing Ireland.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/839dq02s6fikblmp', 'title': 'What are some examples of little known software giants?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Because of Quora, I have a lot of Indian connections on basically every social platform I operate on.\n\nSpecifically, I began noticing a number of Indians on Instagram that were wandering around in Ireland. It caught my attention, “Indians in Ireland?”\n\nNot what I was expecting. It seems like the opposite place I’d expect to see Indians. I’m of Irish descent so it was particularly interesting.\n\nThe trend of seeing this continued, after doing some digging, I now have full clarity on:\n\nIreland is a software engineering powerhouse.\n\nWho woulda thunk?\n\nIt started more than 60 years ago, IBM and a number of other US Software companies set up satellite offices in Dublin. From there, a tech culture emerged, and Ireland’s young population began filtering into the software engineering sector.\n\nAs those companies began growing, they began reaching abroad to find software talent.\n\nHmmm. Where can you find a large population, with a gajillion software engineers?\n\nAha!\n\nIndia!\n\nAnd thus—many top Indian students find themselves in the emerald isle.\n\nIreland has more than 900 software companies. But specifically, US companies like Google, Facebook, and Twitter use Ireland as a home base for European services. (Source: What attracts big tech companies to Ireland. Bryant, Martin)\n\nAs mentioned before, the ecosystem of talent started in Ireland and is already there. Tech companies love building offices next to each other so that they can poach talent. Additionally, taxes are low in Ireland and the business laws are very favorable to tech companies.\n\nAnd thus, the tiny island of Ireland is a software supergiant. They export more than $18 billion in software revenue each year.\n\nIf you are going to work abroad, I wouldn’t blame you for choosing Ireland.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984286, 'subscription': 0, 'content': 'Because of Quora, I have a lot of Indian connections on basically every social platform I operate on.\n\nSpecifically, I began noticing a number of Indians on Instagram that were wandering around in Ireland. It caught my attention, “Indians in Ireland?”\n\nNot what I was expecting. It seems like the opposite place I’d expect to see Indians. I’m of Irish descent so it was particularly interesting.\n\nThe trend of seeing this continued, after doing some digging, I now have full clarity on:\n\nIreland is a software engineering powerhouse.\n\nWho woulda thunk?\n\nIt started more than 60 years ago, IBM and a number of other US Software companies set up satellite offices in Dublin. From there, a tech culture emerged, and Ireland’s young population began filtering into the software engineering sector.\n\nAs those companies began growing, they began reaching abroad to find software talent.\n\nHmmm. Where can you find a large population, with a gajillion software engineers?\n\nAha!\n\nIndia!\n\nAnd thus—many top Indian students find themselves in the emerald isle.\n\nIreland has more than 900 software companies. But specifically, US companies like Google, Facebook, and Twitter use Ireland as a home base for European services. (Source: What attracts big tech companies to Ireland. Bryant, Martin)\n\nAs mentioned before, the ecosystem of talent started in Ireland and is already there. Tech companies love building offices next to each other so that they can poach talent. Additionally, taxes are low in Ireland and the business laws are very favorable to tech companies.\n\nAnd thus, the tiny island of Ireland is a software supergiant. They export more than $18 billion in software revenue each year.\n\nIf you are going to work abroad, I wouldn’t blame you for choosing Ireland.', 'aiModelVersion': '1'}",0.9998
Sofia Everly,4y,How different would be the situation of a programmer who has 1 year of experience vs a programmer with 20 years of experience? What is something both face?,I’m a developer with over 20 years of experience. We hired a junior developer with 1.5 years of experience. We worked together for a year. I noticed right away he was struggling. I don’t normally take anyone under my wing but one day he was working on an issue and didn’t know where to start. I heard him ask several people but didn’t really get anywhere so I walked to his cube and asked what he was working on. He explained and communicated his frustration. I smiled and told him where I would start. And then listed 3 steps to help him figure out the problem. He figured it out that day. After that I began mentoring him on front end and back end. I talked him through C# and entity framework. I taught him about bootstrap and how to visualize as he worked. He also learned Angular from me. He taught me new approaches to testing and architecture patterns that he learned at his last job. I forgot what it was like to be excited about learning new things. He called me the Queen. I called him the devkid til I finally learned his name. He made me realize I reached a level as a developer in which I was finally able to give back. It was a good experience for us both.,"{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/gsnujl7m0xbk3dra', 'title': 'How different would be the situation of a programmer who has 1 year of experience vs a programmer with 20 years of experience? What is something both face?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'I’m a developer with over 20 years of experience. We hired a junior developer with 1.5 years of experience. We worked together for a year. I noticed right away he was struggling. I don’t normally take anyone under my wing but one day he was working on an issue and didn’t know where to start. I heard him ask several people but didn’t really get anywhere so I walked to his cube and asked what he was working on. He explained and communicated his frustration. I smiled and told him where I would start. And then listed 3 steps to help him figure out the problem. He figured it out that day. After that I began mentoring him on front end and back end. I talked him through C# and entity framework. I taught him about bootstrap and how to visualize as he worked. He also learned Angular from me. He taught me new approaches to testing and architecture patterns that he learned at his last job. I forgot what it was like to be excited about learning new things. He called me the Queen. I called him the devkid til I finally learned his name. He made me realize I reached a level as a developer in which I was finally able to give back. It was a good experience for us both.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984283, 'subscription': 0, 'content': 'I’m a developer with over 20 years of experience. We hired a junior developer with 1.5 years of experience. We worked together for a year. I noticed right away he was struggling. I don’t normally take anyone under my wing but one day he was working on an issue and didn’t know where to start. I heard him ask several people but didn’t really get anywhere so I walked to his cube and asked what he was working on. He explained and communicated his frustration. I smiled and told him where I would start. And then listed 3 steps to help him figure out the problem. He figured it out that day. After that I began mentoring him on front end and back end. I talked him through C# and entity framework. I taught him about bootstrap and how to visualize as he worked. He also learned Angular from me. He taught me new approaches to testing and architecture patterns that he learned at his last job. I forgot what it was like to be excited about learning new things. He called me the Queen. I called him the devkid til I finally learned his name. He made me realize I reached a level as a developer in which I was finally able to give back. It was a good experience for us both.', 'aiModelVersion': '1'}",0.9997
Dmitry Murashenkov,5y,How difficult is it to find highly talented software developers?,"Dev: Alright, let the competition begin!
Startup A: We will give you 50% of the revenue!
Startup B: To hell with it, we will give you 100%!
Startup A: Eh… we will give you 150%!

TL;DR: Nearly impossible. If you are a Google-sized company, of course. Totally impossible in other cases.

I run an outsourcing company. Our statistics so far:

500 CVs viewed per month
50 interview invitations sent per month
10 interviews conducted per month
1 job offer made (and usually refused) per month

And here we are looking for a mid-level developers in Russia.

Initially we wanted to hire some top-notch engineers and were ready to pay “any sum of money that would fit on the check”. We sent many invitations. Best people laughed at us and didn’t bother. Those who agreed - knew nothing. After that we had to shift our expectations greatly.

Still, we manage to find good developers from time to time. None of them can be considered super-expert, but as a team they cooperate extremely effectively, get the job done and all of them have that engineering spirit and innate curiosity that causes them to improve.

This is as good as an average company can get.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/zyl51f7qn8cdihuw', 'title': 'How difficult is it to find highly talented software developers?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'Dev: Alright, let the competition begin!\nStartup A: We will give you 50% of the revenue!\nStartup B: To hell with it, we will give you 100%!\nStartup A: Eh… we will give you 150%!\n\nTL;DR: Nearly impossible. If you are a Google-sized company, of course. Totally impossible in other cases.\n\nI run an outsourcing company. Our statistics so far:\n\n500 CVs viewed per month\n50 interview invitations sent per month\n10 interviews conducted per month\n1 job offer made (and usually refused) per month\n\nAnd here we are looking for a mid-level developers in Russia.\n\nInitially we wanted to hire some top-notch engineers and were ready to pay “any sum of money that would fit on the check”. We sent many invitations. Best people laughed at us and didn’t bother. Those who agreed - knew nothing. After that we had to shift our expectations greatly.\n\nStill, we manage to find good developers from time to time. None of them can be considered super-expert, but as a team they cooperate extremely effectively, get the job done and all of them have that engineering spirit and innate curiosity that causes them to improve.\n\nThis is as good as an average company can get.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984281, 'subscription': 0, 'content': 'Dev: Alright, let the competition begin!\nStartup A: We will give you 50% of the revenue!\nStartup B: To hell with it, we will give you 100%!\nStartup A: Eh… we will give you 150%!\n\nTL;DR: Nearly impossible. If you are a Google-sized company, of course. Totally impossible in other cases.\n\nI run an outsourcing company. Our statistics so far:\n\n500 CVs viewed per month\n50 interview invitations sent per month\n10 interviews conducted per month\n1 job offer made (and usually refused) per month\n\nAnd here we are looking for a mid-level developers in Russia.\n\nInitially we wanted to hire some top-notch engineers and were ready to pay “any sum of money that would fit on the check”. We sent many invitations. Best people laughed at us and didn’t bother. Those who agreed - knew nothing. After that we had to shift our expectations greatly.\n\nStill, we manage to find good developers from time to time. None of them can be considered super-expert, but as a team they cooperate extremely effectively, get the job done and all of them have that engineering spirit and innate curiosity that causes them to improve.\n\nThis is as good as an average company can get.', 'aiModelVersion': '1'}",0.9995
John Reese,6y,What are some great truths of computer programming?,"Here is the big one, as far as I'm concerned:

If you're battling an inexplicable bug, and you find yourself saying, “This doesn't make any sense!”, then this is a sign that you are making an invalid assumption about what's on. It could be you're in a different environment than you thought you were in, or that your variable names are correct so you don't need to check them, or that you're connected to a different database. It's often something that seems unimportant, so you tend to overlook it as you search for a solution.

The first thing to do is to ask, What assumptions am I making? Go through the list, check them all, even the ones that seem stupid.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/nhkcput6i9efxqmv', 'title': 'What are some great truths of computer programming?', 'score': {'original': 0.0042, 'ai': 0.9958}, 'blocks': [{'text': ""Here is the big one, as far as I'm concerned:\n\nIf you're battling an inexplicable bug, and you find yourself saying, “This doesn't make any sense!”, then this is a sign that you are making an invalid assumption about what's on. It could be you're in a different environment than you thought you were in, or that your variable names are correct so you don't need to check them, or that you're connected to a different database. It's often something that seems unimportant, so you tend to overlook it as you search for a solution.\n\nThe first thing to do is to ask, What assumptions am I making? Go through the list, check them all, even the ones that seem stupid."", 'result': {'fake': 0.9958, 'real': 0.0042}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984279, 'subscription': 0, 'content': ""Here is the big one, as far as I'm concerned:\n\nIf you're battling an inexplicable bug, and you find yourself saying, “This doesn't make any sense!”, then this is a sign that you are making an invalid assumption about what's on. It could be you're in a different environment than you thought you were in, or that your variable names are correct so you don't need to check them, or that you're connected to a different database. It's often something that seems unimportant, so you tend to overlook it as you search for a solution.\n\nThe first thing to do is to ask, What assumptions am I making? Go through the list, check them all, even the ones that seem stupid."", 'aiModelVersion': '1'}",0.0042
Kurt Guntheroth,4y,What is it like to be a retired software developer?,"I am somewhat involuntarily retired. It seems that while I’m smart enough to write books about C++, I’m not smart enough to write C++ code for any employer I’ve contacted recently. Running head-on into ageism hurts a little, especially when you don’t feel particularly old. I’ve more-or-less given up looking for work, though every now and then I’m tempted to send a resume. The more I think about the pressures of my past work life, the more comfortable I am with the continuing decision not to get back into the fight.

As I mentioned, I’ve been writing my work experience down as a series of books. The first book, Optimized C++
, was completed in 2016, but I’m working on a second edition. A second book, a tutorial on C++ for beginners called C++ Workshop, is approaching publication. There’s a third book lurking on my computer, tentatively titled Nonstop C++. I’m pretty sure that after that third book, I’ll have said all there is to say about my career. Writing is a lot like coding, but easier. There’s plenty of code in the books too, so I am keeping up-to-date. Why? I’m not sure. It just seems like the right thing to do until the books are done at least.

One of the cool things about writing books is that I get to write a bunch of code that I always wish I’d had time to write when I was working, but which was too big or not mission-critical enough to interest my employer.

I answer a lot of questions on Quora about workplace issues, software development, and C++. Y’all seem to like me OK on Quora. Sometimes I write something about politics, which mostly falls down the well without making a splash.

There are still just as many broken things in my house as there always were, only now I can fix them at my leisure. By the time I die of old age, I imagine the house will look pretty good.

I have a lovely wife, who happens to be disabled. I just spent an hour helping her manage her pain. If I’d been at work, she would have been at home hurting, crying silently with tears rolling down her cheeks all day, until I came home to help her. I have three teenage children, all with one sort of special need or another. They have been getting actual help now, rather than being ignored because I’m out of the house all day. Focusing on them seems like the right decision.

Aside from the reduced stress load, being retired feels pretty much like the previous parts of my life. You do a lot of the same stuff. You just have more time to do it.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/j07pdqy6s24gh3ki', 'title': 'What is it like to be a retired software developer?', 'score': {'original': 0.9999, 'ai': 0.0001}, 'blocks': [{'text': 'I am somewhat involuntarily retired. It seems that while I’m smart enough to write books about C++, I’m not smart enough to write C++ code for any employer I’ve contacted recently. Running head-on into ageism hurts a little, especially when you don’t feel particularly old. I’ve more-or-less given up looking for work, though every now and then I’m tempted to send a resume. The more I think about the pressures of my past work life, the more comfortable I am with the continuing decision not to get back into the fight.\n\nAs I mentioned, I’ve been writing my work experience down as a series of books. The first book, Optimized C++\n, was completed in 2016, but I’m working on a second edition. A second book, a tutorial on C++ for beginners called C++ Workshop, is approaching publication. There’s a third book lurking on my computer, tentatively titled Nonstop C++. I’m pretty sure that after that third book, I’ll have said all there is to say about my career. Writing is a lot like coding, but easier. There’s plenty of code in the books too, so I am keeping up-to-date. Why? I’m not sure. It just seems like the right thing to do until the books are done at least.\n\nOne of the cool things about writing books is that I get to write a bunch of code that I always wish I’d had time to write when I was working, but which was too big or not mission-critical enough to interest my employer.\n\nI answer a lot of questions on Quora about workplace issues, software development, and C++. Y’all seem to like me OK on Quora. Sometimes I write something about politics, which mostly falls down the well without making a splash.\n\nThere are still just as many broken things in my house as there always were, only now I can fix them at my leisure. By the time I die of old age, I imagine the house will look pretty good.\n\nI have a lovely wife, who happens to be disabled. I just spent an hour helping her manage her pain. If I’d been at work, she would have been at home hurting, crying silently with tears rolling down her cheeks all day, until I came home to help her. I have three teenage children, all with one sort of special need or another. They have been getting actual help now, rather than being ignored because I’m out of the house all day. Focusing on them seems like the right decision.\n\nAside from the reduced stress load, being retired feels pretty much like the previous parts of my life. You do a lot of the same stuff. You just have more time to do it.', 'result': {'fake': 0.0001, 'real': 0.9999}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984274, 'subscription': 0, 'content': 'I am somewhat involuntarily retired. It seems that while I’m smart enough to write books about C++, I’m not smart enough to write C++ code for any employer I’ve contacted recently. Running head-on into ageism hurts a little, especially when you don’t feel particularly old. I’ve more-or-less given up looking for work, though every now and then I’m tempted to send a resume. The more I think about the pressures of my past work life, the more comfortable I am with the continuing decision not to get back into the fight.\n\nAs I mentioned, I’ve been writing my work experience down as a series of books. The first book, Optimized C++\n, was completed in 2016, but I’m working on a second edition. A second book, a tutorial on C++ for beginners called C++ Workshop, is approaching publication. There’s a third book lurking on my computer, tentatively titled Nonstop C++. I’m pretty sure that after that third book, I’ll have said all there is to say about my career. Writing is a lot like coding, but easier. There’s plenty of code in the books too, so I am keeping up-to-date. Why? I’m not sure. It just seems like the right thing to do until the books are done at least.\n\nOne of the cool things about writing books is that I get to write a bunch of code that I always wish I’d had time to write when I was working, but which was too big or not mission-critical enough to interest my employer.\n\nI answer a lot of questions on Quora about workplace issues, software development, and C++. Y’all seem to like me OK on Quora. Sometimes I write something about politics, which mostly falls down the well without making a splash.\n\nThere are still just as many broken things in my house as there always were, only now I can fix them at my leisure. By the time I die of old age, I imagine the house will look pretty good.\n\nI have a lovely wife, who happens to be disabled. I just spent an hour helping her manage her pain. If I’d been at work, she would have been at home hurting, crying silently with tears rolling down her cheeks all day, until I came home to help her. I have three teenage children, all with one sort of special need or another. They have been getting actual help now, rather than being ignored because I’m out of the house all day. Focusing on them seems like the right decision.\n\nAside from the reduced stress load, being retired feels pretty much like the previous parts of my life. You do a lot of the same stuff. You just have more time to do it.', 'aiModelVersion': '1'}",0.9999
Unnit Metaliya,Updated 5y,How could I pretend to be a programming geek to gain more respect in my company?,"Yes, you can. I will tell you how.

Step 1: Don’t wear formals. That’s not dress-code of geeks. Get some t-shirt or something. And specs like this.

Step 2: Now, go to some Cafe or any Public Place where people can see your screen very clearly.

Step 3: Login to your laptop and increase your brightness at maximum level.

Step 4: Go to Hacker Typer
 (hackertyper .com).

Step 5: Enter into full screen and start typing anything randomly. Site will take care of code by itself.

Let me show you.

- Press the “Alt” key 3 times to get “ACCESS GRANTED” message.

- Now, much enthusiastically keep saying, “Yes. Yes. I made it. Now, let me hack something else”.

And then press the “Esc” key to make that message disappear.

- Again, start typing randomly and press “Caps Lock” three times to get “ACCESS DENIED” message.

- Say, “Oh! Damn. What went wrong? Let me check my code again!” and press the “Esc” key.

- Start typing something and get “ACCESS GRANTED” message again.

- Now, pretend to call your partner and murmur at voice that people in your vicinity can hear you:

“After connecting many dots, much of hard-work, brainstorming and drugging myself with lots of coffees, I successfully hacked into the database, what's next?”

There you are.

A pretentious programming Super Geek.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/z4lpyjrdmwcv7qai', 'title': 'How could I pretend to be a programming geek to gain more respect in my company?', 'score': {'original': 0.9985, 'ai': 0.0015}, 'blocks': [{'text': ""Yes, you can. I will tell you how.\n\nStep 1: Don’t wear formals. That’s not dress-code of geeks. Get some t-shirt or something. And specs like this.\n\nStep 2: Now, go to some Cafe or any Public Place where people can see your screen very clearly.\n\nStep 3: Login to your laptop and increase your brightness at maximum level.\n\nStep 4: Go to Hacker Typer\n (hackertyper .com).\n\nStep 5: Enter into full screen and start typing anything randomly. Site will take care of code by itself.\n\nLet me show you.\n\n- Press the “Alt” key 3 times to get “ACCESS GRANTED” message.\n\n- Now, much enthusiastically keep saying, “Yes. Yes. I made it. Now, let me hack something else”.\n\nAnd then press the “Esc” key to make that message disappear.\n\n- Again, start typing randomly and press “Caps Lock” three times to get “ACCESS DENIED” message.\n\n- Say, “Oh! Damn. What went wrong? Let me check my code again!” and press the “Esc” key.\n\n- Start typing something and get “ACCESS GRANTED” message again.\n\n- Now, pretend to call your partner and murmur at voice that people in your vicinity can hear you:\n\n“After connecting many dots, much of hard-work, brainstorming and drugging myself with lots of coffees, I successfully hacked into the database, what's next?”\n\nThere you are.\n\nA pretentious programming Super Geek."", 'result': {'fake': 0.0015, 'real': 0.9985}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984271, 'subscription': 0, 'content': ""Yes, you can. I will tell you how.\n\nStep 1: Don’t wear formals. That’s not dress-code of geeks. Get some t-shirt or something. And specs like this.\n\nStep 2: Now, go to some Cafe or any Public Place where people can see your screen very clearly.\n\nStep 3: Login to your laptop and increase your brightness at maximum level.\n\nStep 4: Go to Hacker Typer\n (hackertyper .com).\n\nStep 5: Enter into full screen and start typing anything randomly. Site will take care of code by itself.\n\nLet me show you.\n\n- Press the “Alt” key 3 times to get “ACCESS GRANTED” message.\n\n- Now, much enthusiastically keep saying, “Yes. Yes. I made it. Now, let me hack something else”.\n\nAnd then press the “Esc” key to make that message disappear.\n\n- Again, start typing randomly and press “Caps Lock” three times to get “ACCESS DENIED” message.\n\n- Say, “Oh! Damn. What went wrong? Let me check my code again!” and press the “Esc” key.\n\n- Start typing something and get “ACCESS GRANTED” message again.\n\n- Now, pretend to call your partner and murmur at voice that people in your vicinity can hear you:\n\n“After connecting many dots, much of hard-work, brainstorming and drugging myself with lots of coffees, I successfully hacked into the database, what's next?”\n\nThere you are.\n\nA pretentious programming Super Geek."", 'aiModelVersion': '1'}",0.9985
Alan Mellor,7y,"Now that anyone can learn to code, will it become less lucrative?","They can’t though. And that’s the problem our industry faces.

You forget that what a normal person might be proud of - writing “Hello World” in JavaScript, and getting a personal Bio web page up - are nothing, absolutely nothing like real software.

The scale of effort in writing Windows, Linux, iOS, Google Chrome, Google Search, AWS, Facebook, Hotmail, Outlook … Even writing a dumb phone app. Most people can’t do it.

The barriers to equipment are lower, I agree.

The barrier to thinking is higher.

Software is nothing more than captured, executable thought.

It is getting exponentially harder, in my view.

And even with the whole of the internet available on your smartphone, I observe people ask really basic questions, like “How do I start coding?” on Quora. I love answering, and helping. But … it shows me that a person who will not type a google search query is considering entering our field.

It’s like tying your shoelaces together and asking “When can I race Usain Bolt?”

Forget about coding. Think about how you design a system like Facebook or Netflix or the public telephone network or a mobile base station. How do you support millions, billions of users? How do you guarantee service? Where do you store their data> How do you secure it? What happens if storage fails? How do you bill them? How do you not charge them twice?

None of that is answered by coding. It is very difficult, and it is mission critical.

And people capable of doing it are expensive and scarce.

We genuinely cannot spin up enough of those to keep pace with demand.

As Marc Andreesen (inventor of the browser, partner of VC firm) says, “software is eating the world”.

And it isn’t noddy little bits of scripts that he is talking about.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/sjw9lu6t8p5io2ya', 'title': 'Now that anyone can learn to code, will it become less lucrative?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'They can’t though. And that’s the problem our industry faces.\n\nYou forget that what a normal person might be proud of - writing “Hello World” in JavaScript, and getting a personal Bio web page up - are nothing, absolutely nothing like real software.\n\nThe scale of effort in writing Windows, Linux, iOS, Google Chrome, Google Search, AWS, Facebook, Hotmail, Outlook … Even writing a dumb phone app. Most people can’t do it.\n\nThe barriers to equipment are lower, I agree.\n\nThe barrier to thinking is higher.\n\nSoftware is nothing more than captured, executable thought.\n\nIt is getting exponentially harder, in my view.\n\nAnd even with the whole of the internet available on your smartphone, I observe people ask really basic questions, like “How do I start coding?” on Quora. I love answering, and helping. But … it shows me that a person who will not type a google search query is considering entering our field.\n\nIt’s like tying your shoelaces together and asking “When can I race Usain Bolt?”\n\nForget about coding. Think about how you design a system like Facebook or Netflix or the public telephone network or a mobile base station. How do you support millions, billions of users? How do you guarantee service? Where do you store their data> How do you secure it? What happens if storage fails? How do you bill them? How do you not charge them twice?\n\nNone of that is answered by coding. It is very difficult, and it is mission critical.\n\nAnd people capable of doing it are expensive and scarce.\n\nWe genuinely cannot spin up enough of those to keep pace with demand.\n\nAs Marc Andreesen (inventor of the browser, partner of VC firm) says, “software is eating the world”.\n\nAnd it isn’t noddy little bits of scripts that he is talking about.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984267, 'subscription': 0, 'content': 'They can’t though. And that’s the problem our industry faces.\n\nYou forget that what a normal person might be proud of - writing “Hello World” in JavaScript, and getting a personal Bio web page up - are nothing, absolutely nothing like real software.\n\nThe scale of effort in writing Windows, Linux, iOS, Google Chrome, Google Search, AWS, Facebook, Hotmail, Outlook … Even writing a dumb phone app. Most people can’t do it.\n\nThe barriers to equipment are lower, I agree.\n\nThe barrier to thinking is higher.\n\nSoftware is nothing more than captured, executable thought.\n\nIt is getting exponentially harder, in my view.\n\nAnd even with the whole of the internet available on your smartphone, I observe people ask really basic questions, like “How do I start coding?” on Quora. I love answering, and helping. But … it shows me that a person who will not type a google search query is considering entering our field.\n\nIt’s like tying your shoelaces together and asking “When can I race Usain Bolt?”\n\nForget about coding. Think about how you design a system like Facebook or Netflix or the public telephone network or a mobile base station. How do you support millions, billions of users? How do you guarantee service? Where do you store their data> How do you secure it? What happens if storage fails? How do you bill them? How do you not charge them twice?\n\nNone of that is answered by coding. It is very difficult, and it is mission critical.\n\nAnd people capable of doing it are expensive and scarce.\n\nWe genuinely cannot spin up enough of those to keep pace with demand.\n\nAs Marc Andreesen (inventor of the browser, partner of VC firm) says, “software is eating the world”.\n\nAnd it isn’t noddy little bits of scripts that he is talking about.', 'aiModelVersion': '1'}",0.9998
Nick Pappas,Updated 5y,When does programming stop being fun?,"When you find your self in a situation like this:

or this:

Or when THIS happens.

Or of course, when eventually this inevitable crap happens:

closely related to this one below.

Or when you have a boss who first tells you something like this:

and then goes ahead and assigns to you a task like this:

and FINALLY….:
When they tell you that you have to maintain uncommented code that looks like this:","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/udhpc240srwjo7ve', 'title': 'When does programming stop being fun?', 'score': {'original': 0.9966, 'ai': 0.0034}, 'blocks': [{'text': 'When you find your self in a situation like this:\n\nor this:\n\nOr when THIS happens.\n\nOr of course, when eventually this inevitable crap happens:\n\nclosely related to this one below.\n\nOr when you have a boss who first tells you something like this:\n\nand then goes ahead and assigns to you a task like this:\n\nand FINALLY….:\nWhen they tell you that you have to maintain uncommented code that looks like this:', 'result': {'fake': 0.0034, 'real': 0.9966}, 'status': 'success'}], 'credits_used': 1, 'credits': 1984266, 'subscription': 0, 'content': 'When you find your self in a situation like this:\n\nor this:\n\nOr when THIS happens.\n\nOr of course, when eventually this inevitable crap happens:\n\nclosely related to this one below.\n\nOr when you have a boss who first tells you something like this:\n\nand then goes ahead and assigns to you a task like this:\n\nand FINALLY….:\nWhen they tell you that you have to maintain uncommented code that looks like this:', 'aiModelVersion': '1'}",0.9966
K Rohit Rao,Updated 7y,Why did you choose to be an engineer?,"L.H.S.:
1. I used to hate biology.
2. Everyone (including me) used to think that arts and commerce is inferior to science.
3. Fortunately or unfortunately I used to get good marks in Maths and Science.

R.H.S.: Engineering

Therefore, L.H.S=R.H.S (Hence, proved)

P.S.: I used to think that arts and commerce is inferior to science. That was something 8-9 years ago. So, please refrain yourself from putting me in the firing line. I have equal respect for every stream.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ryswujx17devozpa', 'title': 'Why did you choose to be an engineer?', 'score': {'original': 0.9992, 'ai': 0.0008}, 'blocks': [{'text': 'L.H.S.:\n1. I used to hate biology.\n2. Everyone (including me) used to think that arts and commerce is inferior to science.\n3. Fortunately or unfortunately I used to get good marks in Maths and Science.\n\nR.H.S.: Engineering\n\nTherefore, L.H.S=R.H.S (Hence, proved)\n\nP.S.: I used to think that arts and commerce is inferior to science. That was something 8-9 years ago. So, please refrain yourself from putting me in the firing line. I have equal respect for every stream.', 'result': {'fake': 0.0008, 'real': 0.9992}, 'status': 'success'}], 'credits_used': 1, 'credits': 1984265, 'subscription': 0, 'content': 'L.H.S.:\n1. I used to hate biology.\n2. Everyone (including me) used to think that arts and commerce is inferior to science.\n3. Fortunately or unfortunately I used to get good marks in Maths and Science.\n\nR.H.S.: Engineering\n\nTherefore, L.H.S=R.H.S (Hence, proved)\n\nP.S.: I used to think that arts and commerce is inferior to science. That was something 8-9 years ago. So, please refrain yourself from putting me in the firing line. I have equal respect for every stream.', 'aiModelVersion': '1'}",0.9992
Brock Pan-Yellow,Updated 1y,What is the best thing that you can tell about programming?,"Between me typing this answer, sending it to Quora, and you reading it, do you know how much programming went in to making that all happen? Exactly one Bajillion Engineers contributed in some meaningful way.

An army of engineers built the browser I’m using to type. If you use a different one to read, that’s another army.

There are half a dozen layers between the UI displaying my text and the physical/network layers at the bottom. Each of those layers was built by armies of programmers, battling each other daily.

And what about that fancy device you’re reading this on? Do you know how much programming happens at Intel to make those chips? Or how much programming goes into making the physical tools to make the chips? Or the tools to make those tools? …

We’ve come a long way from this.

That’s a map of every computer on the “net” in 1973.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/lbx7nm0q3zk5w9pa', 'title': 'What is the best thing that you can tell about programming?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'Between me typing this answer, sending it to Quora, and you reading it, do you know how much programming went in to making that all happen? Exactly one Bajillion Engineers contributed in some meaningful way.\n\nAn army of engineers built the browser I’m using to type. If you use a different one to read, that’s another army.\n\nThere are half a dozen layers between the UI displaying my text and the physical/network layers at the bottom. Each of those layers was built by armies of programmers, battling each other daily.\n\nAnd what about that fancy device you’re reading this on? Do you know how much programming happens at Intel to make those chips? Or how much programming goes into making the physical tools to make the chips? Or the tools to make those tools? …\n\nWe’ve come a long way from this.\n\nThat’s a map of every computer on the “net” in 1973.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984263, 'subscription': 0, 'content': 'Between me typing this answer, sending it to Quora, and you reading it, do you know how much programming went in to making that all happen? Exactly one Bajillion Engineers contributed in some meaningful way.\n\nAn army of engineers built the browser I’m using to type. If you use a different one to read, that’s another army.\n\nThere are half a dozen layers between the UI displaying my text and the physical/network layers at the bottom. Each of those layers was built by armies of programmers, battling each other daily.\n\nAnd what about that fancy device you’re reading this on? Do you know how much programming happens at Intel to make those chips? Or how much programming goes into making the physical tools to make the chips? Or the tools to make those tools? …\n\nWe’ve come a long way from this.\n\nThat’s a map of every computer on the “net” in 1973.', 'aiModelVersion': '1'}",0.9995
John Davies,4y,Why are programmers so tight-lipped about assisting their fellow programmers with code?,"In my career, I’ve seen this a few times, but very rarely. I’ve been working for a long long time.

A young programmer that believed that by sharing his knowledge he was making himself less valuable to the company. As he got experience he learned that sharing knowledge actually made him more valuable to the company as the guy everyone went to for help.
2. Some companies keep everyone so overworked that there is no time left to give help. I’ve seen this in startups. When you’re working 60–80 hour weeks it’s hard to find the energy to be helpful.
3. One guy I used to help would “thank me” by saying “Yeah, that’s what I thought. Thanks for verifying.” I quit helping him. If he knew so much he didn’t need my help.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wd02vm6nxgy8h57e', 'title': 'Why are programmers so tight-lipped about assisting their fellow programmers with code?', 'score': {'original': 0.9924, 'ai': 0.0076}, 'blocks': [{'text': 'In my career, I’ve seen this a few times, but very rarely. I’ve been working for a long long time.\n\nA young programmer that believed that by sharing his knowledge he was making himself less valuable to the company. As he got experience he learned that sharing knowledge actually made him more valuable to the company as the guy everyone went to for help.\n2. Some companies keep everyone so overworked that there is no time left to give help. I’ve seen this in startups. When you’re working 60–80 hour weeks it’s hard to find the energy to be helpful.\n3. One guy I used to help would “thank me” by saying “Yeah, that’s what I thought. Thanks for verifying.” I quit helping him. If he knew so much he didn’t need my help.', 'result': {'fake': 0.0076, 'real': 0.9924}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984261, 'subscription': 0, 'content': 'In my career, I’ve seen this a few times, but very rarely. I’ve been working for a long long time.\n\nA young programmer that believed that by sharing his knowledge he was making himself less valuable to the company. As he got experience he learned that sharing knowledge actually made him more valuable to the company as the guy everyone went to for help.\n2. Some companies keep everyone so overworked that there is no time left to give help. I’ve seen this in startups. When you’re working 60–80 hour weeks it’s hard to find the energy to be helpful.\n3. One guy I used to help would “thank me” by saying “Yeah, that’s what I thought. Thanks for verifying.” I quit helping him. If he knew so much he didn’t need my help.', 'aiModelVersion': '1'}",0.9924
Kurt Guntheroth,Updated 4y,"As a software engineer, do you have a hard time meeting all your deadlines on time?","Of course.

I estimated that a recent project would take a minimum of 12 weeks. My boss’s boss figured it would only take eight. He didn’t have any actual idea what was involved, but he figured eight weeks was enough. The project involved researching a somewhat obscure error-correcting video streaming spec from SMPTE, and implementing all-new code to receive packets and do the forward error correction. It had to run on PCs, and handle high-bandwidth video feeds.

They promised me use of an expensive hardware device that produced the streams I was supposed to decode. But when I needed the device, it was unavailable (because they were using it for revenue) so I had to build additional code to simulate its output. Then the help I was told was going to be assigned was never assigned. Then after eight weeks, my boss’s boss asked, “Why aren’t you done yet?”

I finished the job, in 16 weeks (and it was a bloody miracle that was all the time it took). By myself, without the hardware support, and with the data stream simulation with rather beautiful optional error insertion for testing purposes. Then they fired me.

So yeah, I guess sometimes I have a hard time meeting all my deadlines on time.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wjl9uf0zb3xsa1y6', 'title': 'As a software engineer, do you have a hard time meeting all your deadlines on time?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Of course.\n\nI estimated that a recent project would take a minimum of 12 weeks. My boss’s boss figured it would only take eight. He didn’t have any actual idea what was involved, but he figured eight weeks was enough. The project involved researching a somewhat obscure error-correcting video streaming spec from SMPTE, and implementing all-new code to receive packets and do the forward error correction. It had to run on PCs, and handle high-bandwidth video feeds.\n\nThey promised me use of an expensive hardware device that produced the streams I was supposed to decode. But when I needed the device, it was unavailable (because they were using it for revenue) so I had to build additional code to simulate its output. Then the help I was told was going to be assigned was never assigned. Then after eight weeks, my boss’s boss asked, “Why aren’t you done yet?”\n\nI finished the job, in 16 weeks (and it was a bloody miracle that was all the time it took). By myself, without the hardware support, and with the data stream simulation with rather beautiful optional error insertion for testing purposes. Then they fired me.\n\nSo yeah, I guess sometimes I have a hard time meeting all my deadlines on time.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984258, 'subscription': 0, 'content': 'Of course.\n\nI estimated that a recent project would take a minimum of 12 weeks. My boss’s boss figured it would only take eight. He didn’t have any actual idea what was involved, but he figured eight weeks was enough. The project involved researching a somewhat obscure error-correcting video streaming spec from SMPTE, and implementing all-new code to receive packets and do the forward error correction. It had to run on PCs, and handle high-bandwidth video feeds.\n\nThey promised me use of an expensive hardware device that produced the streams I was supposed to decode. But when I needed the device, it was unavailable (because they were using it for revenue) so I had to build additional code to simulate its output. Then the help I was told was going to be assigned was never assigned. Then after eight weeks, my boss’s boss asked, “Why aren’t you done yet?”\n\nI finished the job, in 16 weeks (and it was a bloody miracle that was all the time it took). By myself, without the hardware support, and with the data stream simulation with rather beautiful optional error insertion for testing purposes. Then they fired me.\n\nSo yeah, I guess sometimes I have a hard time meeting all my deadlines on time.', 'aiModelVersion': '1'}",0.9998
Saket Kumar,Updated 9mo,Why are Indian software engineers so horrible?,"I will give you a real account of my personal experience of the matter.

In mid 2015, I joined a freelancing website “Upwork.com”. As a beginner I didn’t know how freelancing works, so to try the site out, I applied for all the jobs which suited my preference.

I kept my rate as $18/hour, for a long time I didn't receive a single interview call, after months of disappointment, I changed my rate to mere 6$/hour.

And guess what, idea worked. The very next day I received three interview calls.

Out of three calls, I chose to work with a German guy “Ferdinand”. In next 2 months I wrote two applications, one for Android and one for iOS.

My overall billing was just approximate $550.

All fine and dandy, I got my money, he got his code and applications.

Ferdinand was very happy. He never had such smooth transactions of events with an Indian freelancer. He told, normally for this much work, it used to take 6 month, and around 2000$ with the same 6$/hour, which he thought is justified rate to the Indian freelancers.

I told him clearly, It is my first job, because of which I intentionally kept the rate lowest, but I delivered the work on my best capacity.

He understood.

After this assignment I changed my rate to $15/hour. And got a big project on this rate.

Couple of months later, Ferdinand approached for a new APP, we had a conversation that went something like this.

Ferdinand - Saket, we have new work for you, this is a long term assignment.

Me: Cool.

Ferdinand - As we know you from previous work, we agreed to increase your rate to $8/hour.

Me: Thank you Ferdinand, sorry I am not interested in your generous offer, because I am full right now.

Ferdinand: We can make it $10, if you want.

Me: Thanks, as I said I am full. I am sure you would get your older folks to work this out.

Ferdinand: What are your expectations?

Me: $15/hour is the minimum I would charge if you send money through Xoom/Paypal. If you avail Upwork payment option my rate is $20/hour.

Ferdinand: Oh…are you serious? I have been hiring Indian/Bangladeshi people for much less than I offered you.

Me: I have no doubts about it, you must have hired folks on that rate, but that’s not me.

Finally, he went ahead to $12, I said sorry, and things never materialised, meanwhile after completing 2nd project, I had enough of Upwork, I left the site.

Few months back, I got a ping on Skype from Ferdinand.

“Hello Ferdinand, been two years man, tell me, what forced you to remember me?”

“Saket, we have an app with few bugs, would you like to solve them for us, I will provide the rate you seek”

“I am sorry Ferdinand, I am not a freelancer any more, I am not going to quote you a rate, rather I would estimate the work and quote you a figure, you like my figure then we are on”

“Wonderful, I would send you the bug list and codebase I received from the current developer”

When I run the solution, and tried reproducing the bugs, I could not find the buggy screens itself.

Upon close inspection, I found out, this codebase is really an old one, the hosted app is certainly not a build of it.

This was the time Ferdinand really realised, what it is like to work with a $6/hour developer, all these years he thought he has an updated codebase, if tomorrow a new version is needed, it would be short and quick.

I asked him to get the updated codebase, as expected guy didn't reply to his ping.

And, I ended up writing that whole app afresh from scratch, he ended up paying me $1500+ for the things he should have paid max $20-$30.

To answer your question:

Why are Indian software engineers so horrible? — They aren’t, you intentionally choose the horrible ones, you choose to work with a vendor/developer who makes the lowest bid for your work.

When you pay pennies, you get garbage in return that’s inevitable.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/6kdxumsy40erfo9a', 'title': 'Why are Indian software engineers so horrible?', 'score': {'original': 0.99425, 'ai': 0.00575}, 'blocks': [{'text': ""I will give you a real account of my personal experience of the matter.\n\nIn mid 2015, I joined a freelancing website “Upwork.com”. As a beginner I didn’t know how freelancing works, so to try the site out, I applied for all the jobs which suited my preference.\n\nI kept my rate as $18/hour, for a long time I didn't receive a single interview call, after months of disappointment, I changed my rate to mere 6$/hour.\n\nAnd guess what, idea worked. The very next day I received three interview calls.\n\nOut of three calls, I chose to work with a German guy “Ferdinand”. In next 2 months I wrote two applications, one for Android and one for iOS.\n\nMy overall billing was just approximate $550.\n\nAll fine and dandy, I got my money, he got his code and applications.\n\nFerdinand was very happy. He never had such smooth transactions of events with an Indian freelancer. He told, normally for this much work, it used to take 6 month, and around 2000$ with the same 6$/hour, which he thought is justified rate to the Indian freelancers.\n\nI told him clearly, It is my first job, because of which I intentionally kept the rate lowest, but I delivered the work on my best capacity.\n\nHe understood.\n\nAfter this assignment I changed my rate to $15/hour. And got a big project on this rate.\n\nCouple of months later, Ferdinand approached for a new APP, we had a conversation that went something like this.\n\nFerdinand - Saket, we have new work for you, this is a long term assignment.\n\nMe: Cool.\n\nFerdinand - As we know you from previous work, we agreed to increase your rate to $8/hour.\n\nMe: Thank you Ferdinand, sorry I am not interested in your generous offer, because I am full right now.\n\nFerdinand: We can make it $10, if you want.\n\nMe: Thanks, as I said I am full. I am sure you would get your older folks to work this out.\n\nFerdinand: What are your expectations?\n\nMe: $15/hour is the minimum I would charge if you send money through Xoom/Paypal. If you avail Upwork payment option my rate is $20/hour.\n\nFerdinand: Oh…are you serious? I have been hiring Indian/Bangladeshi people for much less than I offered you.\n\nMe: I have no doubts about it, you must have hired folks on that rate, but that’s not me.\n\nFinally, he went ahead to $12, I said sorry, and things never materialised, meanwhile after completing 2nd project, I had enough of Upwork, I left the site.\n\nFew months back, I got a ping on Skype from Ferdinand.\n\n“Hello Ferdinand, been two years man, tell me, what forced you to remember me?”\n\n“Saket, we have an app with few bugs, would you like to solve them for us, I will provide the rate you seek”\n\n“I am sorry Ferdinand, I am not a freelancer any more, I am not going to quote you a rate, rather I would estimate the work and quote you a figure, you like my figure then we are on”\n\n“Wonderful, I would send you the bug list and codebase I received from the current developer”\n\nWhen I run the solution, and tried reproducing the bugs, I could"", 'result': {'fake': 0.3778, 'real': 0.6222}, 'status': 'success'}, {'text': ""not find the buggy screens itself.\n\nUpon close inspection, I found out, this codebase is really an old one, the hosted app is certainly not a build of it.\n\nThis was the time Ferdinand really realised, what it is like to work with a $6/hour developer, all these years he thought he has an updated codebase, if tomorrow a new version is needed, it would be short and quick.\n\nI asked him to get the updated codebase, as expected guy didn't reply to his ping.\n\nAnd, I ended up writing that whole app afresh from scratch, he ended up paying me $1500+ for the things he should have paid max $20-$30.\n\nTo answer your question:\n\nWhy are Indian software engineers so horrible? — They aren’t, you intentionally choose the horrible ones, you choose to work with a vendor/developer who makes the lowest bid for your work.\n\nWhen you pay pennies, you get garbage in return that’s inevitable."", 'result': {'fake': 0.7105, 'real': 0.2895}, 'status': 'success'}], 'credits_used': 7, 'credits': 1984251, 'subscription': 0, 'content': ""I will give you a real account of my personal experience of the matter.\n\nIn mid 2015, I joined a freelancing website “Upwork.com”. As a beginner I didn’t know how freelancing works, so to try the site out, I applied for all the jobs which suited my preference.\n\nI kept my rate as $18/hour, for a long time I didn't receive a single interview call, after months of disappointment, I changed my rate to mere 6$/hour.\n\nAnd guess what, idea worked. The very next day I received three interview calls.\n\nOut of three calls, I chose to work with a German guy “Ferdinand”. In next 2 months I wrote two applications, one for Android and one for iOS.\n\nMy overall billing was just approximate $550.\n\nAll fine and dandy, I got my money, he got his code and applications.\n\nFerdinand was very happy. He never had such smooth transactions of events with an Indian freelancer. He told, normally for this much work, it used to take 6 month, and around 2000$ with the same 6$/hour, which he thought is justified rate to the Indian freelancers.\n\nI told him clearly, It is my first job, because of which I intentionally kept the rate lowest, but I delivered the work on my best capacity.\n\nHe understood.\n\nAfter this assignment I changed my rate to $15/hour. And got a big project on this rate.\n\nCouple of months later, Ferdinand approached for a new APP, we had a conversation that went something like this.\n\nFerdinand - Saket, we have new work for you, this is a long term assignment.\n\nMe: Cool.\n\nFerdinand - As we know you from previous work, we agreed to increase your rate to $8/hour.\n\nMe: Thank you Ferdinand, sorry I am not interested in your generous offer, because I am full right now.\n\nFerdinand: We can make it $10, if you want.\n\nMe: Thanks, as I said I am full. I am sure you would get your older folks to work this out.\n\nFerdinand: What are your expectations?\n\nMe: $15/hour is the minimum I would charge if you send money through Xoom/Paypal. If you avail Upwork payment option my rate is $20/hour.\n\nFerdinand: Oh…are you serious? I have been hiring Indian/Bangladeshi people for much less than I offered you.\n\nMe: I have no doubts about it, you must have hired folks on that rate, but that’s not me.\n\nFinally, he went ahead to $12, I said sorry, and things never materialised, meanwhile after completing 2nd project, I had enough of Upwork, I left the site.\n\nFew months back, I got a ping on Skype from Ferdinand.\n\n“Hello Ferdinand, been two years man, tell me, what forced you to remember me?”\n\n“Saket, we have an app with few bugs, would you like to solve them for us, I will provide the rate you seek”\n\n“I am sorry Ferdinand, I am not a freelancer any more, I am not going to quote you a rate, rather I would estimate the work and quote you a figure, you like my figure then we are on”\n\n“Wonderful, I would send you the bug list and codebase I received from the current developer”\n\nWhen I run the solution, and tried reproducing the bugs, I could not find the buggy screens itself.\n\nUpon close inspection, I found out, this codebase is really an old one, the hosted app is certainly not a build of it.\n\nThis was the time Ferdinand really realised, what it is like to work with a $6/hour developer, all these years he thought he has an updated codebase, if tomorrow a new version is needed, it would be short and quick.\n\nI asked him to get the updated codebase, as expected guy didn't reply to his ping.\n\nAnd, I ended up writing that whole app afresh from scratch, he ended up paying me $1500+ for the things he should have paid max $20-$30.\n\nTo answer your question:\n\nWhy are Indian software engineers so horrible? — They aren’t, you intentionally choose the horrible ones, you choose to work with a vendor/developer who makes the lowest bid for your work.\n\nWhen you pay pennies, you get garbage in return that’s inevitable."", 'aiModelVersion': '1'}",0.99425
Rana Ashish,5y,Are you happy with the salary you receive as a software engineer?,"Yes, I am satisfied with my salary but not happy. I will give you the justification.

Why am I satisfied?

I belong to a family where fulfilling basic necessity was more important than going for luxury. You can understand the level of poverty from the fact that I had an income certificate as proof, that we belonged to below poverty line.

Those were the days when eating “Parle G” biscuit counted as a part of luxury. And the day we got Toffees (Not chocolates) on someone’s birthday, became the best days of my life.

I have seen those days in my life, when I used to skip lunch to save some money.

After all these struggles,

I cleared my education loan.
My sister successfully got married in a good family. I bore 80% of total expenditure.
First time I bought things like Washing Machine, Fridge, Color TV, Sofa etc.
I renovated my 40 years old house into a modern one.

Everything was done from the money I earned as a Software Engineer. Our standard of living changed dramatically in the last 6 years.

So of course, I am satisfied with the salary I receive.

Why am I not happy?

Software Engineer means a private job, (Mostly) and I am underpaid as per my domain expertise. I didn’t get salary hike or promotion for the last 2 years because I grabbed my manager’s collar. It is a different story why I did that.

But in short, he invaded my self respect which I couldn’t tolerate. And I am also a stubborn asshole, neither did I leave the company nor did I beg for his mercy.

And ofcourse if you earn less than your juniors, then certainly it will make anyone unhappy. :P

If it’s meant for you, you won’t have to beg for it.

You will never have to sacrifice your dignity for your destiny.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/vu3n9s0tocrz2dal', 'title': 'Are you happy with the salary you receive as a software engineer?', 'score': {'original': 0.9999, 'ai': 0.0001}, 'blocks': [{'text': 'Yes, I am satisfied with my salary but not happy. I will give you the justification.\n\nWhy am I satisfied?\n\nI belong to a family where fulfilling basic necessity was more important than going for luxury. You can understand the level of poverty from the fact that I had an income certificate as proof, that we belonged to below poverty line.\n\nThose were the days when eating “Parle G” biscuit counted as a part of luxury. And the day we got Toffees (Not chocolates) on someone’s birthday, became the best days of my life.\n\nI have seen those days in my life, when I used to skip lunch to save some money.\n\nAfter all these struggles,\n\nI cleared my education loan.\nMy sister successfully got married in a good family. I bore 80% of total expenditure.\nFirst time I bought things like Washing Machine, Fridge, Color TV, Sofa etc.\nI renovated my 40 years old house into a modern one.\n\nEverything was done from the money I earned as a Software Engineer. Our standard of living changed dramatically in the last 6 years.\n\nSo of course, I am satisfied with the salary I receive.\n\nWhy am I not happy?\n\nSoftware Engineer means a private job, (Mostly) and I am underpaid as per my domain expertise. I didn’t get salary hike or promotion for the last 2 years because I grabbed my manager’s collar. It is a different story why I did that.\n\nBut in short, he invaded my self respect which I couldn’t tolerate. And I am also a stubborn asshole, neither did I leave the company nor did I beg for his mercy.\n\nAnd ofcourse if you earn less than your juniors, then certainly it will make anyone unhappy. :P\n\nIf it’s meant for you, you won’t have to beg for it.\n\nYou will never have to sacrifice your dignity for your destiny.', 'result': {'fake': 0.0001, 'real': 0.9999}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984247, 'subscription': 0, 'content': 'Yes, I am satisfied with my salary but not happy. I will give you the justification.\n\nWhy am I satisfied?\n\nI belong to a family where fulfilling basic necessity was more important than going for luxury. You can understand the level of poverty from the fact that I had an income certificate as proof, that we belonged to below poverty line.\n\nThose were the days when eating “Parle G” biscuit counted as a part of luxury. And the day we got Toffees (Not chocolates) on someone’s birthday, became the best days of my life.\n\nI have seen those days in my life, when I used to skip lunch to save some money.\n\nAfter all these struggles,\n\nI cleared my education loan.\nMy sister successfully got married in a good family. I bore 80% of total expenditure.\nFirst time I bought things like Washing Machine, Fridge, Color TV, Sofa etc.\nI renovated my 40 years old house into a modern one.\n\nEverything was done from the money I earned as a Software Engineer. Our standard of living changed dramatically in the last 6 years.\n\nSo of course, I am satisfied with the salary I receive.\n\nWhy am I not happy?\n\nSoftware Engineer means a private job, (Mostly) and I am underpaid as per my domain expertise. I didn’t get salary hike or promotion for the last 2 years because I grabbed my manager’s collar. It is a different story why I did that.\n\nBut in short, he invaded my self respect which I couldn’t tolerate. And I am also a stubborn asshole, neither did I leave the company nor did I beg for his mercy.\n\nAnd ofcourse if you earn less than your juniors, then certainly it will make anyone unhappy. :P\n\nIf it’s meant for you, you won’t have to beg for it.\n\nYou will never have to sacrifice your dignity for your destiny.', 'aiModelVersion': '1'}",0.9999
Jack Brennen,2y,"Do large software companies like Google do their absolute best in optimising their code, including doing small things such as removing branches and loop unrolling?","Modern optimization (as done by programmers, not compilers) is less about removing branches and loop unrolling, and more about improving cache locality and reducing the number of slow memory accesses.

In other words, it’s more about optimizing the data than it is about optimizing the code.

At my last job at Qualcomm, which would probably be considered a large software company, the system I worked on was an integral part of many modern mobile phones (the Snapdragon SoC). The speed difference between an access satisfied in Level 1 cache vs. an access that goes to main memory could be as much as a 200x difference.

We paid lots of attention to keeping our working set small and making sure that we made effective use of the cache. When really getting down to the serious optimizations in things like the thread scheduler, we didn’t care about instruction count that much, but we cared a lot about cache footprint.

Note that compiler technology is really good at picking instruction sequences that work well, and doing things like recognizing common sub-expressions, or when data accesses can be done “out of order” to make the code faster.

One thing that I’ve never seen a compiler do yet is reorganize a data structure for cache locality; in fact, by the C specification, a compiler is not permitted to rearrange the elements of a struct. Those optimizations were left to the programmer; things like putting the most commonly accessed fields of a struct into the first 32 bytes, and requesting cache-line alignment for such data structures.

So a modern developer can get more bang for the buck by learning to optimize their data, compared to writing more optimized code.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/25wuzlytk1q30vgd', 'title': 'Do large software companies like Google do their absolute best in optimising their code, including doing small things such as removing branches and loop unrolling?', 'score': {'original': 0.9987, 'ai': 0.0013}, 'blocks': [{'text': 'Modern optimization (as done by programmers, not compilers) is less about removing branches and loop unrolling, and more about improving cache locality and reducing the number of slow memory accesses.\n\nIn other words, it’s more about optimizing the data than it is about optimizing the code.\n\nAt my last job at Qualcomm, which would probably be considered a large software company, the system I worked on was an integral part of many modern mobile phones (the Snapdragon SoC). The speed difference between an access satisfied in Level 1 cache vs. an access that goes to main memory could be as much as a 200x difference.\n\nWe paid lots of attention to keeping our working set small and making sure that we made effective use of the cache. When really getting down to the serious optimizations in things like the thread scheduler, we didn’t care about instruction count that much, but we cared a lot about cache footprint.\n\nNote that compiler technology is really good at picking instruction sequences that work well, and doing things like recognizing common sub-expressions, or when data accesses can be done “out of order” to make the code faster.\n\nOne thing that I’ve never seen a compiler do yet is reorganize a data structure for cache locality; in fact, by the C specification, a compiler is not permitted to rearrange the elements of a struct. Those optimizations were left to the programmer; things like putting the most commonly accessed fields of a struct into the first 32 bytes, and requesting cache-line alignment for such data structures.\n\nSo a modern developer can get more bang for the buck by learning to optimize their data, compared to writing more optimized code.', 'result': {'fake': 0.0013, 'real': 0.9987}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984244, 'subscription': 0, 'content': 'Modern optimization (as done by programmers, not compilers) is less about removing branches and loop unrolling, and more about improving cache locality and reducing the number of slow memory accesses.\n\nIn other words, it’s more about optimizing the data than it is about optimizing the code.\n\nAt my last job at Qualcomm, which would probably be considered a large software company, the system I worked on was an integral part of many modern mobile phones (the Snapdragon SoC). The speed difference between an access satisfied in Level 1 cache vs. an access that goes to main memory could be as much as a 200x difference.\n\nWe paid lots of attention to keeping our working set small and making sure that we made effective use of the cache. When really getting down to the serious optimizations in things like the thread scheduler, we didn’t care about instruction count that much, but we cared a lot about cache footprint.\n\nNote that compiler technology is really good at picking instruction sequences that work well, and doing things like recognizing common sub-expressions, or when data accesses can be done “out of order” to make the code faster.\n\nOne thing that I’ve never seen a compiler do yet is reorganize a data structure for cache locality; in fact, by the C specification, a compiler is not permitted to rearrange the elements of a struct. Those optimizations were left to the programmer; things like putting the most commonly accessed fields of a struct into the first 32 bytes, and requesting cache-line alignment for such data structures.\n\nSo a modern developer can get more bang for the buck by learning to optimize their data, compared to writing more optimized code.', 'aiModelVersion': '1'}",0.9987
Kurt Guntheroth,4y,What is the most difficult C++ programming project you have ever worked on and can you share your code?,"The most difficult C++ project I ever worked on was embedded software to control a device programmer at Data I/O. Can’t share code because it’s proprietary. There are a bunch of things that made this project hard.

It was my first C++ project, and my first project as lead. I was still trying to figure out C++, back in the early 1990s, before the internet. No Stack Overflow
 to ask questions of, no online cppreference.com
 with complete references for every class. Just me and the Annotated Reference Manual. Fortunately, I had a couple of very gentle, kind colleagues to help me with the C++ questions.
The compiler we were using was a POS, and our team was apparently doing the most sophisticated coding of anyone using this compiler. Every week we found another thing that should have worked, but did not. As team lead, I had to look up chapter and verse in the ARM to prove the compiler was not correct, write up a simple test case so they could repro the bug, and interact with their somewhat grumpy customer service. The effort was worth it though, because our bugs always got high priority since we could prove they were bugs.
The device programmer consisted mostly of this custom VLSI circuit that sequenced changes to voltages on the pins of the device to be programmed. You could be as object oriented as you liked, but there was this one big-ass object in the middle with 200 member functions that you could not refactor because it controlled a single big-ass piece of hardware.
That big-ass VLSI sequencer? There was no comprehensive documentation for it. We had to reverse-engineer our other programmers to figure it out, using old and fragmentary documents, and reading the code. We used this sequencer to be compatible with the programming algorithms from previous programmers, so you would think that its operation would be well understood. Well, you would be incorrect.
Processors were slow back in the day, and performance mattered. Even virtual function calls were a big deal, so they had to be used carefully. Try to imagine a day when a single virtual function call took several microseconds. The horror. The horror.
Oh, and one of the things that didn’t work in this compiler was templates any more complicated than auto_ptr, so no performance help there. No STL either, thank you very much.
We had a split architecture, with a PC controlling a batch of embedded systems in real time. We built the whole architecture so that the decision where to split functionality between the PC and the embedded devices could be changed as needed. It was a great architecture if I do say so myself.
Our marketing department was insane, insisting that our programmer cover every device ever conceived from the latest FPGAs to 35-year-old bipolar PALs. Never mind the fact that anyone wanting to program 35-year-old bipolar PALs already had a programmer. Lots of extra work there, to no benefit.
The company needed this project to take about one calendar year, but we had scheduled out the project at 35 man-years, so there was no way that was going to happen with our ten man team. The software was a year less late than the hardware, so we felt pretty good.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/vt9dla02by5fjqnz', 'title': 'What is the most difficult C++ programming project you have ever worked on and can you share your code?', 'score': {'original': 0.44465, 'ai': 0.55535}, 'blocks': [{'text': 'The most difficult C++ project I ever worked on was embedded software to control a device programmer at Data I/O. Can’t share code because it’s proprietary. There are a bunch of things that made this project hard.\n\nIt was my first C++ project, and my first project as lead. I was still trying to figure out C++, back in the early 1990s, before the internet. No Stack Overflow\n to ask questions of, no online cppreference.com\n with complete references for every class. Just me and the Annotated Reference Manual. Fortunately, I had a couple of very gentle, kind colleagues to help me with the C++ questions.\nThe compiler we were using was a POS, and our team was apparently doing the most sophisticated coding of anyone using this compiler. Every week we found another thing that should have worked, but did not. As team lead, I had to look up chapter and verse in the ARM to prove the compiler was not correct, write up a simple test case so they could repro the bug, and interact with their somewhat grumpy customer service. The effort was worth it though, because our bugs always got high priority since we could prove they were bugs.\nThe device programmer consisted mostly of this custom VLSI circuit that sequenced changes to voltages on the pins of the device to be programmed. You could be as object oriented as you liked, but there was this one big-ass object in the middle with 200 member functions that you could not refactor because it controlled a single big-ass piece of hardware.\nThat big-ass VLSI sequencer? There was no comprehensive documentation for it. We had to reverse-engineer our other programmers to figure it out, using old and fragmentary documents, and reading the code. We used this sequencer to be compatible with the programming algorithms from previous programmers, so you would think that its operation would be well understood. Well, you would be incorrect.\nProcessors were slow back in the day, and performance mattered. Even virtual function calls were a big deal, so they had to be used carefully. Try to imagine a day when a single virtual function call took several microseconds. The horror. The horror.\nOh, and one of the things that didn’t work in this compiler was templates any more complicated than auto_ptr, so no performance help there. No STL either, thank you very much.\nWe had a split architecture, with a PC controlling a batch of embedded systems in real time. We built the whole architecture so that the decision where to split functionality between the PC and the embedded devices could be changed as needed. It was a great architecture if I do say so myself.\nOur marketing department was insane, insisting that our programmer cover every device ever conceived from the latest FPGAs to 35-year-old bipolar PALs. Never mind the fact that anyone wanting to program 35-year-old bipolar PALs already had a programmer. Lots of extra work there, to no benefit.\nThe company needed this project to take about one calendar year, but we had scheduled out the project at 35 man-years, so there was', 'result': {'fake': 0.1033, 'real': 0.8967}, 'status': 'success'}, {'text': 'no way that was going to happen with our ten man team. The software was a year less late than the hardware, so we felt pretty good.', 'result': {'fake': 0.9965, 'real': 0.0035}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984238, 'subscription': 0, 'content': 'The most difficult C++ project I ever worked on was embedded software to control a device programmer at Data I/O. Can’t share code because it’s proprietary. There are a bunch of things that made this project hard.\n\nIt was my first C++ project, and my first project as lead. I was still trying to figure out C++, back in the early 1990s, before the internet. No Stack Overflow\n to ask questions of, no online cppreference.com\n with complete references for every class. Just me and the Annotated Reference Manual. Fortunately, I had a couple of very gentle, kind colleagues to help me with the C++ questions.\nThe compiler we were using was a POS, and our team was apparently doing the most sophisticated coding of anyone using this compiler. Every week we found another thing that should have worked, but did not. As team lead, I had to look up chapter and verse in the ARM to prove the compiler was not correct, write up a simple test case so they could repro the bug, and interact with their somewhat grumpy customer service. The effort was worth it though, because our bugs always got high priority since we could prove they were bugs.\nThe device programmer consisted mostly of this custom VLSI circuit that sequenced changes to voltages on the pins of the device to be programmed. You could be as object oriented as you liked, but there was this one big-ass object in the middle with 200 member functions that you could not refactor because it controlled a single big-ass piece of hardware.\nThat big-ass VLSI sequencer? There was no comprehensive documentation for it. We had to reverse-engineer our other programmers to figure it out, using old and fragmentary documents, and reading the code. We used this sequencer to be compatible with the programming algorithms from previous programmers, so you would think that its operation would be well understood. Well, you would be incorrect.\nProcessors were slow back in the day, and performance mattered. Even virtual function calls were a big deal, so they had to be used carefully. Try to imagine a day when a single virtual function call took several microseconds. The horror. The horror.\nOh, and one of the things that didn’t work in this compiler was templates any more complicated than auto_ptr, so no performance help there. No STL either, thank you very much.\nWe had a split architecture, with a PC controlling a batch of embedded systems in real time. We built the whole architecture so that the decision where to split functionality between the PC and the embedded devices could be changed as needed. It was a great architecture if I do say so myself.\nOur marketing department was insane, insisting that our programmer cover every device ever conceived from the latest FPGAs to 35-year-old bipolar PALs. Never mind the fact that anyone wanting to program 35-year-old bipolar PALs already had a programmer. Lots of extra work there, to no benefit.\nThe company needed this project to take about one calendar year, but we had scheduled out the project at 35 man-years, so there was no way that was going to happen with our ten man team. The software was a year less late than the hardware, so we felt pretty good.', 'aiModelVersion': '1'}",0.44465
Aaron Christianson,1y,Why not just switch to Rust if C++ is less efficient and more verbose as some claim?,"You have a non-trivial C++ project that works fine and would be expensive to rewrite.
You are an expert in C++ and are happy with it.
You are working on a domain where C++ has libraries and Rust doesn’t (game development, for example)

If none of these are true, it may be a good idea to switch from C++ to Rust.

I’m not sure C++ is less efficient, thought it is probably more verbose in general (not sure why verbosity is a problem perse).

Rust is also no picnic to program in. Don’t get me wrong. I like it more than C++ because it’s more similar to the statically typed functional languages I love and the memory safety is great, but I would just choose a language with garbage collection over either of them for 90% of cases. Thinking about object lifetimes while programming sucks, and both Rust and C++ make you do that in different ways.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/lgotismfq7d46pvr', 'title': 'Why not just switch to Rust if C++ is less efficient and more verbose as some claim?', 'score': {'original': 0.9985, 'ai': 0.0015}, 'blocks': [{'text': 'You have a non-trivial C++ project that works fine and would be expensive to rewrite.\nYou are an expert in C++ and are happy with it.\nYou are working on a domain where C++ has libraries and Rust doesn’t (game development, for example)\n\nIf none of these are true, it may be a good idea to switch from C++ to Rust.\n\nI’m not sure C++ is less efficient, thought it is probably more verbose in general (not sure why verbosity is a problem perse).\n\nRust is also no picnic to program in. Don’t get me wrong. I like it more than C++ because it’s more similar to the statically typed functional languages I love and the memory safety is great, but I would just choose a language with garbage collection over either of them for 90% of cases. Thinking about object lifetimes while programming sucks, and both Rust and C++ make you do that in different ways.', 'result': {'fake': 0.0015, 'real': 0.9985}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984236, 'subscription': 0, 'content': 'You have a non-trivial C++ project that works fine and would be expensive to rewrite.\nYou are an expert in C++ and are happy with it.\nYou are working on a domain where C++ has libraries and Rust doesn’t (game development, for example)\n\nIf none of these are true, it may be a good idea to switch from C++ to Rust.\n\nI’m not sure C++ is less efficient, thought it is probably more verbose in general (not sure why verbosity is a problem perse).\n\nRust is also no picnic to program in. Don’t get me wrong. I like it more than C++ because it’s more similar to the statically typed functional languages I love and the memory safety is great, but I would just choose a language with garbage collection over either of them for 90% of cases. Thinking about object lifetimes while programming sucks, and both Rust and C++ make you do that in different ways.', 'aiModelVersion': '1'}",0.9985
Kurt Guntheroth,5y,Should my software developer be liable for bugs that cost me thousands of dollars?,"The more you think about this, the worse an idea it seems.

Sure, and you should be liable to your customers for bugs that cost your customers thousands of dollars. It doesn’t matter that you have no control over how your customers use your software, or whether the customers are careful to test the results or not. If you don’t like that idea, then you might suspect that your developers won’t like it either.
Sure, but you’ll have to let your developers test the code until they are satisfied it’s ready for release. No more rushing a new release out before the developers say it’s ready. No more telling the developers not to do testing. They pay for problems, so they get to say when the software is ready.
Sure, but your developers will expect you to sign off on the quality of the code before selling it. Then if you want to charge them for the cost of the bug, there will be a lawsuit where the developers put your own acceptance procedures under a microscope to see if you had reason to know better.
Sure, but you will have to increase your developers’ compensation to cover the extra risk they are taking on, just as you would raise your prices if you had to take on extra liability risk. Your developers won’t just accept the risk. They’ll either want a ton of money, or they’ll walk away. In fact, the developers will want to buy malpractice insurance to put off the liability risk, so you’ll have to pay them like neurosurgeons.
Sure, but your developers will want a piece of any profit that the code earns, because they are taking a liability risk. That’s more money for them, and less money for you. Is that what you want?
Software is covered under copyright law, more like a book of recipes than a hammer. Software does not come with an implicit warranty of merchantability or fitness for use, the way a hammer does. Any warranty must be specifically covered by contract. I betcha your customer contract is a shrinkwrap contract or opt-in button that disclaims all warranty. And you want to hold your developers to a vastly higher standard than you hold your own behavior? Shame on you.

I know, you don’t want any of this stuff. You just want your developers to pay, while you keep doing what you do. You keep all the profit, they take all the risk. Do you think anybody is going to walk into a trap like that? Would you?

Does this ever happen in the real world? You would think not, but yes it does happen. Many business leaders expect developers to work long hours to catch up if they get behind schedule. The employer is putting off schedule risk, the basic uncertainty of predicting the future, onto developers, expecting them to work uncompensated overtime to mitigate this risk. It’s crazy, and developers ought to laugh out loud when asked to do this.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wvj1gts5ox8icpel', 'title': 'Should my software developer be liable for bugs that cost me thousands of dollars?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'The more you think about this, the worse an idea it seems.\n\nSure, and you should be liable to your customers for bugs that cost your customers thousands of dollars. It doesn’t matter that you have no control over how your customers use your software, or whether the customers are careful to test the results or not. If you don’t like that idea, then you might suspect that your developers won’t like it either.\nSure, but you’ll have to let your developers test the code until they are satisfied it’s ready for release. No more rushing a new release out before the developers say it’s ready. No more telling the developers not to do testing. They pay for problems, so they get to say when the software is ready.\nSure, but your developers will expect you to sign off on the quality of the code before selling it. Then if you want to charge them for the cost of the bug, there will be a lawsuit where the developers put your own acceptance procedures under a microscope to see if you had reason to know better.\nSure, but you will have to increase your developers’ compensation to cover the extra risk they are taking on, just as you would raise your prices if you had to take on extra liability risk. Your developers won’t just accept the risk. They’ll either want a ton of money, or they’ll walk away. In fact, the developers will want to buy malpractice insurance to put off the liability risk, so you’ll have to pay them like neurosurgeons.\nSure, but your developers will want a piece of any profit that the code earns, because they are taking a liability risk. That’s more money for them, and less money for you. Is that what you want?\nSoftware is covered under copyright law, more like a book of recipes than a hammer. Software does not come with an implicit warranty of merchantability or fitness for use, the way a hammer does. Any warranty must be specifically covered by contract. I betcha your customer contract is a shrinkwrap contract or opt-in button that disclaims all warranty. And you want to hold your developers to a vastly higher standard than you hold your own behavior? Shame on you.\n\nI know, you don’t want any of this stuff. You just want your developers to pay, while you keep doing what you do. You keep all the profit, they take all the risk. Do you think anybody is going to walk into a trap like that? Would you?\n\nDoes this ever happen in the real world? You would think not, but yes it does happen. Many business leaders expect developers to work long hours to catch up if they get behind schedule. The employer is putting off schedule risk, the basic uncertainty of predicting the future, onto developers, expecting them to work uncompensated overtime to mitigate this risk. It’s crazy, and developers ought to laugh out loud when asked to do this.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984230, 'subscription': 0, 'content': 'The more you think about this, the worse an idea it seems.\n\nSure, and you should be liable to your customers for bugs that cost your customers thousands of dollars. It doesn’t matter that you have no control over how your customers use your software, or whether the customers are careful to test the results or not. If you don’t like that idea, then you might suspect that your developers won’t like it either.\nSure, but you’ll have to let your developers test the code until they are satisfied it’s ready for release. No more rushing a new release out before the developers say it’s ready. No more telling the developers not to do testing. They pay for problems, so they get to say when the software is ready.\nSure, but your developers will expect you to sign off on the quality of the code before selling it. Then if you want to charge them for the cost of the bug, there will be a lawsuit where the developers put your own acceptance procedures under a microscope to see if you had reason to know better.\nSure, but you will have to increase your developers’ compensation to cover the extra risk they are taking on, just as you would raise your prices if you had to take on extra liability risk. Your developers won’t just accept the risk. They’ll either want a ton of money, or they’ll walk away. In fact, the developers will want to buy malpractice insurance to put off the liability risk, so you’ll have to pay them like neurosurgeons.\nSure, but your developers will want a piece of any profit that the code earns, because they are taking a liability risk. That’s more money for them, and less money for you. Is that what you want?\nSoftware is covered under copyright law, more like a book of recipes than a hammer. Software does not come with an implicit warranty of merchantability or fitness for use, the way a hammer does. Any warranty must be specifically covered by contract. I betcha your customer contract is a shrinkwrap contract or opt-in button that disclaims all warranty. And you want to hold your developers to a vastly higher standard than you hold your own behavior? Shame on you.\n\nI know, you don’t want any of this stuff. You just want your developers to pay, while you keep doing what you do. You keep all the profit, they take all the risk. Do you think anybody is going to walk into a trap like that? Would you?\n\nDoes this ever happen in the real world? You would think not, but yes it does happen. Many business leaders expect developers to work long hours to catch up if they get behind schedule. The employer is putting off schedule risk, the basic uncertainty of predicting the future, onto developers, expecting them to work uncompensated overtime to mitigate this risk. It’s crazy, and developers ought to laugh out loud when asked to do this.', 'aiModelVersion': '1'}",0.9996
Jim Christmas,Updated 4y,"What’s the most outdated software you still run on a regular basis, and why is that?","Notepad.exe (circa 1983)

I use it every day.

Why? It's a fast loading program, that's easy to use. It reliably strips all formatting from a block of text. I don't have to tell it each time that I want it to ignore hyperlinks, or HTML tags, and just treat them like the raw ASCII they truly are.

Readme.txt files are still found here and there. Notepad is the perfect program to view them.

When we purchased massive demographic data files from various vendors, they always came to us in some text format, CSV, pipe or tab delimited, fixed width… to write the scripts to import these encyclopedias, I would first need to inspect the header files with a program that wouldn't alter or format the data in any way. Thank you Notepad.

Notepad is an electronic hand axe. It will continue to be useful for a very long time. There are more powerful text editors, some with very handy features for programmers, but Notepad is always there, on every machine, waiting for an opportunity to show how useful it can be.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/28j5acrsm437znb6', 'title': 'What’s the most outdated software you still run on a regular basis, and why is that?', 'score': {'original': 0.9973, 'ai': 0.0027}, 'blocks': [{'text': ""Notepad.exe (circa 1983)\n\nI use it every day.\n\nWhy? It's a fast loading program, that's easy to use. It reliably strips all formatting from a block of text. I don't have to tell it each time that I want it to ignore hyperlinks, or HTML tags, and just treat them like the raw ASCII they truly are.\n\nReadme.txt files are still found here and there. Notepad is the perfect program to view them.\n\nWhen we purchased massive demographic data files from various vendors, they always came to us in some text format, CSV, pipe or tab delimited, fixed width… to write the scripts to import these encyclopedias, I would first need to inspect the header files with a program that wouldn't alter or format the data in any way. Thank you Notepad.\n\nNotepad is an electronic hand axe. It will continue to be useful for a very long time. There are more powerful text editors, some with very handy features for programmers, but Notepad is always there, on every machine, waiting for an opportunity to show how useful it can be."", 'result': {'fake': 0.0027, 'real': 0.9973}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984228, 'subscription': 0, 'content': ""Notepad.exe (circa 1983)\n\nI use it every day.\n\nWhy? It's a fast loading program, that's easy to use. It reliably strips all formatting from a block of text. I don't have to tell it each time that I want it to ignore hyperlinks, or HTML tags, and just treat them like the raw ASCII they truly are.\n\nReadme.txt files are still found here and there. Notepad is the perfect program to view them.\n\nWhen we purchased massive demographic data files from various vendors, they always came to us in some text format, CSV, pipe or tab delimited, fixed width… to write the scripts to import these encyclopedias, I would first need to inspect the header files with a program that wouldn't alter or format the data in any way. Thank you Notepad.\n\nNotepad is an electronic hand axe. It will continue to be useful for a very long time. There are more powerful text editors, some with very handy features for programmers, but Notepad is always there, on every machine, waiting for an opportunity to show how useful it can be."", 'aiModelVersion': '1'}",0.9973
John Byrd,5y,What is the most difficult concept to grasp in object oriented programming (OOP)? How did you finally understand it?,"That computers don’t know anything about objects.

Nor do they know about classes, or methods, or members, or subclasses, or virtual functions, or pure functions, or any of that new-school jazz.

Computers don’t care.

Computers just know that there is this stuff called memory, and memory contains a bunch of numbers in it.

We humans invented object-oriented programming, in order to keep ourselves sane.

Time was, we just wrote a bunch of instructions to the computer, in the computer’s own language. Look at this memory location, do the instruction there, load another memory location, add one to it, store that value in memory there, yada yada.

Computers were fine with that.

But we weren’t fine with that. Once you added more than one programmer to a project, people couldn’t keep straight which memory locations did what, and which code did what, and who was responsible for what.

High-level languages like C helped some. But we ridiculous humans still wanted all our code to access all our data at all times, with each section of the program accessing each section of memory willy-nilly.

So we were constantly creating bugs, because we couldn’t keep all that complexity straight.

And it only got worse, the more programmers that were added to a project.

So we created rules for humans to follow, and enforced them through this wacky new human concept of object-oriented programming.

If you strip off all the funky language about what an object is and what a class is, the soul of object-oriented programming is just this:

A particular type of data should only be accessible, to a specific set of functions that operate on it.

Now this is not a computer rule. This is a human rule. Sure, you can break this rule anytime you want (with C).

But if we all agree to follow this rule, then if we do have a bug in our code, we usually have a pretty good idea where to find it. We don’t have to traipse all over our own code base, to find the one function that happens to inadvertently overwrite the wrong memory.

Each programmer has their own area of responsibility. Keeping data accessible only to the functions that operate on it, means that the audio programmer will only access audio data, and the graphics programmer will only access graphics data.

So, since we have agreed to follow this rule, we can now add a bunch of programmers to a project, without having them all constantly undoing one another’s work! What a novel concept.

Understanding virtual method tables
, and their relationship to classes, is probably the second-most difficult concept in object-oriented programming.

But once you’ve got that down, you can actually deduce almost all of how object-oriented programming works.

How did I understand object-oriented programming finally? Well, I wrote spaghetti code for about ten years, like everyone else did. And often I couldn’t go back and read my own code and figure out what the hell I was trying to do.

So in 1990, I was taking a compiler class at Harvard, and a few people were talking about this wacky new human concept of object-oriented programming. So I wrote a small compiler for an object-oriented language.

Anyway, once those concepts baked themselves into my brain, my whole approach to data abstraction changed. I started thinking in objects.

It was only living without object-oriented programming, that I could see the advantages of using it.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/bhw2jgix0vf1uz3k', 'title': 'What is the most difficult concept to grasp in object oriented programming (OOP)? How did you finally understand it?', 'score': {'original': 0.9686, 'ai': 0.0314}, 'blocks': [{'text': 'That computers don’t know anything about objects.\n\nNor do they know about classes, or methods, or members, or subclasses, or virtual functions, or pure functions, or any of that new-school jazz.\n\nComputers don’t care.\n\nComputers just know that there is this stuff called memory, and memory contains a bunch of numbers in it.\n\nWe humans invented object-oriented programming, in order to keep ourselves sane.\n\nTime was, we just wrote a bunch of instructions to the computer, in the computer’s own language. Look at this memory location, do the instruction there, load another memory location, add one to it, store that value in memory there, yada yada.\n\nComputers were fine with that.\n\nBut we weren’t fine with that. Once you added more than one programmer to a project, people couldn’t keep straight which memory locations did what, and which code did what, and who was responsible for what.\n\nHigh-level languages like C helped some. But we ridiculous humans still wanted all our code to access all our data at all times, with each section of the program accessing each section of memory willy-nilly.\n\nSo we were constantly creating bugs, because we couldn’t keep all that complexity straight.\n\nAnd it only got worse, the more programmers that were added to a project.\n\nSo we created rules for humans to follow, and enforced them through this wacky new human concept of object-oriented programming.\n\nIf you strip off all the funky language about what an object is and what a class is, the soul of object-oriented programming is just this:\n\nA particular type of data should only be accessible, to a specific set of functions that operate on it.\n\nNow this is not a computer rule. This is a human rule. Sure, you can break this rule anytime you want (with C).\n\nBut if we all agree to follow this rule, then if we do have a bug in our code, we usually have a pretty good idea where to find it. We don’t have to traipse all over our own code base, to find the one function that happens to inadvertently overwrite the wrong memory.\n\nEach programmer has their own area of responsibility. Keeping data accessible only to the functions that operate on it, means that the audio programmer will only access audio data, and the graphics programmer will only access graphics data.\n\nSo, since we have agreed to follow this rule, we can now add a bunch of programmers to a project, without having them all constantly undoing one another’s work! What a novel concept.\n\nUnderstanding virtual method tables\n, and their relationship to classes, is probably the second-most difficult concept in object-oriented programming.\n\nBut once you’ve got that down, you can actually deduce almost all of how object-oriented programming works.\n\nHow did I understand object-oriented programming finally? Well, I wrote spaghetti code for about ten years, like everyone else did. And often I couldn’t go back and read my own code and figure out what the hell I was trying to do.\n\nSo in 1990, I was taking a compiler class at Harvard, and a few people were talking about this wacky new human concept of object-oriented programming. So I wrote a small compiler for', 'result': {'fake': 0.0068, 'real': 0.9932}, 'status': 'success'}, {'text': 'an object-oriented language.\n\nAnyway, once those concepts baked themselves into my brain, my whole approach to data abstraction changed. I started thinking in objects.\n\nIt was only living without object-oriented programming, that I could see the advantages of using it.', 'result': {'fake': 0.1452, 'real': 0.8548}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984222, 'subscription': 0, 'content': 'That computers don’t know anything about objects.\n\nNor do they know about classes, or methods, or members, or subclasses, or virtual functions, or pure functions, or any of that new-school jazz.\n\nComputers don’t care.\n\nComputers just know that there is this stuff called memory, and memory contains a bunch of numbers in it.\n\nWe humans invented object-oriented programming, in order to keep ourselves sane.\n\nTime was, we just wrote a bunch of instructions to the computer, in the computer’s own language. Look at this memory location, do the instruction there, load another memory location, add one to it, store that value in memory there, yada yada.\n\nComputers were fine with that.\n\nBut we weren’t fine with that. Once you added more than one programmer to a project, people couldn’t keep straight which memory locations did what, and which code did what, and who was responsible for what.\n\nHigh-level languages like C helped some. But we ridiculous humans still wanted all our code to access all our data at all times, with each section of the program accessing each section of memory willy-nilly.\n\nSo we were constantly creating bugs, because we couldn’t keep all that complexity straight.\n\nAnd it only got worse, the more programmers that were added to a project.\n\nSo we created rules for humans to follow, and enforced them through this wacky new human concept of object-oriented programming.\n\nIf you strip off all the funky language about what an object is and what a class is, the soul of object-oriented programming is just this:\n\nA particular type of data should only be accessible, to a specific set of functions that operate on it.\n\nNow this is not a computer rule. This is a human rule. Sure, you can break this rule anytime you want (with C).\n\nBut if we all agree to follow this rule, then if we do have a bug in our code, we usually have a pretty good idea where to find it. We don’t have to traipse all over our own code base, to find the one function that happens to inadvertently overwrite the wrong memory.\n\nEach programmer has their own area of responsibility. Keeping data accessible only to the functions that operate on it, means that the audio programmer will only access audio data, and the graphics programmer will only access graphics data.\n\nSo, since we have agreed to follow this rule, we can now add a bunch of programmers to a project, without having them all constantly undoing one another’s work! What a novel concept.\n\nUnderstanding virtual method tables\n, and their relationship to classes, is probably the second-most difficult concept in object-oriented programming.\n\nBut once you’ve got that down, you can actually deduce almost all of how object-oriented programming works.\n\nHow did I understand object-oriented programming finally? Well, I wrote spaghetti code for about ten years, like everyone else did. And often I couldn’t go back and read my own code and figure out what the hell I was trying to do.\n\nSo in 1990, I was taking a compiler class at Harvard, and a few people were talking about this wacky new human concept of object-oriented programming. So I wrote a small compiler for an object-oriented language.\n\nAnyway, once those concepts baked themselves into my brain, my whole approach to data abstraction changed. I started thinking in objects.\n\nIt was only living without object-oriented programming, that I could see the advantages of using it.', 'aiModelVersion': '1'}",0.9686
Barry Rountree,6y,Is coding really boring and hard?,"Ever worked in the service industry?

Imagine being on your feet for eight hours interacting with strangers who think they’re entitled to order you around. Now imagine you’re doing this at sub-minimum-wage and you need tips to pay your rent. And then imagine that your career path requires doing this well enough to move to more expensive restaurants where tips are potentially larger and the entitlement issues certainly will be.

When I’m coding I can take breaks whenever I like. I have a huge amount of freedom in the problems I choose and how I choose to solve them. I have a worldwide infrastructure that I can turn to for help. And as I’m relatively senior and work for an employer that has a clue, I have an office to myself with a door I can shut.

Am I bored? Occasionally. Are things hard? From time to time. But compared to most people in the US (and certainly the world), I have an easy, exciting job that pays really well.

I try not to forget that.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/27qzvgiy5hxbfkj9', 'title': 'Is coding really boring and hard?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'Ever worked in the service industry?\n\nImagine being on your feet for eight hours interacting with strangers who think they’re entitled to order you around. Now imagine you’re doing this at sub-minimum-wage and you need tips to pay your rent. And then imagine that your career path requires doing this well enough to move to more expensive restaurants where tips are potentially larger and the entitlement issues certainly will be.\n\nWhen I’m coding I can take breaks whenever I like. I have a huge amount of freedom in the problems I choose and how I choose to solve them. I have a worldwide infrastructure that I can turn to for help. And as I’m relatively senior and work for an employer that has a clue, I have an office to myself with a door I can shut.\n\nAm I bored? Occasionally. Are things hard? From time to time. But compared to most people in the US (and certainly the world), I have an easy, exciting job that pays really well.\n\nI try not to forget that.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984220, 'subscription': 0, 'content': 'Ever worked in the service industry?\n\nImagine being on your feet for eight hours interacting with strangers who think they’re entitled to order you around. Now imagine you’re doing this at sub-minimum-wage and you need tips to pay your rent. And then imagine that your career path requires doing this well enough to move to more expensive restaurants where tips are potentially larger and the entitlement issues certainly will be.\n\nWhen I’m coding I can take breaks whenever I like. I have a huge amount of freedom in the problems I choose and how I choose to solve them. I have a worldwide infrastructure that I can turn to for help. And as I’m relatively senior and work for an employer that has a clue, I have an office to myself with a door I can shut.\n\nAm I bored? Occasionally. Are things hard? From time to time. But compared to most people in the US (and certainly the world), I have an easy, exciting job that pays really well.\n\nI try not to forget that.', 'aiModelVersion': '1'}",0.9997
Robin Thomas,Updated 6y,What are some important things that I should know in order to become a good coder?,"Do not think that the more languages you know, the better you will be.
Code. Code. Code! The more you do, the better you can become. Start an open source project. Or contribute to one. Perseverance is the key.
If you are using an IDE, make sure you become well versed in it. Customize it to yield your maximum efficiency. Learn all the keyboard shortcuts. Etch it into muscle memory.
Learn about debugging, version control, and unit tests.
Solve problems for which others are willing to pay. Or build something that might be helpful for some.
Do not try to build an exhaustive memory of all the data structures, algorithms and syntax. It’s more about how you think, rather than what you remember.
You are the average of the people you surround yourselves with. So find good people and mentors to learn from and learn with. Build a feedback loop.
Learn new programming paradigms. If don’t know OOPs, learn OOPs. You don’t know functional programming, learn it. Exposing to such new materials should improve your problem solving capability.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ty90u74sag1ilw8z', 'title': 'What are some important things that I should know in order to become a good coder?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'Do not think that the more languages you know, the better you will be.\nCode. Code. Code! The more you do, the better you can become. Start an open source project. Or contribute to one. Perseverance is the key.\nIf you are using an IDE, make sure you become well versed in it. Customize it to yield your maximum efficiency. Learn all the keyboard shortcuts. Etch it into muscle memory.\nLearn about debugging, version control, and unit tests.\nSolve problems for which others are willing to pay. Or build something that might be helpful for some.\nDo not try to build an exhaustive memory of all the data structures, algorithms and syntax. It’s more about how you think, rather than what you remember.\nYou are the average of the people you surround yourselves with. So find good people and mentors to learn from and learn with. Build a feedback loop.\nLearn new programming paradigms. If don’t know OOPs, learn OOPs. You don’t know functional programming, learn it. Exposing to such new materials should improve your problem solving capability.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984218, 'subscription': 0, 'content': 'Do not think that the more languages you know, the better you will be.\nCode. Code. Code! The more you do, the better you can become. Start an open source project. Or contribute to one. Perseverance is the key.\nIf you are using an IDE, make sure you become well versed in it. Customize it to yield your maximum efficiency. Learn all the keyboard shortcuts. Etch it into muscle memory.\nLearn about debugging, version control, and unit tests.\nSolve problems for which others are willing to pay. Or build something that might be helpful for some.\nDo not try to build an exhaustive memory of all the data structures, algorithms and syntax. It’s more about how you think, rather than what you remember.\nYou are the average of the people you surround yourselves with. So find good people and mentors to learn from and learn with. Build a feedback loop.\nLearn new programming paradigms. If don’t know OOPs, learn OOPs. You don’t know functional programming, learn it. Exposing to such new materials should improve your problem solving capability.', 'aiModelVersion': '1'}",0.9995
Mohammed Islam,Updated 4y,What harsh truths did you learn during your first year working as a software developer?,"That nothing regarding computers happens by “chance.”

In the Aviation industry, there’s a critical issue known as “blinking/blanking.”

At first I was like, “what’s the big deal with a little blink on one of the many screens on a cockpit display?” I took a flight training course later and realized the dance with death that we play with heavier-than-air machines in the sky.

So yeah… blinks are a critical issue.

So critical, that the company spent several million dollars to solve one particularly bad one. We pulled out all the stops to figure out why some of the displays were blinked momentarily, about once every 7 hours of flight time.

Six Sigma is an interesting idea. The Six comes from 6 standard deviations, meaning that the cockpit displays have to be showing correct information 99.99966% of the time (no more than 3.4 second downtime for 1,000,000 seconds).

1 second every 7 hours broke Six Sigma, and the wrath of the FAA comes down on our necks.

After the first week I was ready to give up. I wanted to say “c’mon guys, it’s just a random glitch. Let’s get over it, and move on.” But my seniors persisted.

After week 4, I was wondering if everyone around me were crazy. It’s obviously from solar radiation which flipped a random bit. These planes were flying in the sky, closer to the sun, where it’s closer to a solar flare. Duh.

But I was having fun. We would get priority access to these huge expensive simulators, and use them for overnight testing. We got to play with the autopilot system, programming random long flight patterns, and setting the craft to unlimited fuel. We’d come back in the morning hoping there were some blinks we captured in the logs.

We became Sherlock Holmes, testing every new hypothesis, uncovering every small clue. By week 6 we had figured out the problem. The next day there was a solution. A week later it was merged in, and everyone got a few hundred dollar bonus for our hard work.

I learned some hard lessons in those weeks,

How easily I wanted to give up
What real tenacity looked like, and
I can’t blame anything on solar flares.

I learned from my team, that there are no coincidences, and everything inside a computer has a reason for doing what it did.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/kgrsyn708lei95qb', 'title': 'What harsh truths did you learn during your first year working as a software developer?', 'score': {'original': 0.9995, 'ai': 0.0005}, 'blocks': [{'text': 'That nothing regarding computers happens by “chance.”\n\nIn the Aviation industry, there’s a critical issue known as “blinking/blanking.”\n\nAt first I was like, “what’s the big deal with a little blink on one of the many screens on a cockpit display?” I took a flight training course later and realized the dance with death that we play with heavier-than-air machines in the sky.\n\nSo yeah… blinks are a critical issue.\n\nSo critical, that the company spent several million dollars to solve one particularly bad one. We pulled out all the stops to figure out why some of the displays were blinked momentarily, about once every 7 hours of flight time.\n\nSix Sigma is an interesting idea. The Six comes from 6 standard deviations, meaning that the cockpit displays have to be showing correct information 99.99966% of the time (no more than 3.4 second downtime for 1,000,000 seconds).\n\n1 second every 7 hours broke Six Sigma, and the wrath of the FAA comes down on our necks.\n\nAfter the first week I was ready to give up. I wanted to say “c’mon guys, it’s just a random glitch. Let’s get over it, and move on.” But my seniors persisted.\n\nAfter week 4, I was wondering if everyone around me were crazy. It’s obviously from solar radiation which flipped a random bit. These planes were flying in the sky, closer to the sun, where it’s closer to a solar flare. Duh.\n\nBut I was having fun. We would get priority access to these huge expensive simulators, and use them for overnight testing. We got to play with the autopilot system, programming random long flight patterns, and setting the craft to unlimited fuel. We’d come back in the morning hoping there were some blinks we captured in the logs.\n\nWe became Sherlock Holmes, testing every new hypothesis, uncovering every small clue. By week 6 we had figured out the problem. The next day there was a solution. A week later it was merged in, and everyone got a few hundred dollar bonus for our hard work.\n\nI learned some hard lessons in those weeks,\n\nHow easily I wanted to give up\nWhat real tenacity looked like, and\nI can’t blame anything on solar flares.\n\nI learned from my team, that there are no coincidences, and everything inside a computer has a reason for doing what it did.', 'result': {'fake': 0.0005, 'real': 0.9995}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984214, 'subscription': 0, 'content': 'That nothing regarding computers happens by “chance.”\n\nIn the Aviation industry, there’s a critical issue known as “blinking/blanking.”\n\nAt first I was like, “what’s the big deal with a little blink on one of the many screens on a cockpit display?” I took a flight training course later and realized the dance with death that we play with heavier-than-air machines in the sky.\n\nSo yeah… blinks are a critical issue.\n\nSo critical, that the company spent several million dollars to solve one particularly bad one. We pulled out all the stops to figure out why some of the displays were blinked momentarily, about once every 7 hours of flight time.\n\nSix Sigma is an interesting idea. The Six comes from 6 standard deviations, meaning that the cockpit displays have to be showing correct information 99.99966% of the time (no more than 3.4 second downtime for 1,000,000 seconds).\n\n1 second every 7 hours broke Six Sigma, and the wrath of the FAA comes down on our necks.\n\nAfter the first week I was ready to give up. I wanted to say “c’mon guys, it’s just a random glitch. Let’s get over it, and move on.” But my seniors persisted.\n\nAfter week 4, I was wondering if everyone around me were crazy. It’s obviously from solar radiation which flipped a random bit. These planes were flying in the sky, closer to the sun, where it’s closer to a solar flare. Duh.\n\nBut I was having fun. We would get priority access to these huge expensive simulators, and use them for overnight testing. We got to play with the autopilot system, programming random long flight patterns, and setting the craft to unlimited fuel. We’d come back in the morning hoping there were some blinks we captured in the logs.\n\nWe became Sherlock Holmes, testing every new hypothesis, uncovering every small clue. By week 6 we had figured out the problem. The next day there was a solution. A week later it was merged in, and everyone got a few hundred dollar bonus for our hard work.\n\nI learned some hard lessons in those weeks,\n\nHow easily I wanted to give up\nWhat real tenacity looked like, and\nI can’t blame anything on solar flares.\n\nI learned from my team, that there are no coincidences, and everything inside a computer has a reason for doing what it did.', 'aiModelVersion': '1'}",0.9995
Dave Voorhis,Updated 3y,Will no-code make it unnecessary to learn a programming language?,"“No code” or “Low code” systems have been promoted since the 1970’s. Some, like Microsoft Excel (calculations), Crystal Reports (reporting), Tableau (data visualisation) and Labview (lab automation) are very successful within their specialist niches.

But general-purpose “No code” and “Low code” systems have never worked well, and because they’ve never worked well, they’ve never caught on.

The problem is that general-purpose “No code” and “Low code” system vendors misunderstand what makes programming hard and complex.

They think the problem is syntax, specifically text syntax. They think what makes Python or Java or C difficult is writing code as text, and that if they can replace it with something graphical or diagrammatic or templated, it will become much easier.

It won’t and it doesn’t.

The reality is that general-purpose programming is not — or at least very little — about syntax. It’s very much about manipulating the concepts of evaluation, iteration, selection, ordering, state, expressions, procedures, functions, and commands.

It doesn’t matter whether you do that with diagrams or templates or text, the essential complexity lies in manipulating the concepts — in other words, the semantics of programming — and not the syntax.

That’s why general-purpose “No code” systems don’t work. They either leave out crucial concepts or semantics that need to be manipulated, or they make manipulating them slower, more awkward, and actually more complex than using text.

For general-purpose programming, it turns out that text — code — is the most effective way to express intent to a computer. Anything and everything else is slower, more complex, more awkward, and more difficult.

As an example and an analogy, imagine this answer had to be written both as English text (which it is) and as a diagram without words.

Which do you think would be easier to write, the English text version?

Or the diagram version?

Which do you think would be easier to understand?

The same applies to general-purpose programming.

Therefore — to answer your original question — for the foreseeable future, “No Code” will not make it unnecessary to learn a programming language, if you intend to do the general-purpose programming things for which general-purpose programming languages are best.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/sb7yprxolfqew59k', 'title': 'Will no-code make it unnecessary to learn a programming language?', 'score': {'original': 0.9991, 'ai': 0.0009}, 'blocks': [{'text': '“No code” or “Low code” systems have been promoted since the 1970’s. Some, like Microsoft Excel (calculations), Crystal Reports (reporting), Tableau (data visualisation) and Labview (lab automation) are very successful within their specialist niches.\n\nBut general-purpose “No code” and “Low code” systems have never worked well, and because they’ve never worked well, they’ve never caught on.\n\nThe problem is that general-purpose “No code” and “Low code” system vendors misunderstand what makes programming hard and complex.\n\nThey think the problem is syntax, specifically text syntax. They think what makes Python or Java or C difficult is writing code as text, and that if they can replace it with something graphical or diagrammatic or templated, it will become much easier.\n\nIt won’t and it doesn’t.\n\nThe reality is that general-purpose programming is not — or at least very little — about syntax. It’s very much about manipulating the concepts of evaluation, iteration, selection, ordering, state, expressions, procedures, functions, and commands.\n\nIt doesn’t matter whether you do that with diagrams or templates or text, the essential complexity lies in manipulating the concepts — in other words, the semantics of programming — and not the syntax.\n\nThat’s why general-purpose “No code” systems don’t work. They either leave out crucial concepts or semantics that need to be manipulated, or they make manipulating them slower, more awkward, and actually more complex than using text.\n\nFor general-purpose programming, it turns out that text — code — is the most effective way to express intent to a computer. Anything and everything else is slower, more complex, more awkward, and more difficult.\n\nAs an example and an analogy, imagine this answer had to be written both as English text (which it is) and as a diagram without words.\n\nWhich do you think would be easier to write, the English text version?\n\nOr the diagram version?\n\nWhich do you think would be easier to understand?\n\nThe same applies to general-purpose programming.\n\nTherefore — to answer your original question — for the foreseeable future, “No Code” will not make it unnecessary to learn a programming language, if you intend to do the general-purpose programming things for which general-purpose programming languages are best.', 'result': {'fake': 0.0009, 'real': 0.9991}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984210, 'subscription': 0, 'content': '“No code” or “Low code” systems have been promoted since the 1970’s. Some, like Microsoft Excel (calculations), Crystal Reports (reporting), Tableau (data visualisation) and Labview (lab automation) are very successful within their specialist niches.\n\nBut general-purpose “No code” and “Low code” systems have never worked well, and because they’ve never worked well, they’ve never caught on.\n\nThe problem is that general-purpose “No code” and “Low code” system vendors misunderstand what makes programming hard and complex.\n\nThey think the problem is syntax, specifically text syntax. They think what makes Python or Java or C difficult is writing code as text, and that if they can replace it with something graphical or diagrammatic or templated, it will become much easier.\n\nIt won’t and it doesn’t.\n\nThe reality is that general-purpose programming is not — or at least very little — about syntax. It’s very much about manipulating the concepts of evaluation, iteration, selection, ordering, state, expressions, procedures, functions, and commands.\n\nIt doesn’t matter whether you do that with diagrams or templates or text, the essential complexity lies in manipulating the concepts — in other words, the semantics of programming — and not the syntax.\n\nThat’s why general-purpose “No code” systems don’t work. They either leave out crucial concepts or semantics that need to be manipulated, or they make manipulating them slower, more awkward, and actually more complex than using text.\n\nFor general-purpose programming, it turns out that text — code — is the most effective way to express intent to a computer. Anything and everything else is slower, more complex, more awkward, and more difficult.\n\nAs an example and an analogy, imagine this answer had to be written both as English text (which it is) and as a diagram without words.\n\nWhich do you think would be easier to write, the English text version?\n\nOr the diagram version?\n\nWhich do you think would be easier to understand?\n\nThe same applies to general-purpose programming.\n\nTherefore — to answer your original question — for the foreseeable future, “No Code” will not make it unnecessary to learn a programming language, if you intend to do the general-purpose programming things for which general-purpose programming languages are best.', 'aiModelVersion': '1'}",0.9991
Shai Simonson,5y,"What class should be taught in all computer science degree programs, but isn’t?","I have a strong opinion here: Compiler Design.

Of all the subsets of courses required in a CS curriculum, the most commonly required are intro programming, discrete math of some sort, data structures, algorithms, operating systems, and software engineering.

The next tier includes: programming languages, digital logic design, computer organization and architecture, data base, AI, theory of computation.

After this is a long list of various electives: robotics, machine learning, advanced systems, advanced architecture, automata theory, compiler design, graph algorithms, geometric algorithms, numerical algorithms, etc etc.

Without getting into a long discussion of what a CS curriculum should include, whether in a big or small, engineering or liberal arts setting, I claim that the biggest mistake over the USA is the loss of Compiler Design as a requirement, and the projects associated with this course. Compiler Design was popular early on in the CS curriculum evolution but fell away for various reasons… some having to do with the fact that “almost nobody writes compilers anymore, because we can specify the grammar and structure of the input, and automatically generate the compiler.”

IMO, Compiler Design is a perfect capstone/keystone for the entire CS curriculum - reinforcing notions of: theory, grammars, finite state machines, data structures, software engineering, computer architecture, and project management. Moreover, whether or not a student will ever write a compiler again, the ideas of scanners, parsers, code generators are relevant in almost any large programming project. And, I would value a programmer who understood these ideas in the context of a compiler for any project I was leading.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/6qy84vmz9crp2uhk', 'title': 'What class should be taught in all computer science degree programs, but isn’t?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'I have a strong opinion here: Compiler Design.\n\nOf all the subsets of courses required in a CS curriculum, the most commonly required are intro programming, discrete math of some sort, data structures, algorithms, operating systems, and software engineering.\n\nThe next tier includes: programming languages, digital logic design, computer organization and architecture, data base, AI, theory of computation.\n\nAfter this is a long list of various electives: robotics, machine learning, advanced systems, advanced architecture, automata theory, compiler design, graph algorithms, geometric algorithms, numerical algorithms, etc etc.\n\nWithout getting into a long discussion of what a CS curriculum should include, whether in a big or small, engineering or liberal arts setting, I claim that the biggest mistake over the USA is the loss of Compiler Design as a requirement, and the projects associated with this course. Compiler Design was popular early on in the CS curriculum evolution but fell away for various reasons… some having to do with the fact that “almost nobody writes compilers anymore, because we can specify the grammar and structure of the input, and automatically generate the compiler.”\n\nIMO, Compiler Design is a perfect capstone/keystone for the entire CS curriculum - reinforcing notions of: theory, grammars, finite state machines, data structures, software engineering, computer architecture, and project management. Moreover, whether or not a student will ever write a compiler again, the ideas of scanners, parsers, code generators are relevant in almost any large programming project. And, I would value a programmer who understood these ideas in the context of a compiler for any project I was leading.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984207, 'subscription': 0, 'content': 'I have a strong opinion here: Compiler Design.\n\nOf all the subsets of courses required in a CS curriculum, the most commonly required are intro programming, discrete math of some sort, data structures, algorithms, operating systems, and software engineering.\n\nThe next tier includes: programming languages, digital logic design, computer organization and architecture, data base, AI, theory of computation.\n\nAfter this is a long list of various electives: robotics, machine learning, advanced systems, advanced architecture, automata theory, compiler design, graph algorithms, geometric algorithms, numerical algorithms, etc etc.\n\nWithout getting into a long discussion of what a CS curriculum should include, whether in a big or small, engineering or liberal arts setting, I claim that the biggest mistake over the USA is the loss of Compiler Design as a requirement, and the projects associated with this course. Compiler Design was popular early on in the CS curriculum evolution but fell away for various reasons… some having to do with the fact that “almost nobody writes compilers anymore, because we can specify the grammar and structure of the input, and automatically generate the compiler.”\n\nIMO, Compiler Design is a perfect capstone/keystone for the entire CS curriculum - reinforcing notions of: theory, grammars, finite state machines, data structures, software engineering, computer architecture, and project management. Moreover, whether or not a student will ever write a compiler again, the ideas of scanners, parsers, code generators are relevant in almost any large programming project. And, I would value a programmer who understood these ideas in the context of a compiler for any project I was leading.', 'aiModelVersion': '1'}",0.9997
Håkon Hapnes Strand,3y,How do you deal with a very slow software developer on your team?,"It doesn't make sense to discuss this without considering the most important aspect of a software developer, and that is the quality of the work delivered.

If we imagine a matrix of speed and quality, we can identify our developer types.

Our ideal developer is the unicorn in the top right corner. You can't really hire for this, as they are extremely rare. If you're lucky enough to have one on your team, be prepared to be blown away. We're talking about one-man armies who will take weeks to do what a team of regular developers can do in months. This is not normal.

Everything else in the matrix is quite common.

On the bottom right, we have our cowboys. These guys can be good to have on your team if you need to get something very quickly to market. Managers love these developers more than anyone else. They will do whatever it takes to get stuff done asap, even if they have to stitch the solution together with paper clips and band-aid. But they can be a disaster when you have a mature solution that needs to scale.

On the bottom left, we have our Internet Explorer types. Yes, these developers are slow and produce buggy code to boot. In general, they're quite useless.

Finally, in the upper left corner we have the turtles, trying to prove that slow and steady wins the race. They take a lot of time to arrive at a solution, but it's always well thought out and properly tested.

In most cases, I'd rather have a turtle than a cowboy on my team. I know I can count on them and I know they won't wreak havoc on the codebase. They're almost ideal for working on solutions that have gone into maintenance mode. Even if they're very slow, it's rarely a problem. However, if we have hard deadlines that we desperately need to make, I would push them to try to work faster.

The real problem are the developers who are like Internet Explorer 6. Slow and buggy. The emphasis should be on pushing them in the north-east direction in the matrix.

If their problem is lack of motivation, resolving that issue can make them jump over to the cowboy quadrant. And if their problem is lack of experience, then proper training and mentoring can move them up in turtle quadrant and possibly speed them up as well.

In fact, I'd be okay with having a junior developer that delivers bad code slowly, because I know there is the potential for them to improve along both axes.

However, I'd be much less happy about having a highly experienced developer in my team who fell into that category. You can't teach an old dog new tricks.

I agree with Alan Mellor who said that kicking someone out of your team should be the last resort. But someone who is both slow and bad has almost zero value on the team, and they need to show improvement to justify their team membership.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/tqpekonxi74hc6b1', 'title': 'How do you deal with a very slow software developer on your team?', 'score': {'original': 0.9556, 'ai': 0.0444}, 'blocks': [{'text': ""It doesn't make sense to discuss this without considering the most important aspect of a software developer, and that is the quality of the work delivered.\n\nIf we imagine a matrix of speed and quality, we can identify our developer types.\n\nOur ideal developer is the unicorn in the top right corner. You can't really hire for this, as they are extremely rare. If you're lucky enough to have one on your team, be prepared to be blown away. We're talking about one-man armies who will take weeks to do what a team of regular developers can do in months. This is not normal.\n\nEverything else in the matrix is quite common.\n\nOn the bottom right, we have our cowboys. These guys can be good to have on your team if you need to get something very quickly to market. Managers love these developers more than anyone else. They will do whatever it takes to get stuff done asap, even if they have to stitch the solution together with paper clips and band-aid. But they can be a disaster when you have a mature solution that needs to scale.\n\nOn the bottom left, we have our Internet Explorer types. Yes, these developers are slow and produce buggy code to boot. In general, they're quite useless.\n\nFinally, in the upper left corner we have the turtles, trying to prove that slow and steady wins the race. They take a lot of time to arrive at a solution, but it's always well thought out and properly tested.\n\nIn most cases, I'd rather have a turtle than a cowboy on my team. I know I can count on them and I know they won't wreak havoc on the codebase. They're almost ideal for working on solutions that have gone into maintenance mode. Even if they're very slow, it's rarely a problem. However, if we have hard deadlines that we desperately need to make, I would push them to try to work faster.\n\nThe real problem are the developers who are like Internet Explorer 6. Slow and buggy. The emphasis should be on pushing them in the north-east direction in the matrix.\n\nIf their problem is lack of motivation, resolving that issue can make them jump over to the cowboy quadrant. And if their problem is lack of experience, then proper training and mentoring can move them up in turtle quadrant and possibly speed them up as well.\n\nIn fact, I'd be okay with having a junior developer that delivers bad code slowly, because I know there is the potential for them to improve along both axes.\n\nHowever, I'd be much less happy about having a highly experienced developer in my team who fell into that category. You can't teach an old dog new tricks.\n\nI agree with Alan Mellor who said that kicking someone out of your team should be the last resort. But someone who is both slow and bad has almost zero value on the team, and they need to show improvement to justify their team membership."", 'result': {'fake': 0.0444, 'real': 0.9556}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984201, 'subscription': 0, 'content': ""It doesn't make sense to discuss this without considering the most important aspect of a software developer, and that is the quality of the work delivered.\n\nIf we imagine a matrix of speed and quality, we can identify our developer types.\n\nOur ideal developer is the unicorn in the top right corner. You can't really hire for this, as they are extremely rare. If you're lucky enough to have one on your team, be prepared to be blown away. We're talking about one-man armies who will take weeks to do what a team of regular developers can do in months. This is not normal.\n\nEverything else in the matrix is quite common.\n\nOn the bottom right, we have our cowboys. These guys can be good to have on your team if you need to get something very quickly to market. Managers love these developers more than anyone else. They will do whatever it takes to get stuff done asap, even if they have to stitch the solution together with paper clips and band-aid. But they can be a disaster when you have a mature solution that needs to scale.\n\nOn the bottom left, we have our Internet Explorer types. Yes, these developers are slow and produce buggy code to boot. In general, they're quite useless.\n\nFinally, in the upper left corner we have the turtles, trying to prove that slow and steady wins the race. They take a lot of time to arrive at a solution, but it's always well thought out and properly tested.\n\nIn most cases, I'd rather have a turtle than a cowboy on my team. I know I can count on them and I know they won't wreak havoc on the codebase. They're almost ideal for working on solutions that have gone into maintenance mode. Even if they're very slow, it's rarely a problem. However, if we have hard deadlines that we desperately need to make, I would push them to try to work faster.\n\nThe real problem are the developers who are like Internet Explorer 6. Slow and buggy. The emphasis should be on pushing them in the north-east direction in the matrix.\n\nIf their problem is lack of motivation, resolving that issue can make them jump over to the cowboy quadrant. And if their problem is lack of experience, then proper training and mentoring can move them up in turtle quadrant and possibly speed them up as well.\n\nIn fact, I'd be okay with having a junior developer that delivers bad code slowly, because I know there is the potential for them to improve along both axes.\n\nHowever, I'd be much less happy about having a highly experienced developer in my team who fell into that category. You can't teach an old dog new tricks.\n\nI agree with Alan Mellor who said that kicking someone out of your team should be the last resort. But someone who is both slow and bad has almost zero value on the team, and they need to show improvement to justify their team membership."", 'aiModelVersion': '1'}",0.9556
Alan Mellor,Updated 3y,"If someone were to ruin your source code and delete half or most of it, would you be able to write it again exactly the same as you did before without using the backup? What if it was created 6 months/2 years/5 years and so on?","I’d be able to write it again but not exactly the same. I’d make different micro-decisions about the design.

Sometimes that improves the code; sometimes not.

If it is a recent loss, I find it so demotivating. It’s hard work doing that. It feels Sisyphean; ‘Get that rock back up that hill!’

I’ve had to do that after messing up a git rebase, then not being able to find my way back.

That sucks worse than Professor Sucks of Sucks University, Sucksville during a lecture on ‘Everything Sucks II’","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/8zy6e7hom2qsn0g3', 'title': 'If someone were to ruin your source code and delete half or most of it, would you be able to write it again exactly the same as you did before without using the backup? What if it was created 6 months/2 years/5 years and so on?', 'score': {'original': 0.9978, 'ai': 0.0022}, 'blocks': [{'text': 'I’d be able to write it again but not exactly the same. I’d make different micro-decisions about the design.\n\nSometimes that improves the code; sometimes not.\n\nIf it is a recent loss, I find it so demotivating. It’s hard work doing that. It feels Sisyphean; ‘Get that rock back up that hill!’\n\nI’ve had to do that after messing up a git rebase, then not being able to find my way back.\n\nThat sucks worse than Professor Sucks of Sucks University, Sucksville during a lecture on ‘Everything Sucks II’', 'result': {'fake': 0.0022, 'real': 0.9978}, 'status': 'success'}], 'credits_used': 1, 'credits': 1984200, 'subscription': 0, 'content': 'I’d be able to write it again but not exactly the same. I’d make different micro-decisions about the design.\n\nSometimes that improves the code; sometimes not.\n\nIf it is a recent loss, I find it so demotivating. It’s hard work doing that. It feels Sisyphean; ‘Get that rock back up that hill!’\n\nI’ve had to do that after messing up a git rebase, then not being able to find my way back.\n\nThat sucks worse than Professor Sucks of Sucks University, Sucksville during a lecture on ‘Everything Sucks II’', 'aiModelVersion': '1'}",0.9978
Asim Qureshi,1y,What are the best career tips for freshers?,"During the days I slaved away at Morgan Stanley, I had a colleague who was a very highly-respected market analyst.

I never quite understood what he was saying in our team meetings - it was all way over my head which was fine because I was a CMBS research specialist and he was a macro generalist.

In one of these meetings where he again said something that didn't make sense to me, I pulled him to the side and asked him to explain so I could learn a thing or two. It turned out that he had confused some fairly basic concepts, which really surprised me.

After a few weeks of listening to him carefully, I realised that his reputation as a research analyst was built not so much on what he said, rather on the extreme confidence with which he delivered his messages.

And that taught me the importance of delivery, something I lacked as a nerdy introvert - addressing it significantly propelled my career.

Now, let's fast forward to today. The new British Prime Minister, Liz Truss, and her Chancellor, Kwasi Kwarteng, have just unleashed one of the most radical budgets in British history - tax cuts for the wealthy, despite mounting debt and slow growth, funded by further borrowing - Keynes on steroids.

The pair have been lambasted by the media, the pound crashed, the Bank of England intervened in the bond markets due to a capitulation of long-dated gilts threatening pension funds and mortgages, the IMF issued a veiled warning, and there's talk of us heading towards the first ever economic crisis in Britain caused by a budget.

Yet Kwarteng is no economics lightweight. He read classics and history at Cambridge, achieving a first, became a Kennedy Scholar at Harvard, and then attained a PhD in economic history from Cambridge. How many of these doomsters know more about economics than him?

So why the panic? Because of the WAY the message was delivered. Both Truss and Kwarteng went into hiding for a week straight after the mini-budget and when Truss emerged she gave a series of car crash interviews where she came across as a complete airhead.

Had she immediately addressed concerns, spoken in interviews with a bit of gravitas, thrown in a few difficult-to-understand economic terms which would have thrown off her interviewers and given us some hope she might know something we don't, and then pushed Kwarteng to explain the economic theories behind the policies, the markets would have reacted VERY differently.

Listen, in politics, and in your career (which will have its fair share of politics), how you say things is as important as what you say and what you do. You have to say things with confidence, because if you don't have confidence in what you say, why should anyone else?","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/1gyhza68si0kfvx2', 'title': 'What are the best career tips for freshers?', 'score': {'original': 0.986, 'ai': 0.014}, 'blocks': [{'text': ""During the days I slaved away at Morgan Stanley, I had a colleague who was a very highly-respected market analyst.\n\nI never quite understood what he was saying in our team meetings - it was all way over my head which was fine because I was a CMBS research specialist and he was a macro generalist.\n\nIn one of these meetings where he again said something that didn't make sense to me, I pulled him to the side and asked him to explain so I could learn a thing or two. It turned out that he had confused some fairly basic concepts, which really surprised me.\n\nAfter a few weeks of listening to him carefully, I realised that his reputation as a research analyst was built not so much on what he said, rather on the extreme confidence with which he delivered his messages.\n\nAnd that taught me the importance of delivery, something I lacked as a nerdy introvert - addressing it significantly propelled my career.\n\nNow, let's fast forward to today. The new British Prime Minister, Liz Truss, and her Chancellor, Kwasi Kwarteng, have just unleashed one of the most radical budgets in British history - tax cuts for the wealthy, despite mounting debt and slow growth, funded by further borrowing - Keynes on steroids.\n\nThe pair have been lambasted by the media, the pound crashed, the Bank of England intervened in the bond markets due to a capitulation of long-dated gilts threatening pension funds and mortgages, the IMF issued a veiled warning, and there's talk of us heading towards the first ever economic crisis in Britain caused by a budget.\n\nYet Kwarteng is no economics lightweight. He read classics and history at Cambridge, achieving a first, became a Kennedy Scholar at Harvard, and then attained a PhD in economic history from Cambridge. How many of these doomsters know more about economics than him?\n\nSo why the panic? Because of the WAY the message was delivered. Both Truss and Kwarteng went into hiding for a week straight after the mini-budget and when Truss emerged she gave a series of car crash interviews where she came across as a complete airhead.\n\nHad she immediately addressed concerns, spoken in interviews with a bit of gravitas, thrown in a few difficult-to-understand economic terms which would have thrown off her interviewers and given us some hope she might know something we don't, and then pushed Kwarteng to explain the economic theories behind the policies, the markets would have reacted VERY differently.\n\nListen, in politics, and in your career (which will have its fair share of politics), how you say things is as important as what you say and what you do. You have to say things with confidence, because if you don't have confidence in what you say, why should anyone else?"", 'result': {'fake': 0.014, 'real': 0.986}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984195, 'subscription': 0, 'content': ""During the days I slaved away at Morgan Stanley, I had a colleague who was a very highly-respected market analyst.\n\nI never quite understood what he was saying in our team meetings - it was all way over my head which was fine because I was a CMBS research specialist and he was a macro generalist.\n\nIn one of these meetings where he again said something that didn't make sense to me, I pulled him to the side and asked him to explain so I could learn a thing or two. It turned out that he had confused some fairly basic concepts, which really surprised me.\n\nAfter a few weeks of listening to him carefully, I realised that his reputation as a research analyst was built not so much on what he said, rather on the extreme confidence with which he delivered his messages.\n\nAnd that taught me the importance of delivery, something I lacked as a nerdy introvert - addressing it significantly propelled my career.\n\nNow, let's fast forward to today. The new British Prime Minister, Liz Truss, and her Chancellor, Kwasi Kwarteng, have just unleashed one of the most radical budgets in British history - tax cuts for the wealthy, despite mounting debt and slow growth, funded by further borrowing - Keynes on steroids.\n\nThe pair have been lambasted by the media, the pound crashed, the Bank of England intervened in the bond markets due to a capitulation of long-dated gilts threatening pension funds and mortgages, the IMF issued a veiled warning, and there's talk of us heading towards the first ever economic crisis in Britain caused by a budget.\n\nYet Kwarteng is no economics lightweight. He read classics and history at Cambridge, achieving a first, became a Kennedy Scholar at Harvard, and then attained a PhD in economic history from Cambridge. How many of these doomsters know more about economics than him?\n\nSo why the panic? Because of the WAY the message was delivered. Both Truss and Kwarteng went into hiding for a week straight after the mini-budget and when Truss emerged she gave a series of car crash interviews where she came across as a complete airhead.\n\nHad she immediately addressed concerns, spoken in interviews with a bit of gravitas, thrown in a few difficult-to-understand economic terms which would have thrown off her interviewers and given us some hope she might know something we don't, and then pushed Kwarteng to explain the economic theories behind the policies, the markets would have reacted VERY differently.\n\nListen, in politics, and in your career (which will have its fair share of politics), how you say things is as important as what you say and what you do. You have to say things with confidence, because if you don't have confidence in what you say, why should anyone else?"", 'aiModelVersion': '1'}",0.986
Anonymous,6y,How bad are the worst software engineers at top companies like Google and Facebook?,"I was probably one of the worst software engineers (bottom 3%) at Google Mountain View from 2011–2013.

During my 4 years in college I did a ton of preparation for technical interviews so that hundreds of common data structure problems & algorithmic solutions were drilled into my head, but I wasn't actually that good at software engineering and my side projects were tremendously exaggerated on my resume. My internships previous to Google were at decent companies but I didn't actually do a lot of coding and was more of a project management intern than anything else prior to getting hired at Google.

So even though Google optimizes their interview process to minimize false positives, I was definitely one of those rare false positives. My interviews were for the most part easier than I expected, so I accepted the offer with much enthusiasm expecting a gentle introduction to the workflow.

Week 1 I'm assigned to a team that really didn't make that much sense given my background, and my manager gives me an assignment that I had no clue as to how to even get started working on. At this stage of my career I was still one of those coders who has to Google pretty much everything, so that I did. My coworkers were helpful at first but quickly became annoyed by my relative lack of programming experience. Fast forward a couple days and my manager asks why I haven't checked any code… I still cringe when I think of the facepalm in his eyes as he looked over my code that was mostly copied and modified from stackoverflow. Eventually I was reassigned because of my slow progress.

My next group & project was much easier but i was still clearly a noob compared to my colleagues, and did bad on performance reviews. My poor social skills certainly didn't help either. I bounced around a couple projects until Google finally fired me in early 2013 for what could be nicely described as general incompetence.

I'll admit that the perks & atmosphere at Google were pretty distracting and harmful to my overall productivity, but I was also too lazy to be a good employee and not passionate enough about what I was doing.

Nowadays I no longer work as a software engineer and run a small business. All the interview prep in the world doesn't prepare you for the reality of tough work as a software engineer at top companies.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/8j0w43gfodtzmhy5', 'title': 'How bad are the worst software engineers at top companies like Google and Facebook?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': ""I was probably one of the worst software engineers (bottom 3%) at Google Mountain View from 2011–2013.\n\nDuring my 4 years in college I did a ton of preparation for technical interviews so that hundreds of common data structure problems & algorithmic solutions were drilled into my head, but I wasn't actually that good at software engineering and my side projects were tremendously exaggerated on my resume. My internships previous to Google were at decent companies but I didn't actually do a lot of coding and was more of a project management intern than anything else prior to getting hired at Google.\n\nSo even though Google optimizes their interview process to minimize false positives, I was definitely one of those rare false positives. My interviews were for the most part easier than I expected, so I accepted the offer with much enthusiasm expecting a gentle introduction to the workflow.\n\nWeek 1 I'm assigned to a team that really didn't make that much sense given my background, and my manager gives me an assignment that I had no clue as to how to even get started working on. At this stage of my career I was still one of those coders who has to Google pretty much everything, so that I did. My coworkers were helpful at first but quickly became annoyed by my relative lack of programming experience. Fast forward a couple days and my manager asks why I haven't checked any code… I still cringe when I think of the facepalm in his eyes as he looked over my code that was mostly copied and modified from stackoverflow. Eventually I was reassigned because of my slow progress.\n\nMy next group & project was much easier but i was still clearly a noob compared to my colleagues, and did bad on performance reviews. My poor social skills certainly didn't help either. I bounced around a couple projects until Google finally fired me in early 2013 for what could be nicely described as general incompetence.\n\nI'll admit that the perks & atmosphere at Google were pretty distracting and harmful to my overall productivity, but I was also too lazy to be a good employee and not passionate enough about what I was doing.\n\nNowadays I no longer work as a software engineer and run a small business. All the interview prep in the world doesn't prepare you for the reality of tough work as a software engineer at top companies."", 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984190, 'subscription': 0, 'content': ""I was probably one of the worst software engineers (bottom 3%) at Google Mountain View from 2011–2013.\n\nDuring my 4 years in college I did a ton of preparation for technical interviews so that hundreds of common data structure problems & algorithmic solutions were drilled into my head, but I wasn't actually that good at software engineering and my side projects were tremendously exaggerated on my resume. My internships previous to Google were at decent companies but I didn't actually do a lot of coding and was more of a project management intern than anything else prior to getting hired at Google.\n\nSo even though Google optimizes their interview process to minimize false positives, I was definitely one of those rare false positives. My interviews were for the most part easier than I expected, so I accepted the offer with much enthusiasm expecting a gentle introduction to the workflow.\n\nWeek 1 I'm assigned to a team that really didn't make that much sense given my background, and my manager gives me an assignment that I had no clue as to how to even get started working on. At this stage of my career I was still one of those coders who has to Google pretty much everything, so that I did. My coworkers were helpful at first but quickly became annoyed by my relative lack of programming experience. Fast forward a couple days and my manager asks why I haven't checked any code… I still cringe when I think of the facepalm in his eyes as he looked over my code that was mostly copied and modified from stackoverflow. Eventually I was reassigned because of my slow progress.\n\nMy next group & project was much easier but i was still clearly a noob compared to my colleagues, and did bad on performance reviews. My poor social skills certainly didn't help either. I bounced around a couple projects until Google finally fired me in early 2013 for what could be nicely described as general incompetence.\n\nI'll admit that the perks & atmosphere at Google were pretty distracting and harmful to my overall productivity, but I was also too lazy to be a good employee and not passionate enough about what I was doing.\n\nNowadays I no longer work as a software engineer and run a small business. All the interview prep in the world doesn't prepare you for the reality of tough work as a software engineer at top companies."", 'aiModelVersion': '1'}",0.9998
Alan Mellor,2y,"Do most companies who say they use Agile these days just do daily standups (sitting down) with demos at the end of each sprint, and nothing else like retros or planning poker? Are developers tired of Agile?","More common is Watergile, also known as Agilefail.

This is where you turn a project into short, inflexible, thoroughly pre-planned, forecasted and committed chunks.

Agile was originally an attempt to embrace the uncertainty of development, not a revenue stream for consultants. We all got lost and bamboozled along the way.

There is strong commercial pressure to make project deliveries predictable, repeatable and forecastable. That is all well and good. But we still lack the required crystal ball to guarantee that.

Agile was once nothing more than iterative development. A bit of design as you go. A little rough estimation of maybe when and how much. All that was helped by ‘shifting left’ things like testing, integration and deployment and user testing.

Many companies simply do not do that. Any of that.

Agile has become a rigid, inflexible process that must be followed even when the specifics are not delivering good outcomes. We set long deadlines. Commit to specific deliverables on each iteration. Insist that all ‘sprint commitments’ (say what?) are delivered, even if that means the dev team work late whilst the ‘scrum master’ is on the golf course.

Whatever is happening, it’s not the spirit of that original agile manifesto.

Have a look at agile 20 years ago:

Manifesto for Agile Software Development
https://agilemanifesto.org/

Do you recognise that in your workplace?","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/5xy2wc1dgro7ujkm', 'title': 'Do most companies who say they use Agile these days just do daily standups (sitting down) with demos at the end of each sprint, and nothing else like retros or planning poker? Are developers tired of Agile?', 'score': {'original': 0.9992, 'ai': 0.0008}, 'blocks': [{'text': 'More common is Watergile, also known as Agilefail.\n\nThis is where you turn a project into short, inflexible, thoroughly pre-planned, forecasted and committed chunks.\n\nAgile was originally an attempt to embrace the uncertainty of development, not a revenue stream for consultants. We all got lost and bamboozled along the way.\n\nThere is strong commercial pressure to make project deliveries predictable, repeatable and forecastable. That is all well and good. But we still lack the required crystal ball to guarantee that.\n\nAgile was once nothing more than iterative development. A bit of design as you go. A little rough estimation of maybe when and how much. All that was helped by ‘shifting left’ things like testing, integration and deployment and user testing.\n\nMany companies simply do not do that. Any of that.\n\nAgile has become a rigid, inflexible process that must be followed even when the specifics are not delivering good outcomes. We set long deadlines. Commit to specific deliverables on each iteration. Insist that all ‘sprint commitments’ (say what?) are delivered, even if that means the dev team work late whilst the ‘scrum master’ is on the golf course.\n\nWhatever is happening, it’s not the spirit of that original agile manifesto.\n\nHave a look at agile 20 years ago:\n\nManifesto for Agile Software Development\nhttps://agilemanifesto.org/\n\nDo you recognise that in your workplace?', 'result': {'fake': 0.0008, 'real': 0.9992}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984187, 'subscription': 0, 'content': 'More common is Watergile, also known as Agilefail.\n\nThis is where you turn a project into short, inflexible, thoroughly pre-planned, forecasted and committed chunks.\n\nAgile was originally an attempt to embrace the uncertainty of development, not a revenue stream for consultants. We all got lost and bamboozled along the way.\n\nThere is strong commercial pressure to make project deliveries predictable, repeatable and forecastable. That is all well and good. But we still lack the required crystal ball to guarantee that.\n\nAgile was once nothing more than iterative development. A bit of design as you go. A little rough estimation of maybe when and how much. All that was helped by ‘shifting left’ things like testing, integration and deployment and user testing.\n\nMany companies simply do not do that. Any of that.\n\nAgile has become a rigid, inflexible process that must be followed even when the specifics are not delivering good outcomes. We set long deadlines. Commit to specific deliverables on each iteration. Insist that all ‘sprint commitments’ (say what?) are delivered, even if that means the dev team work late whilst the ‘scrum master’ is on the golf course.\n\nWhatever is happening, it’s not the spirit of that original agile manifesto.\n\nHave a look at agile 20 years ago:\n\nManifesto for Agile Software Development\nhttps://agilemanifesto.org/\n\nDo you recognise that in your workplace?', 'aiModelVersion': '1'}",0.9992
Nick Pappas,Updated 5y,Do programmers prefer coding at night? Why?,"I am not sure if everyone prefers it; I most certainly do… but first let me tell you this:

Plenty of times I have found myself coding at night because coding is often like civilization. The game.

For coding is, “just one more method/function” or “just one more thing to try”.

Given that, and given that at night it is usually the best time of the day to avoid this:

which could be either digital:

or analog:

I can imagine that plenty of people would prefer coding at the time where the distractions are minimized and the productivity is maximized.

Here is a graph that illustrates what I am talking about for your convenience:","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/slbwge7nr3u6y59i', 'title': 'Do programmers prefer coding at night? Why?', 'score': {'original': 0.9854, 'ai': 0.0146}, 'blocks': [{'text': 'I am not sure if everyone prefers it; I most certainly do… but first let me tell you this:\n\nPlenty of times I have found myself coding at night because coding is often like civilization. The game.\n\nFor coding is, “just one more method/function” or “just one more thing to try”.\n\nGiven that, and given that at night it is usually the best time of the day to avoid this:\n\nwhich could be either digital:\n\nor analog:\n\nI can imagine that plenty of people would prefer coding at the time where the distractions are minimized and the productivity is maximized.\n\nHere is a graph that illustrates what I am talking about for your convenience:', 'result': {'fake': 0.0146, 'real': 0.9854}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984185, 'subscription': 0, 'content': 'I am not sure if everyone prefers it; I most certainly do… but first let me tell you this:\n\nPlenty of times I have found myself coding at night because coding is often like civilization. The game.\n\nFor coding is, “just one more method/function” or “just one more thing to try”.\n\nGiven that, and given that at night it is usually the best time of the day to avoid this:\n\nwhich could be either digital:\n\nor analog:\n\nI can imagine that plenty of people would prefer coding at the time where the distractions are minimized and the productivity is maximized.\n\nHere is a graph that illustrates what I am talking about for your convenience:', 'aiModelVersion': '1'}",0.9854
Ben Podgursky,4y,"In computer science, what is the ""two generals problem""?","There is no algorithm by which two agents, separated by time and unreliable means of communication, can ever come up with a plan that requires both agents to act on the plan and guarantees success.

The original formulation was:

“Two generals are on opposite sides of a city. If they both attack at dawn, the attack will succeed. If either of them attacks without support, the attack will fail with great loss of life. Messengers sent between the camps are sometimes intercepted and lost.

Can they communicate with each other and come up with a plan which guarantees that they will either both attack at dawn, or neither will attack?”

And the answer is no, there is no such algorithm. Your only choice is to increase the reliability of your signal-passing and hope for the best.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/k4lypxu168wn7d9j', 'title': 'In computer science, what is the ""two generals problem""?', 'score': {'original': 0.5168, 'ai': 0.4832}, 'blocks': [{'text': 'There is no algorithm by which two agents, separated by time and unreliable means of communication, can ever come up with a plan that requires both agents to act on the plan and guarantees success.\n\nThe original formulation was:\n\n“Two generals are on opposite sides of a city. If they both attack at dawn, the attack will succeed. If either of them attacks without support, the attack will fail with great loss of life. Messengers sent between the camps are sometimes intercepted and lost.\n\nCan they communicate with each other and come up with a plan which guarantees that they will either both attack at dawn, or neither will attack?”\n\nAnd the answer is no, there is no such algorithm. Your only choice is to increase the reliability of your signal-passing and hope for the best.', 'result': {'fake': 0.4832, 'real': 0.5168}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984183, 'subscription': 0, 'content': 'There is no algorithm by which two agents, separated by time and unreliable means of communication, can ever come up with a plan that requires both agents to act on the plan and guarantees success.\n\nThe original formulation was:\n\n“Two generals are on opposite sides of a city. If they both attack at dawn, the attack will succeed. If either of them attacks without support, the attack will fail with great loss of life. Messengers sent between the camps are sometimes intercepted and lost.\n\nCan they communicate with each other and come up with a plan which guarantees that they will either both attack at dawn, or neither will attack?”\n\nAnd the answer is no, there is no such algorithm. Your only choice is to increase the reliability of your signal-passing and hope for the best.', 'aiModelVersion': '1'}",0.5168
Brandon Ross,Updated Aug 30,How difficult is it to find highly talented software developers?,"It’s not. Not at all.

Most people just don’t want to pay for it.

It’s like walking into a Kohl’s Department Store and complaining that you can’t find Gucci or Prada. You’re bargain shopping in the wrong place for something far outside of your budget.

Look, there's a wide range of skills. You can pay for whatever you want. If you've done tech hiring, you really want to look for experience. Experience means a lot.

Me? If your email isn’t related to a non-equity offer with at least $250,000/year, it’s spam. Seriously, in my first email check in the morning, I remove all the job-offer clutter from my inbox. If you include a cute cat pic or your favorite XKCD strip I might even read it before I trash it. And everything from LinkedIn goes right to the trash. Does your email include the phrases “10x”, “ninja”, or “Jedi""? You are cancer. Deleted.

Seriously. I get 4–6 of those messages a day, everyday from some corporate recruiter I’ve never met offering some vague, “exciting new opportunity”. Maybe even inviting me to fly out to San Francisco (ugh, gross)—at my own expense, no less—for multiple technical interviews.

And I know I sound like an asshole when I say that. But, c’mon, guys. I’ve carved out this little niche for “fixing” crashing startups. And I’m not going to do the work of 2-3 junior engineers and a project manager on a speculative start-up for maybe $80,000/year.

You cannot easily find “highly talented software developers” if you’re headhunting on a budget.

Big Problem No. 1: Executives and executive teams don’t even know what they’re looking for. Or what a reasonable development budget looks like. Or even what a reasonable time frame to product release looks like. They don't know.

It's not a sin to be ignorant. But it gets worse because…

Big Problem No. 2: They also don’t know how to figure out what they need—unless they happen to have hands-on experience in that space.

If they hired a “highly talented” software developer, that would solve their problem. But, as previously established, they often don’t want to do that. It’s a bit of a Catch-22.

So, they often off-load their talent search to someone who knows even less than they do. Corporate recruiters know nothing about technology and less about the technology space.

As an example, one of the last projects I worked on in NYC. The CEO offered to pay me roughly $20,000/mo. plus the departing “CTO”’s equity stake. Just to get his ship under control ASAP. As you might imagine, I was pretty hesitant to do this. I assumed the equity stake was worth $0—as you should—and went anyway.

As expected, it was a mess. But not for the reason you’d think. They had junior developers with no experience working without any guidance in languages and in frameworks they’d never touched. No coding standards. No project management. No written documents, designs, or artifacts of any kind. Literally tabula rasa. It was like walking in on Day 1. Not Day 0. Some crap was already flung at the wall.

It took me about two weeks to figure out the real problem: the CEO insisted on doing all the technical and hiring himself. Which is part of the reason the previous CTO left in a tantrum. The CEO was a hardcore micromanager. And the CTO had recommended removing some of the juniors and bringing in at least one senior engineer. Which the CEO refused to do.

The CEO didn’t want to let one of the juniors go (without knowing this issue before, I also recommended on my second day that the junior be fired immediately) and bristled at the extra expense of more software engineers. I told the CEO straight up: you need to cut the surplus juniors and give the rest some direction.

The CEO was trying to determine which technology frameworks would be used. And roughly this conversation took place:

Me: So, we need to make a decision on this technology framework and the decision cannot wait. For all the reasons we discussed yesterday, I selected X.

CEO: I want to use Y. A friend of mine said it would be better.

Me: Okay. We can do that. However, if we do that, nobody here knows how to use it. Even I don’t know how to use it. Literally, Y is not used in production anywhere. Nobody, nowhere. It’s not enterprise-ready. It will increase development time by 3–4 weeks minimum, for the most barebones product. It will increase the cost to maintain this codebase. There is not a single reason to use it—except that it’s written in Java. Which isn’t a good reason. We already have two developers who are using X. We should use X.

CEO: I want to use Y.

Me: We’ve previously discussed that you have no software experience whatsoever. Which is why you are paying me. Can you describe to me what makes Y better?

CEO: No.

Me: Then, again, I strongly suggest we use X. If you want to use Y, it’s going to cost a lot of money. That could be better spent on paying software engineers to produce the product, instead of how to use Y, something that nobody uses. If I were the CTO, I would completely ignore you and use X because it’s not your decision to make. That’s the point of having a CTO. But your CTO is MIA, and now you’ve got me. So, follow my suggestions and your next CTO won’t hate you.

Not surprisingly, CEO insisted on using Y.

And you know? I try to not to sugarcoat any of this, because I’ve been through enough rodeos to not care about hurting management’s feelings too much.

Some of them are good in a verbal scrap, and then the decision is made and it's done. Some… tragically, they get their feelings hurt like children and cry and moan about. And treat everyone poorly in response.

At the end of the day, it’s (usually) their money. I’m very happy to do the job their way. As long as they’re paying me on time, I’ll do the best job possible. But doing the “best job possible” also means telling them, from time to time, what they’re doing some very wrong.

Why even relay that story? It’s an example of the non-comfort v. high-control that executive decision-makers often have with technology issues. They’re extremely uncomfortable. And they don’t want to bring someone who is comfortable on-board in a decision-making capacity. But they know they need us: their whole business runs on “magic” that they don’t understand.

Great executive leaders understand this dynamic. And they’re fine with off-loading what they’re not competent with. That is how shit gets done. (Without everyone losing their sanity.)

And then there’s everyone else. They’re so overwhelmed by uncertainty, they would rather do nothing than to spend the money they need to make money. And if they would have started with a solid development budget, they wouldn’t have a problem in maybe 95% of cases.

And so many executives have an attitude of selling the idea of the product to their investors by asking some juniors to slap a proof-of-concept together. Sure. Phoning in your product is \always\ a solid plan.

Unrealistic expectations abound in software because it's vapor to most people. Here's a tip to gauge management's sanity. Ask them how much they think Instagram's first, basic app and backend cost to develop. If they say anything under $250,000, they don't have realistic expectations. (And people will cry and say you can do an Instagram clone for $30,000. —Really? Oh, right. Two apps? Er, $60,000. And the backend? Oh, right. $120,000. —And it has to scale massively? Er, $250,000. Bare minimums? You get the idea.)

Your job, partly, is to show them the way. Sure, management has real cost constraints to manage. Labor is the biggest expense—which means it's a slider they can move around. Like that switch on a control panel that someone put duct tape over years ago.

I mean, I’m not here to take your job, Mr. CEO. But I can tell you with 100% confidence that if you don’t spend on software engineers roughly how I’m suggesting, you’ll never complete the product. And I do like to keep things nimble and efficient—especially when I have equity. There’s just a minimum level you need to spend to get where you want to be. If you can’t spend at least that minimum amount, pack up and go home because you’re just lighting your money on fire. —Do you like lighting money on fire?!

Apparently, a lot of people do.

Some people will think this far too crass. It's not meant to be that way. My point is, many people just have unrealistic expectations about what good software engineers actually cost.

You want to find highly talented software developers? I keep a small stack of resumes of extremely talented guys I know I can call any time. But the guy with the least experience isn’t going to touch anything for under $150,000/year.

So that’s why some may find it hard: can you afford what you’re looking for?","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/vnicxkafb10w4gez', 'title': 'How difficult is it to find highly talented software developers?', 'score': {'original': 0.85166666666667, 'ai': 0.14833333333333}, 'blocks': [{'text': 'It’s not. Not at all.\n\nMost people just don’t want to pay for it.\n\nIt’s like walking into a Kohl’s Department Store and complaining that you can’t find Gucci or Prada. You’re bargain shopping in the wrong place for something far outside of your budget.\n\nLook, there\'s a wide range of skills. You can pay for whatever you want. If you\'ve done tech hiring, you really want to look for experience. Experience means a lot.\n\nMe? If your email isn’t related to a non-equity offer with at least $250,000/year, it’s spam. Seriously, in my first email check in the morning, I remove all the job-offer clutter from my inbox. If you include a cute cat pic or your favorite XKCD strip I might even read it before I trash it. And everything from LinkedIn goes right to the trash. Does your email include the phrases “10x”, “ninja”, or “Jedi""? You are cancer. Deleted.\n\nSeriously. I get 4–6 of those messages a day, everyday from some corporate recruiter I’ve never met offering some vague, “exciting new opportunity”. Maybe even inviting me to fly out to San Francisco (ugh, gross)—at my own expense, no less—for multiple technical interviews.\n\nAnd I know I sound like an asshole when I say that. But, c’mon, guys. I’ve carved out this little niche for “fixing” crashing startups. And I’m not going to do the work of 2-3 junior engineers and a project manager on a speculative start-up for maybe $80,000/year.\n\nYou cannot easily find “highly talented software developers” if you’re headhunting on a budget.\n\nBig Problem No. 1: Executives and executive teams don’t even know what they’re looking for. Or what a reasonable development budget looks like. Or even what a reasonable time frame to product release looks like. They don\'t know.\n\nIt\'s not a sin to be ignorant. But it gets worse because…\n\nBig Problem No. 2: They also don’t know how to figure out what they need—unless they happen to have hands-on experience in that space.\n\nIf they hired a “highly talented” software developer, that would solve their problem. But, as previously established, they often don’t want to do that. It’s a bit of a Catch-22.\n\nSo, they often off-load their talent search to someone who knows even less than they do. Corporate recruiters know nothing about technology and less about the technology space.\n\nAs an example, one of the last projects I worked on in NYC. The CEO offered to pay me roughly $20,000/mo. plus the departing “CTO”’s equity stake. Just to get his ship under control ASAP. As you might imagine, I was pretty hesitant to do this. I assumed the equity stake was worth $0—as you should—and went anyway.\n\nAs expected, it was a mess. But not for the reason you’d think. They had junior developers with no experience working without any guidance in languages and in frameworks they’d never touched. No coding standards. No project management. No written documents, designs, or artifacts of any kind. Literally tabula rasa. It was like walking in on Day 1. Not Day 0. Some crap was already flung at the wall.\n\nIt took me about two weeks to figure out the', 'result': {'fake': 0.0263, 'real': 0.9737}, 'status': 'success'}, {'text': ""real problem: the CEO insisted on doing all the technical and hiring himself. Which is part of the reason the previous CTO left in a tantrum. The CEO was a hardcore micromanager. And the CTO had recommended removing some of the juniors and bringing in at least one senior engineer. Which the CEO refused to do.\n\nThe CEO didn’t want to let one of the juniors go (without knowing this issue before, I also recommended on my second day that the junior be fired immediately) and bristled at the extra expense of more software engineers. I told the CEO straight up: you need to cut the surplus juniors and give the rest some direction.\n\nThe CEO was trying to determine which technology frameworks would be used. And roughly this conversation took place:\n\nMe: So, we need to make a decision on this technology framework and the decision cannot wait. For all the reasons we discussed yesterday, I selected X.\n\nCEO: I want to use Y. A friend of mine said it would be better.\n\nMe: Okay. We can do that. However, if we do that, nobody here knows how to use it. Even I don’t know how to use it. Literally, Y is not used in production anywhere. Nobody, nowhere. It’s not enterprise-ready. It will increase development time by 3–4 weeks minimum, for the most barebones product. It will increase the cost to maintain this codebase. There is not a single reason to use it—except that it’s written in Java. Which isn’t a good reason. We already have two developers who are using X. We should use X.\n\nCEO: I want to use Y.\n\nMe: We’ve previously discussed that you have no software experience whatsoever. Which is why you are paying me. Can you describe to me what makes Y better?\n\nCEO: No.\n\nMe: Then, again, I strongly suggest we use X. If you want to use Y, it’s going to cost a lot of money. That could be better spent on paying software engineers to produce the product, instead of how to use Y, something that nobody uses. If I were the CTO, I would completely ignore you and use X because it’s not your decision to make. That’s the point of having a CTO. But your CTO is MIA, and now you’ve got me. So, follow my suggestions and your next CTO won’t hate you.\n\nNot surprisingly, CEO insisted on using Y.\n\nAnd you know? I try to not to sugarcoat any of this, because I’ve been through enough rodeos to not care about hurting management’s feelings too much.\n\nSome of them are good in a verbal scrap, and then the decision is made and it's done. Some… tragically, they get their feelings hurt like children and cry and moan about. And treat everyone poorly in response.\n\nAt the end of the day, it’s (usually) their money. I’m very happy to do the job their way. As long as they’re paying me on time, I’ll do the best job possible. But doing the “best job possible” also means telling them, from time to time, what they’re doing some very wrong.\n\nWhy even relay that"", 'result': {'fake': 0.0327, 'real': 0.9673}, 'status': 'success'}, {'text': ""story? It’s an example of the non-comfort v. high-control that executive decision-makers often have with technology issues. They’re extremely uncomfortable. And they don’t want to bring someone who is comfortable on-board in a decision-making capacity. But they know they need us: their whole business runs on “magic” that they don’t understand.\n\nGreat executive leaders understand this dynamic. And they’re fine with off-loading what they’re not competent with. That is how shit gets done. (Without everyone losing their sanity.)\n\nAnd then there’s everyone else. They’re so overwhelmed by uncertainty, they would rather do nothing than to spend the money they need to make money. And if they would have started with a solid development budget, they wouldn’t have a problem in maybe 95% of cases.\n\nAnd so many executives have an attitude of selling the idea of the product to their investors by asking some juniors to slap a proof-of-concept together. Sure. Phoning in your product is \\always\\ a solid plan.\n\nUnrealistic expectations abound in software because it's vapor to most people. Here's a tip to gauge management's sanity. Ask them how much they think Instagram's first, basic app and backend cost to develop. If they say anything under $250,000, they don't have realistic expectations. (And people will cry and say you can do an Instagram clone for $30,000. —Really? Oh, right. Two apps? Er, $60,000. And the backend? Oh, right. $120,000. —And it has to scale massively? Er, $250,000. Bare minimums? You get the idea.)\n\nYour job, partly, is to show them the way. Sure, management has real cost constraints to manage. Labor is the biggest expense—which means it's a slider they can move around. Like that switch on a control panel that someone put duct tape over years ago.\n\nI mean, I’m not here to take your job, Mr. CEO. But I can tell you with 100% confidence that if you don’t spend on software engineers roughly how I’m suggesting, you’ll never complete the product. And I do like to keep things nimble and efficient—especially when I have equity. There’s just a minimum level you need to spend to get where you want to be. If you can’t spend at least that minimum amount, pack up and go home because you’re just lighting your money on fire. —Do you like lighting money on fire?!\n\nApparently, a lot of people do.\n\nSome people will think this far too crass. It's not meant to be that way. My point is, many people just have unrealistic expectations about what good software engineers actually cost.\n\nYou want to find highly talented software developers? I keep a small stack of resumes of extremely talented guys I know I can call any time. But the guy with the least experience isn’t going to touch anything for under $150,000/year.\n\nSo that’s why some may find it hard: can you afford what you’re looking for?"", 'result': {'fake': 0.752, 'real': 0.248}, 'status': 'success'}], 'credits_used': 16, 'credits': 1984167, 'subscription': 0, 'content': 'It’s not. Not at all.\n\nMost people just don’t want to pay for it.\n\nIt’s like walking into a Kohl’s Department Store and complaining that you can’t find Gucci or Prada. You’re bargain shopping in the wrong place for something far outside of your budget.\n\nLook, there\'s a wide range of skills. You can pay for whatever you want. If you\'ve done tech hiring, you really want to look for experience. Experience means a lot.\n\nMe? If your email isn’t related to a non-equity offer with at least $250,000/year, it’s spam. Seriously, in my first email check in the morning, I remove all the job-offer clutter from my inbox. If you include a cute cat pic or your favorite XKCD strip I might even read it before I trash it. And everything from LinkedIn goes right to the trash. Does your email include the phrases “10x”, “ninja”, or “Jedi""? You are cancer. Deleted.\n\nSeriously. I get 4–6 of those messages a day, everyday from some corporate recruiter I’ve never met offering some vague, “exciting new opportunity”. Maybe even inviting me to fly out to San Francisco (ugh, gross)—at my own expense, no less—for multiple technical interviews.\n\nAnd I know I sound like an asshole when I say that. But, c’mon, guys. I’ve carved out this little niche for “fixing” crashing startups. And I’m not going to do the work of 2-3 junior engineers and a project manager on a speculative start-up for maybe $80,000/year.\n\nYou cannot easily find “highly talented software developers” if you’re headhunting on a budget.\n\nBig Problem No. 1: Executives and executive teams don’t even know what they’re looking for. Or what a reasonable development budget looks like. Or even what a reasonable time frame to product release looks like. They don\'t know.\n\nIt\'s not a sin to be ignorant. But it gets worse because…\n\nBig Problem No. 2: They also don’t know how to figure out what they need—unless they happen to have hands-on experience in that space.\n\nIf they hired a “highly talented” software developer, that would solve their problem. But, as previously established, they often don’t want to do that. It’s a bit of a Catch-22.\n\nSo, they often off-load their talent search to someone who knows even less than they do. Corporate recruiters know nothing about technology and less about the technology space.\n\nAs an example, one of the last projects I worked on in NYC. The CEO offered to pay me roughly $20,000/mo. plus the departing “CTO”’s equity stake. Just to get his ship under control ASAP. As you might imagine, I was pretty hesitant to do this. I assumed the equity stake was worth $0—as you should—and went anyway.\n\nAs expected, it was a mess. But not for the reason you’d think. They had junior developers with no experience working without any guidance in languages and in frameworks they’d never touched. No coding standards. No project management. No written documents, designs, or artifacts of any kind. Literally tabula rasa. It was like walking in on Day 1. Not Day 0. Some crap was already flung at the wall.\n\nIt took me about two weeks to figure out the real problem: the CEO insisted on doing all the technical and hiring himself. Which is part of the reason the previous CTO left in a tantrum. The CEO was a hardcore micromanager. And the CTO had recommended removing some of the juniors and bringing in at least one senior engineer. Which the CEO refused to do.\n\nThe CEO didn’t want to let one of the juniors go (without knowing this issue before, I also recommended on my second day that the junior be fired immediately) and bristled at the extra expense of more software engineers. I told the CEO straight up: you need to cut the surplus juniors and give the rest some direction.\n\nThe CEO was trying to determine which technology frameworks would be used. And roughly this conversation took place:\n\nMe: So, we need to make a decision on this technology framework and the decision cannot wait. For all the reasons we discussed yesterday, I selected X.\n\nCEO: I want to use Y. A friend of mine said it would be better.\n\nMe: Okay. We can do that. However, if we do that, nobody here knows how to use it. Even I don’t know how to use it. Literally, Y is not used in production anywhere. Nobody, nowhere. It’s not enterprise-ready. It will increase development time by 3–4 weeks minimum, for the most barebones product. It will increase the cost to maintain this codebase. There is not a single reason to use it—except that it’s written in Java. Which isn’t a good reason. We already have two developers who are using X. We should use X.\n\nCEO: I want to use Y.\n\nMe: We’ve previously discussed that you have no software experience whatsoever. Which is why you are paying me. Can you describe to me what makes Y better?\n\nCEO: No.\n\nMe: Then, again, I strongly suggest we use X. If you want to use Y, it’s going to cost a lot of money. That could be better spent on paying software engineers to produce the product, instead of how to use Y, something that nobody uses. If I were the CTO, I would completely ignore you and use X because it’s not your decision to make. That’s the point of having a CTO. But your CTO is MIA, and now you’ve got me. So, follow my suggestions and your next CTO won’t hate you.\n\nNot surprisingly, CEO insisted on using Y.\n\nAnd you know? I try to not to sugarcoat any of this, because I’ve been through enough rodeos to not care about hurting management’s feelings too much.\n\nSome of them are good in a verbal scrap, and then the decision is made and it\'s done. Some… tragically, they get their feelings hurt like children and cry and moan about. And treat everyone poorly in response.\n\nAt the end of the day, it’s (usually) their money. I’m very happy to do the job their way. As long as they’re paying me on time, I’ll do the best job possible. But doing the “best job possible” also means telling them, from time to time, what they’re doing some very wrong.\n\nWhy even relay that story? It’s an example of the non-comfort v. high-control that executive decision-makers often have with technology issues. They’re extremely uncomfortable. And they don’t want to bring someone who is comfortable on-board in a decision-making capacity. But they know they need us: their whole business runs on “magic” that they don’t understand.\n\nGreat executive leaders understand this dynamic. And they’re fine with off-loading what they’re not competent with. That is how shit gets done. (Without everyone losing their sanity.)\n\nAnd then there’s everyone else. They’re so overwhelmed by uncertainty, they would rather do nothing than to spend the money they need to make money. And if they would have started with a solid development budget, they wouldn’t have a problem in maybe 95% of cases.\n\nAnd so many executives have an attitude of selling the idea of the product to their investors by asking some juniors to slap a proof-of-concept together. Sure. Phoning in your product is \\always\\ a solid plan.\n\nUnrealistic expectations abound in software because it\'s vapor to most people. Here\'s a tip to gauge management\'s sanity. Ask them how much they think Instagram\'s first, basic app and backend cost to develop. If they say anything under $250,000, they don\'t have realistic expectations. (And people will cry and say you can do an Instagram clone for $30,000. —Really? Oh, right. Two apps? Er, $60,000. And the backend? Oh, right. $120,000. —And it has to scale massively? Er, $250,000. Bare minimums? You get the idea.)\n\nYour job, partly, is to show them the way. Sure, management has real cost constraints to manage. Labor is the biggest expense—which means it\'s a slider they can move around. Like that switch on a control panel that someone put duct tape over years ago.\n\nI mean, I’m not here to take your job, Mr. CEO. But I can tell you with 100% confidence that if you don’t spend on software engineers roughly how I’m suggesting, you’ll never complete the product. And I do like to keep things nimble and efficient—especially when I have equity. There’s just a minimum level you need to spend to get where you want to be. If you can’t spend at least that minimum amount, pack up and go home because you’re just lighting your money on fire. —Do you like lighting money on fire?!\n\nApparently, a lot of people do.\n\nSome people will think this far too crass. It\'s not meant to be that way. My point is, many people just have unrealistic expectations about what good software engineers actually cost.\n\nYou want to find highly talented software developers? I keep a small stack of resumes of extremely talented guys I know I can call any time. But the guy with the least experience isn’t going to touch anything for under $150,000/year.\n\nSo that’s why some may find it hard: can you afford what you’re looking for?', 'aiModelVersion': '1'}",0.85166666666667
Otip R. Kohn,Updated 4y,"As a programmer, software engineer, or developer, what's the biggest mic drop you've experienced when arguing with a colleague?","Many years ago, I was part of a team which delivered a development environment for other engineers. That environment included not only software, but also some communication devices which were interfacing with the device they developed. The other team couldn’t work without that environment, and it was critical that everything would work perfectly.

Right after the weekend, on the first day of the week, one of the engineers of the other team set an emergency meeting around noon. I couldn’t understand from the meeting subject what they wanted, but they asked everyone to attend because we had a crisis. So, I went to the meeting with my manager.

The meeting started very bad. They accused us for wasting their time, because our environment in the lab didn’t work, and their engineer wasted several hours trying to understand what’s the problem. He tried EVERYTHING, including reading our manual, but the communication just didn’t work. They were enraged, and basically described us as incompetent. There were some big-shot managers in the meeting, and my manager started to turn pale. After 20 minutes of venting, which I kept silence all that time not saying a word, they were done saying everything they had to say.

My manager looked at me. I looked at my manager and then looked back slowly at everyone in the room, and with a strict poker face I said softly: “Please come with me”. I got up and started walking out of the meeting room to the lab. Everybody were baffled a bit, probably thinking I lost it, but they followed me.

In the lab, there was a switch. I turned on the switch, and everything started working. Just above the switch there was sign, which I hung when we delivered the environment: “Please turn off before the weekend to shut down the lab, and DO NOT FORGET TO TURN IT ON MONDAY”. I pointed at the sign, looked at everybody, said “That’s on the first page of the manual”, and walked out the lab.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/05syr1eu4nxdgwzf', 'title': ""As a programmer, software engineer, or developer, what's the biggest mic drop you've experienced when arguing with a colleague?"", 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Many years ago, I was part of a team which delivered a development environment for other engineers. That environment included not only software, but also some communication devices which were interfacing with the device they developed. The other team couldn’t work without that environment, and it was critical that everything would work perfectly.\n\nRight after the weekend, on the first day of the week, one of the engineers of the other team set an emergency meeting around noon. I couldn’t understand from the meeting subject what they wanted, but they asked everyone to attend because we had a crisis. So, I went to the meeting with my manager.\n\nThe meeting started very bad. They accused us for wasting their time, because our environment in the lab didn’t work, and their engineer wasted several hours trying to understand what’s the problem. He tried EVERYTHING, including reading our manual, but the communication just didn’t work. They were enraged, and basically described us as incompetent. There were some big-shot managers in the meeting, and my manager started to turn pale. After 20 minutes of venting, which I kept silence all that time not saying a word, they were done saying everything they had to say.\n\nMy manager looked at me. I looked at my manager and then looked back slowly at everyone in the room, and with a strict poker face I said softly: “Please come with me”. I got up and started walking out of the meeting room to the lab. Everybody were baffled a bit, probably thinking I lost it, but they followed me.\n\nIn the lab, there was a switch. I turned on the switch, and everything started working. Just above the switch there was sign, which I hung when we delivered the environment: “Please turn off before the weekend to shut down the lab, and DO NOT FORGET TO TURN IT ON MONDAY”. I pointed at the sign, looked at everybody, said “That’s on the first page of the manual”, and walked out the lab.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984163, 'subscription': 0, 'content': 'Many years ago, I was part of a team which delivered a development environment for other engineers. That environment included not only software, but also some communication devices which were interfacing with the device they developed. The other team couldn’t work without that environment, and it was critical that everything would work perfectly.\n\nRight after the weekend, on the first day of the week, one of the engineers of the other team set an emergency meeting around noon. I couldn’t understand from the meeting subject what they wanted, but they asked everyone to attend because we had a crisis. So, I went to the meeting with my manager.\n\nThe meeting started very bad. They accused us for wasting their time, because our environment in the lab didn’t work, and their engineer wasted several hours trying to understand what’s the problem. He tried EVERYTHING, including reading our manual, but the communication just didn’t work. They were enraged, and basically described us as incompetent. There were some big-shot managers in the meeting, and my manager started to turn pale. After 20 minutes of venting, which I kept silence all that time not saying a word, they were done saying everything they had to say.\n\nMy manager looked at me. I looked at my manager and then looked back slowly at everyone in the room, and with a strict poker face I said softly: “Please come with me”. I got up and started walking out of the meeting room to the lab. Everybody were baffled a bit, probably thinking I lost it, but they followed me.\n\nIn the lab, there was a switch. I turned on the switch, and everything started working. Just above the switch there was sign, which I hung when we delivered the environment: “Please turn off before the weekend to shut down the lab, and DO NOT FORGET TO TURN IT ON MONDAY”. I pointed at the sign, looked at everybody, said “That’s on the first page of the manual”, and walked out the lab.', 'aiModelVersion': '1'}",0.9998
Joe Seabreeze,Updated 8mo,"As a coder, what annoys you most?","Buzz words that manipulate senior management.
Example: “we need to build our own blockchain because our competitors are doing it”. How about they try to understand what it is first?
Senior management with no forward thinking. They’d rather rush something through and deal with a crisis than be proactive from the start. But a crisis is just a crisis; some programmer will work overtime to bail them out.
The lack of knowledge on what it takes to build and deploy software. Some senior management still thinks software development is magic and that there’s no difference between building a ToDo app and a social media network. Ugh.
Agile Development.
Where do I start? This paradigm must have manifested from people who have never seen good product management. Do a search on “Agile Manifesto” and have a good laugh.
Open workspace/office plan.
Are you kidding me? Someone actually thought that you’d get more work done if you could easily get distracted and talk to people all day? LMAO
Horrible equipment.
You just hired a senior level developer and you’re giving him/her a 4 year old Lenovo laptop running Windows with old user profiles on it? Here’s a hint: give them what they want to get their job done or let them use their own equipment.
Tech giants who pretty much control most of the industry not coming together and supporting developers.
We have to jump through hoops just to get our apps on the different platforms. Forced to use weird hybrid solutions that have their own challenges. Or duplicating code, porting, testing on a gazillion different systems. Different doc formats, different file systems, different languages, different sdks, apis, libraries, libraries, libraries! It makes me tired. We typically have to resort to cross-platform solutions like browsers/JavaScript to do things that it wasn’t even meant to do. Ugh. Thank you Microsoft, thank you Google, thank you Apple, thank you Amazon. You all suck.
Senior management who think that more heads will always make a project move faster. Haven’t they read the Mythical Man-Month? It has been out since 1975:
x = n(n − 1) / 2
n = number of developers
x = channels of communication
Companies that don’t encourage people to work from home. Some of us spend over an hour in traffic to move a laptop from one desk to another just to do the same work. DOH! I can understand people who need an office because they get distracted at home, but it should be an option for everyone. Not only does it add a bit more productivity, but it’s good for the environment as well! Less cars on the road, no need for huge offices burning lights all day, etc. I mean, do you really need to look at someone’s face to get your code done?

Damn, I could keep this list going, but…. I have a crisis to deal with. :)","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/ogsdb7einu3w8rf2', 'title': 'As a coder, what annoys you most?', 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'Buzz words that manipulate senior management.\nExample: “we need to build our own blockchain because our competitors are doing it”. How about they try to understand what it is first?\nSenior management with no forward thinking. They’d rather rush something through and deal with a crisis than be proactive from the start. But a crisis is just a crisis; some programmer will work overtime to bail them out.\nThe lack of knowledge on what it takes to build and deploy software. Some senior management still thinks software development is magic and that there’s no difference between building a ToDo app and a social media network. Ugh.\nAgile Development.\nWhere do I start? This paradigm must have manifested from people who have never seen good product management. Do a search on “Agile Manifesto” and have a good laugh.\nOpen workspace/office plan.\nAre you kidding me? Someone actually thought that you’d get more work done if you could easily get distracted and talk to people all day? LMAO\nHorrible equipment.\nYou just hired a senior level developer and you’re giving him/her a 4 year old Lenovo laptop running Windows with old user profiles on it? Here’s a hint: give them what they want to get their job done or let them use their own equipment.\nTech giants who pretty much control most of the industry not coming together and supporting developers.\nWe have to jump through hoops just to get our apps on the different platforms. Forced to use weird hybrid solutions that have their own challenges. Or duplicating code, porting, testing on a gazillion different systems. Different doc formats, different file systems, different languages, different sdks, apis, libraries, libraries, libraries! It makes me tired. We typically have to resort to cross-platform solutions like browsers/JavaScript to do things that it wasn’t even meant to do. Ugh. Thank you Microsoft, thank you Google, thank you Apple, thank you Amazon. You all suck.\nSenior management who think that more heads will always make a project move faster. Haven’t they read the Mythical Man-Month? It has been out since 1975:\nx = n(n − 1) / 2\nn = number of developers\nx = channels of communication\nCompanies that don’t encourage people to work from home. Some of us spend over an hour in traffic to move a laptop from one desk to another just to do the same work. DOH! I can understand people who need an office because they get distracted at home, but it should be an option for everyone. Not only does it add a bit more productivity, but it’s good for the environment as well! Less cars on the road, no need for huge offices burning lights all day, etc. I mean, do you really need to look at someone’s face to get your code done?\n\nDamn, I could keep this list going, but…. I have a crisis to deal with. :)', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984158, 'subscription': 0, 'content': 'Buzz words that manipulate senior management.\nExample: “we need to build our own blockchain because our competitors are doing it”. How about they try to understand what it is first?\nSenior management with no forward thinking. They’d rather rush something through and deal with a crisis than be proactive from the start. But a crisis is just a crisis; some programmer will work overtime to bail them out.\nThe lack of knowledge on what it takes to build and deploy software. Some senior management still thinks software development is magic and that there’s no difference between building a ToDo app and a social media network. Ugh.\nAgile Development.\nWhere do I start? This paradigm must have manifested from people who have never seen good product management. Do a search on “Agile Manifesto” and have a good laugh.\nOpen workspace/office plan.\nAre you kidding me? Someone actually thought that you’d get more work done if you could easily get distracted and talk to people all day? LMAO\nHorrible equipment.\nYou just hired a senior level developer and you’re giving him/her a 4 year old Lenovo laptop running Windows with old user profiles on it? Here’s a hint: give them what they want to get their job done or let them use their own equipment.\nTech giants who pretty much control most of the industry not coming together and supporting developers.\nWe have to jump through hoops just to get our apps on the different platforms. Forced to use weird hybrid solutions that have their own challenges. Or duplicating code, porting, testing on a gazillion different systems. Different doc formats, different file systems, different languages, different sdks, apis, libraries, libraries, libraries! It makes me tired. We typically have to resort to cross-platform solutions like browsers/JavaScript to do things that it wasn’t even meant to do. Ugh. Thank you Microsoft, thank you Google, thank you Apple, thank you Amazon. You all suck.\nSenior management who think that more heads will always make a project move faster. Haven’t they read the Mythical Man-Month? It has been out since 1975:\nx = n(n − 1) / 2\nn = number of developers\nx = channels of communication\nCompanies that don’t encourage people to work from home. Some of us spend over an hour in traffic to move a laptop from one desk to another just to do the same work. DOH! I can understand people who need an office because they get distracted at home, but it should be an option for everyone. Not only does it add a bit more productivity, but it’s good for the environment as well! Less cars on the road, no need for huge offices burning lights all day, etc. I mean, do you really need to look at someone’s face to get your code done?\n\nDamn, I could keep this list going, but…. I have a crisis to deal with. :)', 'aiModelVersion': '1'}",0.9997
Andy Baker,5y,What are some best technologies to learn for software developers besides programming?,"Become comfortable at the command line. Bash is sufficient as you can use it on the 3 major platforms (Linux etc, Mac OS and Windows thanks to the gift of Windows Subsystem for Linux). If you’re going to be predominantly working in a Microsoft world then learn Powershell as well.
Learn a modern VCS. Probably Git (because sadly Mercurial lost that battle)
Understand HTTP at a low-ish level. Request/Response and HTTP headers will touch nearly all aspects of development even if you’re not strictly a web developer.
Learn to understand the concepts of relational databases and maybe even a smattering of SQL. Even if you drink the No SQL kool-aid you will need to know why they’ve decided to sacrifice one of the cornerstones of classic database theory and what the trade-offs were.
Become vaguely proficient in Gimp or Photoshop if you ever need to process images. And I struggle to think how you’ll sidestep this one in most areas of software development.
Understand data transfer formats to some degree. JSON, XML, CSV and maybe YAML or similar will cross your path at some point. Be aware of when to select one over the others.
Learn to be lazy. Good programmers are lazy. Bad programmers reinvent things that already exist and forget the actual task at hand. Sometimes you just need to do something quick and dirty and if that means a crappy online service or hacking something together in Excel then so be it.
Which reminds me - a good spreadsheet will solve many problems better than a quick script. Or even better - a spreadsheet combines with a quick script will solve nearly all problems. It’s like duct tape and cable ties but for software.
Regular expressions. But know when to stop…","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/9g8x4b3shdlroy1f', 'title': 'What are some best technologies to learn for software developers besides programming?', 'score': {'original': 0.9999, 'ai': 0.0001}, 'blocks': [{'text': 'Become comfortable at the command line. Bash is sufficient as you can use it on the 3 major platforms (Linux etc, Mac OS and Windows thanks to the gift of Windows Subsystem for Linux). If you’re going to be predominantly working in a Microsoft world then learn Powershell as well.\nLearn a modern VCS. Probably Git (because sadly Mercurial lost that battle)\nUnderstand HTTP at a low-ish level. Request/Response and HTTP headers will touch nearly all aspects of development even if you’re not strictly a web developer.\nLearn to understand the concepts of relational databases and maybe even a smattering of SQL. Even if you drink the No SQL kool-aid you will need to know why they’ve decided to sacrifice one of the cornerstones of classic database theory and what the trade-offs were.\nBecome vaguely proficient in Gimp or Photoshop if you ever need to process images. And I struggle to think how you’ll sidestep this one in most areas of software development.\nUnderstand data transfer formats to some degree. JSON, XML, CSV and maybe YAML or similar will cross your path at some point. Be aware of when to select one over the others.\nLearn to be lazy. Good programmers are lazy. Bad programmers reinvent things that already exist and forget the actual task at hand. Sometimes you just need to do something quick and dirty and if that means a crappy online service or hacking something together in Excel then so be it.\nWhich reminds me - a good spreadsheet will solve many problems better than a quick script. Or even better - a spreadsheet combines with a quick script will solve nearly all problems. It’s like duct tape and cable ties but for software.\nRegular expressions. But know when to stop…', 'result': {'fake': 0.0001, 'real': 0.9999}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984155, 'subscription': 0, 'content': 'Become comfortable at the command line. Bash is sufficient as you can use it on the 3 major platforms (Linux etc, Mac OS and Windows thanks to the gift of Windows Subsystem for Linux). If you’re going to be predominantly working in a Microsoft world then learn Powershell as well.\nLearn a modern VCS. Probably Git (because sadly Mercurial lost that battle)\nUnderstand HTTP at a low-ish level. Request/Response and HTTP headers will touch nearly all aspects of development even if you’re not strictly a web developer.\nLearn to understand the concepts of relational databases and maybe even a smattering of SQL. Even if you drink the No SQL kool-aid you will need to know why they’ve decided to sacrifice one of the cornerstones of classic database theory and what the trade-offs were.\nBecome vaguely proficient in Gimp or Photoshop if you ever need to process images. And I struggle to think how you’ll sidestep this one in most areas of software development.\nUnderstand data transfer formats to some degree. JSON, XML, CSV and maybe YAML or similar will cross your path at some point. Be aware of when to select one over the others.\nLearn to be lazy. Good programmers are lazy. Bad programmers reinvent things that already exist and forget the actual task at hand. Sometimes you just need to do something quick and dirty and if that means a crappy online service or hacking something together in Excel then so be it.\nWhich reminds me - a good spreadsheet will solve many problems better than a quick script. Or even better - a spreadsheet combines with a quick script will solve nearly all problems. It’s like duct tape and cable ties but for software.\nRegular expressions. But know when to stop…', 'aiModelVersion': '1'}",0.9999
Michael B.,4y,"Movies usually portray programmers as these insane coders who memorize everything. Do professional programmers actually know code (when making a bot, application, etc) or do research to put the pieces together?","Bit of both.

First of all what you see in the movies usually isn’t programming. It’s hacking (or cracking if you want to be technical). Hacking is when someone gets unauthorized access to a system. It’s nothing like depicted in Hollywood. It takes much longer, and most of the time it involves hacking the people, not the system.

But programming is also very different than what you’re imaging. For one thing there’s a lot less typing. Some people can just sit down and write code for 8 hours straight. Most people can’t. Most people need to think about the problem, ask questions, draw a diagram…

For another, computer science doesn’t require much memorization. If you use a language and set of libraries for a year, obviously you’re going to start remembering what each function does. But the IDE, the program that makes it easier to program remembers a lot of this stuff for you. And of course in real life programmers spend a lot of time on Google, Stack Overflow, or even just reading the documentation.

And then there’s the fact that you’re not always familiar with the pieces you’re using. A good chunk of the code of any program is going to be libraries. Preexisting code that does something. You might be familiar with the standard libraries used in your language, but if you want the program to do something specialized that can often involve having to learn a new library.

On the other side of the spectrum are design patterns. Set ways of solving a problem that can be used in any language. These are one of the few things that programmers will actually memorize.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/hmn0dciey2asorx9', 'title': 'Movies usually portray programmers as these insane coders who memorize everything. Do professional programmers actually know code (when making a bot, application, etc) or do research to put the pieces together?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'Bit of both.\n\nFirst of all what you see in the movies usually isn’t programming. It’s hacking (or cracking if you want to be technical). Hacking is when someone gets unauthorized access to a system. It’s nothing like depicted in Hollywood. It takes much longer, and most of the time it involves hacking the people, not the system.\n\nBut programming is also very different than what you’re imaging. For one thing there’s a lot less typing. Some people can just sit down and write code for 8 hours straight. Most people can’t. Most people need to think about the problem, ask questions, draw a diagram…\n\nFor another, computer science doesn’t require much memorization. If you use a language and set of libraries for a year, obviously you’re going to start remembering what each function does. But the IDE, the program that makes it easier to program remembers a lot of this stuff for you. And of course in real life programmers spend a lot of time on Google, Stack Overflow, or even just reading the documentation.\n\nAnd then there’s the fact that you’re not always familiar with the pieces you’re using. A good chunk of the code of any program is going to be libraries. Preexisting code that does something. You might be familiar with the standard libraries used in your language, but if you want the program to do something specialized that can often involve having to learn a new library.\n\nOn the other side of the spectrum are design patterns. Set ways of solving a problem that can be used in any language. These are one of the few things that programmers will actually memorize.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984152, 'subscription': 0, 'content': 'Bit of both.\n\nFirst of all what you see in the movies usually isn’t programming. It’s hacking (or cracking if you want to be technical). Hacking is when someone gets unauthorized access to a system. It’s nothing like depicted in Hollywood. It takes much longer, and most of the time it involves hacking the people, not the system.\n\nBut programming is also very different than what you’re imaging. For one thing there’s a lot less typing. Some people can just sit down and write code for 8 hours straight. Most people can’t. Most people need to think about the problem, ask questions, draw a diagram…\n\nFor another, computer science doesn’t require much memorization. If you use a language and set of libraries for a year, obviously you’re going to start remembering what each function does. But the IDE, the program that makes it easier to program remembers a lot of this stuff for you. And of course in real life programmers spend a lot of time on Google, Stack Overflow, or even just reading the documentation.\n\nAnd then there’s the fact that you’re not always familiar with the pieces you’re using. A good chunk of the code of any program is going to be libraries. Preexisting code that does something. You might be familiar with the standard libraries used in your language, but if you want the program to do something specialized that can often involve having to learn a new library.\n\nOn the other side of the spectrum are design patterns. Set ways of solving a problem that can be used in any language. These are one of the few things that programmers will actually memorize.', 'aiModelVersion': '1'}",0.9998
Kurt Guntheroth,Updated 3y,"When should I claim in an interview that I know C++? It seems every time you make such claim, they won't stop asking questions until they prove to you that you haven't memorized the standard cover to cover. Who could decide if they know C++?","If you don’t know any other object oriented languages, it takes about two full-time years to obtain a journeyman’s level of competence in C++. People used to picking up the basics of simple imperative languages like C, sh, or perl in a few weeks are always surprised by the length of time it takes to learn C++. They may claim mastery when all they have is a nodding acquaintance. It also happens that certain arrogant or eager candidates claim to know C++ when they really don’t, and are just winging it in the interview off their C or Java experience, figuring if you don’t notice they can learn on the job.

This happens so often at interviews that interviewers are all routinely suspicious of the claim. Given what I just said about taking two full-time years of experience, you can imagine that a fresh college grad would be questioned very carefully if they made the claim of knowing C++ if they sat across an interview table from me.

Nobody knows all of C++. After 25+ years, I don’t. Besides, there is a brand-new standard every three years. Compilers don’t even know all of C++20 yet. Nobody expects a candidate to know all of C++, but they do want to know how much of C++ you know. There is a kind of common understanding of what you know after 5 years of full-time C++ development, or 10 years. But it’s hard to guess what a junior dev with just a year or two actually understands.

If you were going to buy a $100,000 car, I’m pretty sure you would ask a lot of questions and make a careful decision. You need to understand that the interviewer is deciding whether to buy a $100,000 per year developer, and is going to try to make the same kind of careful decision.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/2wov4manxq3z8lh9', 'title': ""When should I claim in an interview that I know C++? It seems every time you make such claim, they won't stop asking questions until they prove to you that you haven't memorized the standard cover to cover. Who could decide if they know C++?"", 'score': {'original': 0.9997, 'ai': 0.0003}, 'blocks': [{'text': 'If you don’t know any other object oriented languages, it takes about two full-time years to obtain a journeyman’s level of competence in C++. People used to picking up the basics of simple imperative languages like C, sh, or perl in a few weeks are always surprised by the length of time it takes to learn C++. They may claim mastery when all they have is a nodding acquaintance. It also happens that certain arrogant or eager candidates claim to know C++ when they really don’t, and are just winging it in the interview off their C or Java experience, figuring if you don’t notice they can learn on the job.\n\nThis happens so often at interviews that interviewers are all routinely suspicious of the claim. Given what I just said about taking two full-time years of experience, you can imagine that a fresh college grad would be questioned very carefully if they made the claim of knowing C++ if they sat across an interview table from me.\n\nNobody knows all of C++. After 25+ years, I don’t. Besides, there is a brand-new standard every three years. Compilers don’t even know all of C++20 yet. Nobody expects a candidate to know all of C++, but they do want to know how much of C++ you know. There is a kind of common understanding of what you know after 5 years of full-time C++ development, or 10 years. But it’s hard to guess what a junior dev with just a year or two actually understands.\n\nIf you were going to buy a $100,000 car, I’m pretty sure you would ask a lot of questions and make a careful decision. You need to understand that the interviewer is deciding whether to buy a $100,000 per year developer, and is going to try to make the same kind of careful decision.', 'result': {'fake': 0.0003, 'real': 0.9997}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984148, 'subscription': 0, 'content': 'If you don’t know any other object oriented languages, it takes about two full-time years to obtain a journeyman’s level of competence in C++. People used to picking up the basics of simple imperative languages like C, sh, or perl in a few weeks are always surprised by the length of time it takes to learn C++. They may claim mastery when all they have is a nodding acquaintance. It also happens that certain arrogant or eager candidates claim to know C++ when they really don’t, and are just winging it in the interview off their C or Java experience, figuring if you don’t notice they can learn on the job.\n\nThis happens so often at interviews that interviewers are all routinely suspicious of the claim. Given what I just said about taking two full-time years of experience, you can imagine that a fresh college grad would be questioned very carefully if they made the claim of knowing C++ if they sat across an interview table from me.\n\nNobody knows all of C++. After 25+ years, I don’t. Besides, there is a brand-new standard every three years. Compilers don’t even know all of C++20 yet. Nobody expects a candidate to know all of C++, but they do want to know how much of C++ you know. There is a kind of common understanding of what you know after 5 years of full-time C++ development, or 10 years. But it’s hard to guess what a junior dev with just a year or two actually understands.\n\nIf you were going to buy a $100,000 car, I’m pretty sure you would ask a lot of questions and make a careful decision. You need to understand that the interviewer is deciding whether to buy a $100,000 per year developer, and is going to try to make the same kind of careful decision.', 'aiModelVersion': '1'}",0.9997
Mark Phaedrus,4y,How does software that runs traffic lights avoid fatal errors while consumer programs crash the time?,"Here are some reasons why traffic light software is quite stable:

It’s a largely static field. The vast majority of intersections call for the same, simple requirements and situations. Most governments don’t want traffic control software that does some sort of amazing new thing, in the way that consumers of more typical types of software often do. New features of traffic control software are much rarer.
A given piece of traffic control software runs on a very small, very predictable, very carefully-tested number of hardware configurations. That immediately gets rid of the huge number of difficult-to-diagnose-and-debug problems that can occur when you combine some set of the literally billions of combinations of PC components that can make up, say, a consumer Windows PC.
With almost no exceptions, traffic control software is the only thing that’s running on hardware used for traffic control. That immediately gets rid of a huge majority of the difficult-to-diagnose-and-debug “This only happens when Program A is doing X and Y while Program B is simultaneously doing Z” problems that occur on consumer PCs.
As a result of those factors, the job of testing traffic control software is at least two or three orders of magnitude easier than the job of testing a complex piece of consumer software. The reduced number of possible hardware and software configurations means that you can test each combination in much greater detail than would be possible — let alone cost-effective — for consumer PCs.

And despite all this, traffic control software does sometimes crash or malfunction. So why don’t we hear about horrible crashes caused by malfunctioning software turning the lights green in all directions? Because of one more crucial factor:

Fancy traffic control software and hardware is almost never hooked directly up to the lights. Everything typically goes through a “watchdog”, a much more conservatively-designed and rarely-modified piece of hardware. The watchdog hardware is designed to enforce a few very basic, very well understood rules like:
“At a typical intersection where two roads intersect, at least one road’s traffic signals must be red at any given moment. Both roads must never be shown a yellow or green signal at the same time.”
“A pedestrian signal cannot be in a WALK or flashing DON’T WALK state if the vehicular signal for the road being crossed is not red.”
“Each direction of traffic must receive a green signal at least once every three minutes.”
If the main traffic control system ever does something that violates one of these constraints — if it tries to display a conflicting set of signals, or if it hangs and leaves the signals in the same state for too long — then the watchdog takes over, disconnects the main traffic control system from the lights, and sets everything to flashing red/flashing DON’T WALK instead. Typically it stays this way until a traffic engineer checks and resets the equipment.

So traffic light software simply doesn’t operate in anything remotely the same way as consumer software. That means that it’s generally not particularly useful to compare them.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/b4l65zavu0ecs1gp', 'title': 'How does software that runs traffic lights avoid fatal errors while consumer programs crash the time?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'Here are some reasons why traffic light software is quite stable:\n\nIt’s a largely static field. The vast majority of intersections call for the same, simple requirements and situations. Most governments don’t want traffic control software that does some sort of amazing new thing, in the way that consumers of more typical types of software often do. New features of traffic control software are much rarer.\nA given piece of traffic control software runs on a very small, very predictable, very carefully-tested number of hardware configurations. That immediately gets rid of the huge number of difficult-to-diagnose-and-debug problems that can occur when you combine some set of the literally billions of combinations of PC components that can make up, say, a consumer Windows PC.\nWith almost no exceptions, traffic control software is the only thing that’s running on hardware used for traffic control. That immediately gets rid of a huge majority of the difficult-to-diagnose-and-debug “This only happens when Program A is doing X and Y while Program B is simultaneously doing Z” problems that occur on consumer PCs.\nAs a result of those factors, the job of testing traffic control software is at least two or three orders of magnitude easier than the job of testing a complex piece of consumer software. The reduced number of possible hardware and software configurations means that you can test each combination in much greater detail than would be possible — let alone cost-effective — for consumer PCs.\n\nAnd despite all this, traffic control software does sometimes crash or malfunction. So why don’t we hear about horrible crashes caused by malfunctioning software turning the lights green in all directions? Because of one more crucial factor:\n\nFancy traffic control software and hardware is almost never hooked directly up to the lights. Everything typically goes through a “watchdog”, a much more conservatively-designed and rarely-modified piece of hardware. The watchdog hardware is designed to enforce a few very basic, very well understood rules like:\n“At a typical intersection where two roads intersect, at least one road’s traffic signals must be red at any given moment. Both roads must never be shown a yellow or green signal at the same time.”\n“A pedestrian signal cannot be in a WALK or flashing DON’T WALK state if the vehicular signal for the road being crossed is not red.”\n“Each direction of traffic must receive a green signal at least once every three minutes.”\nIf the main traffic control system ever does something that violates one of these constraints — if it tries to display a conflicting set of signals, or if it hangs and leaves the signals in the same state for too long — then the watchdog takes over, disconnects the main traffic control system from the lights, and sets everything to flashing red/flashing DON’T WALK instead. Typically it stays this way until a traffic engineer checks and resets the equipment.\n\nSo traffic light software simply doesn’t operate in anything remotely the same way as consumer software. That means that it’s generally not particularly useful to compare them.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984142, 'subscription': 0, 'content': 'Here are some reasons why traffic light software is quite stable:\n\nIt’s a largely static field. The vast majority of intersections call for the same, simple requirements and situations. Most governments don’t want traffic control software that does some sort of amazing new thing, in the way that consumers of more typical types of software often do. New features of traffic control software are much rarer.\nA given piece of traffic control software runs on a very small, very predictable, very carefully-tested number of hardware configurations. That immediately gets rid of the huge number of difficult-to-diagnose-and-debug problems that can occur when you combine some set of the literally billions of combinations of PC components that can make up, say, a consumer Windows PC.\nWith almost no exceptions, traffic control software is the only thing that’s running on hardware used for traffic control. That immediately gets rid of a huge majority of the difficult-to-diagnose-and-debug “This only happens when Program A is doing X and Y while Program B is simultaneously doing Z” problems that occur on consumer PCs.\nAs a result of those factors, the job of testing traffic control software is at least two or three orders of magnitude easier than the job of testing a complex piece of consumer software. The reduced number of possible hardware and software configurations means that you can test each combination in much greater detail than would be possible — let alone cost-effective — for consumer PCs.\n\nAnd despite all this, traffic control software does sometimes crash or malfunction. So why don’t we hear about horrible crashes caused by malfunctioning software turning the lights green in all directions? Because of one more crucial factor:\n\nFancy traffic control software and hardware is almost never hooked directly up to the lights. Everything typically goes through a “watchdog”, a much more conservatively-designed and rarely-modified piece of hardware. The watchdog hardware is designed to enforce a few very basic, very well understood rules like:\n“At a typical intersection where two roads intersect, at least one road’s traffic signals must be red at any given moment. Both roads must never be shown a yellow or green signal at the same time.”\n“A pedestrian signal cannot be in a WALK or flashing DON’T WALK state if the vehicular signal for the road being crossed is not red.”\n“Each direction of traffic must receive a green signal at least once every three minutes.”\nIf the main traffic control system ever does something that violates one of these constraints — if it tries to display a conflicting set of signals, or if it hangs and leaves the signals in the same state for too long — then the watchdog takes over, disconnects the main traffic control system from the lights, and sets everything to flashing red/flashing DON’T WALK instead. Typically it stays this way until a traffic engineer checks and resets the equipment.\n\nSo traffic light software simply doesn’t operate in anything remotely the same way as consumer software. That means that it’s generally not particularly useful to compare them.', 'aiModelVersion': '1'}",0.9996
Joshua Gross,Updated 1y,How difficult is it to find highly talented software developers?,"What do you mean? I can find ’em quite easily.

It’s hiring and keeping them that’s hard.

It used to be true that it was just a question of pay. I don’t even think that’s meaningful anymore. Oh, don’t get me wrong, I think money can be an incentive, but there’s this weird edge effect that if you start really paying premium, people are going to think that something’s going on.

Let’s say that an experienced dev (2–3 years?) with a bachelor’s degree at a competitive company located in a high COL area is making $250,000 (the numbers don’t matter). You offer them $280,000, and they think about it, but with vesting schedules and other factors, that’s often not enough to entice them. They’re not going to take home enough more to change their lifestyle. OK, so you offer them $350,000. Now the money makes sense, but why the hell are you offering them that much money? You must have trouble hiring and keeping folks. They’re going to run to Blind and ask. And someone on Blind will just utterly dump on you, because every company has disgruntled employees. And that’s it, that’s all, you’ll get a polite decline. Or perhaps they’ll take it to leverage something elsewhere, but they won’t stay.

Most devs want interesting work. They want a healthy work culture that’s compatible with their own value system. They want money, but they’re at a specific point in compensation when the amounts out there just aren’t going to change their lifestyles enough to make moving easier. They’ll job hop as they see fit, but big checks don’t cut it. Not anymore.

I’ll add that I’m in the US and I’ve been out of industry for many years, although I’ve thought about going back.

There is a solution, by the way. Hiring properly. Hiring experienced, seasoned devs? That’s the easy way out. Hire recent college grads, even community college grads, and not the ones who pass every interview with flying colors. Hire the ones with potential. It’s there. It’s harder to see than someone who can jump through the hoops, but they exist. Hire ‘em, train ‘em, mentor ‘em, promote ‘em, compensate ‘em, and treat them well. You’ll be surprised at how easy people are to keep when they’re treated properly, and how quickly you lose them when you think that you’re only a source of money.

ETA. Another thing to think about: we’ve recently seen mass layoffs. Some of these are genuinely struggling companies, but some are the old-fashioned, idiotic, “let’s raise the stock price” layoffs. Remember that devs talk to each othr on Blind, and realize that you are poisoning the well. Developers do not want to be out there looking for new cheese just because you felt like undermining their livelihood; they want to be at a stable employer. They want their work to be evaluated fairly and be the basis for continued employment. Lay off tech workers at your own risk; it’s a great way to destroy your ability to hire. If I’m making the kind of money most tech workers make, I’d gladly take a 25% pay cut to work for an employer that has a great reputation of treating people well, and that includes stability.

At one point, IBM was a global technology giant. They’re now an also-ran, currently ranked 42 in the Fortune 500, despite having been a top-ten stalwart for decades. The fall began when they started laying people off.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/5kjpas6bzi8whx4v', 'title': 'How difficult is it to find highly talented software developers?', 'score': {'original': 0.33195, 'ai': 0.66805}, 'blocks': [{'text': 'What do you mean? I can find ’em quite easily.\n\nIt’s hiring and keeping them that’s hard.\n\nIt used to be true that it was just a question of pay. I don’t even think that’s meaningful anymore. Oh, don’t get me wrong, I think money can be an incentive, but there’s this weird edge effect that if you start really paying premium, people are going to think that something’s going on.\n\nLet’s say that an experienced dev (2–3 years?) with a bachelor’s degree at a competitive company located in a high COL area is making $250,000 (the numbers don’t matter). You offer them $280,000, and they think about it, but with vesting schedules and other factors, that’s often not enough to entice them. They’re not going to take home enough more to change their lifestyle. OK, so you offer them $350,000. Now the money makes sense, but why the hell are you offering them that much money? You must have trouble hiring and keeping folks. They’re going to run to Blind and ask. And someone on Blind will just utterly dump on you, because every company has disgruntled employees. And that’s it, that’s all, you’ll get a polite decline. Or perhaps they’ll take it to leverage something elsewhere, but they won’t stay.\n\nMost devs want interesting work. They want a healthy work culture that’s compatible with their own value system. They want money, but they’re at a specific point in compensation when the amounts out there just aren’t going to change their lifestyles enough to make moving easier. They’ll job hop as they see fit, but big checks don’t cut it. Not anymore.\n\nI’ll add that I’m in the US and I’ve been out of industry for many years, although I’ve thought about going back.\n\nThere is a solution, by the way. Hiring properly. Hiring experienced, seasoned devs? That’s the easy way out. Hire recent college grads, even community college grads, and not the ones who pass every interview with flying colors. Hire the ones with potential. It’s there. It’s harder to see than someone who can jump through the hoops, but they exist. Hire ‘em, train ‘em, mentor ‘em, promote ‘em, compensate ‘em, and treat them well. You’ll be surprised at how easy people are to keep when they’re treated properly, and how quickly you lose them when you think that you’re only a source of money.\n\nETA. Another thing to think about: we’ve recently seen mass layoffs. Some of these are genuinely struggling companies, but some are the old-fashioned, idiotic, “let’s raise the stock price” layoffs. Remember that devs talk to each othr on Blind, and realize that you are poisoning the well. Developers do not want to be out there looking for new cheese just because you felt like undermining their livelihood; they want to be at a stable employer. They want their work to be evaluated fairly and be the basis for continued employment. Lay off tech workers at your own risk; it’s a great way to destroy your ability to hire. If I’m making the kind of money most tech workers make, I’d gladly', 'result': {'fake': 0.4085, 'real': 0.5915}, 'status': 'success'}, {'text': 'take a 25% pay cut to work for an employer that has a great reputation of treating people well, and that includes stability.\n\nAt one point, IBM was a global technology giant. They’re now an also-ran, currently ranked 42 in the Fortune 500, despite having been a top-ten stalwart for decades. The fall began when they started laying people off.', 'result': {'fake': 0.9985, 'real': 0.0015}, 'status': 'success'}], 'credits_used': 7, 'credits': 1984135, 'subscription': 0, 'content': 'What do you mean? I can find ’em quite easily.\n\nIt’s hiring and keeping them that’s hard.\n\nIt used to be true that it was just a question of pay. I don’t even think that’s meaningful anymore. Oh, don’t get me wrong, I think money can be an incentive, but there’s this weird edge effect that if you start really paying premium, people are going to think that something’s going on.\n\nLet’s say that an experienced dev (2–3 years?) with a bachelor’s degree at a competitive company located in a high COL area is making $250,000 (the numbers don’t matter). You offer them $280,000, and they think about it, but with vesting schedules and other factors, that’s often not enough to entice them. They’re not going to take home enough more to change their lifestyle. OK, so you offer them $350,000. Now the money makes sense, but why the hell are you offering them that much money? You must have trouble hiring and keeping folks. They’re going to run to Blind and ask. And someone on Blind will just utterly dump on you, because every company has disgruntled employees. And that’s it, that’s all, you’ll get a polite decline. Or perhaps they’ll take it to leverage something elsewhere, but they won’t stay.\n\nMost devs want interesting work. They want a healthy work culture that’s compatible with their own value system. They want money, but they’re at a specific point in compensation when the amounts out there just aren’t going to change their lifestyles enough to make moving easier. They’ll job hop as they see fit, but big checks don’t cut it. Not anymore.\n\nI’ll add that I’m in the US and I’ve been out of industry for many years, although I’ve thought about going back.\n\nThere is a solution, by the way. Hiring properly. Hiring experienced, seasoned devs? That’s the easy way out. Hire recent college grads, even community college grads, and not the ones who pass every interview with flying colors. Hire the ones with potential. It’s there. It’s harder to see than someone who can jump through the hoops, but they exist. Hire ‘em, train ‘em, mentor ‘em, promote ‘em, compensate ‘em, and treat them well. You’ll be surprised at how easy people are to keep when they’re treated properly, and how quickly you lose them when you think that you’re only a source of money.\n\nETA. Another thing to think about: we’ve recently seen mass layoffs. Some of these are genuinely struggling companies, but some are the old-fashioned, idiotic, “let’s raise the stock price” layoffs. Remember that devs talk to each othr on Blind, and realize that you are poisoning the well. Developers do not want to be out there looking for new cheese just because you felt like undermining their livelihood; they want to be at a stable employer. They want their work to be evaluated fairly and be the basis for continued employment. Lay off tech workers at your own risk; it’s a great way to destroy your ability to hire. If I’m making the kind of money most tech workers make, I’d gladly take a 25% pay cut to work for an employer that has a great reputation of treating people well, and that includes stability.\n\nAt one point, IBM was a global technology giant. They’re now an also-ran, currently ranked 42 in the Fortune 500, despite having been a top-ten stalwart for decades. The fall began when they started laying people off.', 'aiModelVersion': '1'}",0.33195
Chris Nash,Updated 2y,What is something that programmers should know but isn’t taught extensively enough in school?,"First

I find it incredible that many graduates don’t have the first idea of how to actually write a program. For us in college, we programmed. A lot.

I may have programmed more than my peers, simply because I loved it so much. Some of my programs took weeks. Some a few hours. But I loved doing it, so I did it a lot.

Many years later I worked with a woman who had a Masters degree in Computer Science. I only have a Bachelors. She had absolutely no idea how to program whatsoever. She couldn’t understand a simple if statement. I was amazed and couldn’t understand how she earned that degree.

She worked at the help desk. She hated it. About 20 of us worked in software engineering. All of us had bachelors degrees. We made more than 2x what she did with a Masters degree.

So first and foremost, make sure you, the student, know how to program from the ground up. Make sure you can fire up an IDE and write a program from scratch. Do it often. Do it for fun. Do it for serious things.

Second

Source control. When I graduated from college, source control wasn’t really a thing. It was used some places on some things, but it certainly wasn’t popular or the norm.

Now it is, and most college graduates have never been introduced to it. That’s a shame. It should be one of the first things they learn to use. Like an IDE and StackOverflow, it’s an indispensable tool for today’s software engineer.

Given that today’s most popular SCM tool, Git, is free, not teaching it is inexcusable.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/wp8raixz1t7u2vno', 'title': 'What is something that programmers should know but isn’t taught extensively enough in school?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'First\n\nI find it incredible that many graduates don’t have the first idea of how to actually write a program. For us in college, we programmed. A lot.\n\nI may have programmed more than my peers, simply because I loved it so much. Some of my programs took weeks. Some a few hours. But I loved doing it, so I did it a lot.\n\nMany years later I worked with a woman who had a Masters degree in Computer Science. I only have a Bachelors. She had absolutely no idea how to program whatsoever. She couldn’t understand a simple if statement. I was amazed and couldn’t understand how she earned that degree.\n\nShe worked at the help desk. She hated it. About 20 of us worked in software engineering. All of us had bachelors degrees. We made more than 2x what she did with a Masters degree.\n\nSo first and foremost, make sure you, the student, know how to program from the ground up. Make sure you can fire up an IDE and write a program from scratch. Do it often. Do it for fun. Do it for serious things.\n\nSecond\n\nSource control. When I graduated from college, source control wasn’t really a thing. It was used some places on some things, but it certainly wasn’t popular or the norm.\n\nNow it is, and most college graduates have never been introduced to it. That’s a shame. It should be one of the first things they learn to use. Like an IDE and StackOverflow, it’s an indispensable tool for today’s software engineer.\n\nGiven that today’s most popular SCM tool, Git, is free, not teaching it is inexcusable.', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984132, 'subscription': 0, 'content': 'First\n\nI find it incredible that many graduates don’t have the first idea of how to actually write a program. For us in college, we programmed. A lot.\n\nI may have programmed more than my peers, simply because I loved it so much. Some of my programs took weeks. Some a few hours. But I loved doing it, so I did it a lot.\n\nMany years later I worked with a woman who had a Masters degree in Computer Science. I only have a Bachelors. She had absolutely no idea how to program whatsoever. She couldn’t understand a simple if statement. I was amazed and couldn’t understand how she earned that degree.\n\nShe worked at the help desk. She hated it. About 20 of us worked in software engineering. All of us had bachelors degrees. We made more than 2x what she did with a Masters degree.\n\nSo first and foremost, make sure you, the student, know how to program from the ground up. Make sure you can fire up an IDE and write a program from scratch. Do it often. Do it for fun. Do it for serious things.\n\nSecond\n\nSource control. When I graduated from college, source control wasn’t really a thing. It was used some places on some things, but it certainly wasn’t popular or the norm.\n\nNow it is, and most college graduates have never been introduced to it. That’s a shame. It should be one of the first things they learn to use. Like an IDE and StackOverflow, it’s an indispensable tool for today’s software engineer.\n\nGiven that today’s most popular SCM tool, Git, is free, not teaching it is inexcusable.', 'aiModelVersion': '1'}",0.9998
Alan Kay,3y,How do I lay out my software architecture before I code if the requirements change every day?,"Here’s an exemplary process from the past that is a good start on how to think about the present, and even more importantly about the future.

A change in federal laws in the mid-80s rendered much of public utility Brooklyn Union Gas’s database and reporting obsolete. This included more than 1 million customers at that time.

The CEO said “This must never happen again”. The CIO (as was often the case back then) didn’t know much about computing, but had great trust in his head systems designer and programmer Tom Morgan (who did know a lot, and also had a degree in pure math).

Morgan was friends with John Davis of Andersen Consulting, who with his group had been experimenting deeply for several years with object-oriented design (Smalltalk on workstations) — and this because of the farsighted view of Mel Berstein, Andersen Consulting’s head of Technical Services (I was consulting for Mel at this time, so I got to see what transpired first hand).

Morgan and Davis decided to go all out. First, to solve the regulatory problem, but then to include a recasting of most of BUG’s information processing. The requirements were fluid. The target had to be the two IBM 3090 mainframes that were in-house and could not be replaced with anything more suitable.

The larger story can be found in Harvard Business School case studies and in several IEEE papers. Here I’ll just look at the part that helps with the Quora question.

Designing and developing on the IBM mainframe would be a terrible route (the languages available were COBOL, PL/1, and assembly).

So they decided they would first quickly build the entire system as a working prototype in Smalltalk to make sure they had the requirements and possible architectures running and vettable (non-debuggable “requirements” are not *requirements*). In a large room, they set up all the workstations, and used a version of the Smalltalk system tracer to graphically render the system and print it out on large tiled charts that could be put on the walls to show a large picture of the entire system.

Every night (late!) the system would print out its organization (using an enhanced kind of E-R structure), and the tiled printouts were pasted up on all the walls of the room. In the early morning, the team would “do rounds” (as in a hospital) to see how “the patient” was doing. Questions that needed more detailed answers could be immediately answered by using the live Smalltalk on the workstations.

They would take notes, then have different kinds of meetings to decide what needed to be changed, what needed to be added, etc. The extreme late-binding and “eternal lifetime” of Smalltalk allowed changes to take place in about 1/2 second (you don’t ever have to do a systems rebuild, etc.), and they would spend the day fixing and debugging. This allowed a very neat and sophisticated design to be rapidly evolved, programmed, debugged and vetted.

Meanwhile, the underlying semantics of Smalltalk were programmed for the 3090s (in PL/1 !) and debugged. This was relatively easy because Smalltalk had a working model of its own semantics (called the “interpreter simulator” that served as a runnable model). The compromises taken here were interesting, worked well, and are out of the scope of this answer.

And there was work to make DB/2 be the backing store for the new object-base (I will admit to helping with the design of the intermediate object-cache, which was modeled on the Smalltalk-76 OOZE virtual memory swapping system at PARC of 10+ years earlier).

The architecture that was finally arrived at was essentially a real-time simulation of the company itself (and they could run the simulation ahead in time for forecasting, in the manner of a super-spreadsheet but with graphics).

Why real-time? Because they decided to add radio tracking of their 1500 service vehicles to coordinate needs, especially gas leaks (“from the smell of gas to a fix in less than 15 minutes” was the motto they decided on). The control room for this system showed large screens for Brooklyn, the locations of the fix-it trucks, and many other kinds of info (it was like a NASA or NORAD command center).

The whole process from start to finish took about 18 months, winding up with 6 people to maintain the system, after about 130 were involved in the project at its peak.

The key idea here is that CAD<->SIM done well will allow FAB to be merely a lot of work (but close to the minimum, straightforward, and without a lot of additional bugs).

We could imagine a future system much better than Smalltalk at doing the CAD<->SIM part (for example, qualitatively better semantics for capturing and running requirements would be good, and much more comprehensive real-time displays and visualizations of the whole system on the fly, etc.). We could imagine a more automated route for taking the semantics from CAD<->SIM to FAB. And so forth.

But I think, more than 30 years later, the BUG/AAC system design and process to create it stands up very well compared to anything I’ve seen more recently in large companies.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/epflqkc72uhonyrs', 'title': 'How do I lay out my software architecture before I code if the requirements change every day?', 'score': {'original': 0.97125, 'ai': 0.02875}, 'blocks': [{'text': 'Here’s an exemplary process from the past that is a good start on how to think about the present, and even more importantly about the future.\n\nA change in federal laws in the mid-80s rendered much of public utility Brooklyn Union Gas’s database and reporting obsolete. This included more than 1 million customers at that time.\n\nThe CEO said “This must never happen again”. The CIO (as was often the case back then) didn’t know much about computing, but had great trust in his head systems designer and programmer Tom Morgan (who did know a lot, and also had a degree in pure math).\n\nMorgan was friends with John Davis of Andersen Consulting, who with his group had been experimenting deeply for several years with object-oriented design (Smalltalk on workstations) — and this because of the farsighted view of Mel Berstein, Andersen Consulting’s head of Technical Services (I was consulting for Mel at this time, so I got to see what transpired first hand).\n\nMorgan and Davis decided to go all out. First, to solve the regulatory problem, but then to include a recasting of most of BUG’s information processing. The requirements were fluid. The target had to be the two IBM 3090 mainframes that were in-house and could not be replaced with anything more suitable.\n\nThe larger story can be found in Harvard Business School case studies and in several IEEE papers. Here I’ll just look at the part that helps with the Quora question.\n\nDesigning and developing on the IBM mainframe would be a terrible route (the languages available were COBOL, PL/1, and assembly).\n\nSo they decided they would first quickly build the entire system as a working prototype in Smalltalk to make sure they had the requirements and possible architectures running and vettable (non-debuggable “requirements” are not *requirements*). In a large room, they set up all the workstations, and used a version of the Smalltalk system tracer to graphically render the system and print it out on large tiled charts that could be put on the walls to show a large picture of the entire system.\n\nEvery night (late!) the system would print out its organization (using an enhanced kind of E-R structure), and the tiled printouts were pasted up on all the walls of the room. In the early morning, the team would “do rounds” (as in a hospital) to see how “the patient” was doing. Questions that needed more detailed answers could be immediately answered by using the live Smalltalk on the workstations.\n\nThey would take notes, then have different kinds of meetings to decide what needed to be changed, what needed to be added, etc. The extreme late-binding and “eternal lifetime” of Smalltalk allowed changes to take place in about 1/2 second (you don’t ever have to do a systems rebuild, etc.), and they would spend the day fixing and debugging. This allowed a very neat and sophisticated design to be rapidly evolved, programmed, debugged and vetted.\n\nMeanwhile, the underlying semantics of Smalltalk were programmed for the 3090s (in PL/1 !) and debugged. This was relatively easy because Smalltalk had a working model of its own', 'result': {'fake': 0.0235, 'real': 0.9765}, 'status': 'success'}, {'text': 'semantics (called the “interpreter simulator” that served as a runnable model). The compromises taken here were interesting, worked well, and are out of the scope of this answer.\n\nAnd there was work to make DB/2 be the backing store for the new object-base (I will admit to helping with the design of the intermediate object-cache, which was modeled on the Smalltalk-76 OOZE virtual memory swapping system at PARC of 10+ years earlier).\n\nThe architecture that was finally arrived at was essentially a real-time simulation of the company itself (and they could run the simulation ahead in time for forecasting, in the manner of a super-spreadsheet but with graphics).\n\nWhy real-time? Because they decided to add radio tracking of their 1500 service vehicles to coordinate needs, especially gas leaks (“from the smell of gas to a fix in less than 15 minutes” was the motto they decided on). The control room for this system showed large screens for Brooklyn, the locations of the fix-it trucks, and many other kinds of info (it was like a NASA or NORAD command center).\n\nThe whole process from start to finish took about 18 months, winding up with 6 people to maintain the system, after about 130 were involved in the project at its peak.\n\nThe key idea here is that CAD<->SIM done well will allow FAB to be merely a lot of work (but close to the minimum, straightforward, and without a lot of additional bugs).\n\nWe could imagine a future system much better than Smalltalk at doing the CAD<->SIM part (for example, qualitatively better semantics for capturing and running requirements would be good, and much more comprehensive real-time displays and visualizations of the whole system on the fly, etc.). We could imagine a more automated route for taking the semantics from CAD<->SIM to FAB. And so forth.\n\nBut I think, more than 30 years later, the BUG/AAC system design and process to create it stands up very well compared to anything I’ve seen more recently in large companies.', 'result': {'fake': 0.1773, 'real': 0.8227}, 'status': 'success'}], 'credits_used': 9, 'credits': 1984123, 'subscription': 0, 'content': 'Here’s an exemplary process from the past that is a good start on how to think about the present, and even more importantly about the future.\n\nA change in federal laws in the mid-80s rendered much of public utility Brooklyn Union Gas’s database and reporting obsolete. This included more than 1 million customers at that time.\n\nThe CEO said “This must never happen again”. The CIO (as was often the case back then) didn’t know much about computing, but had great trust in his head systems designer and programmer Tom Morgan (who did know a lot, and also had a degree in pure math).\n\nMorgan was friends with John Davis of Andersen Consulting, who with his group had been experimenting deeply for several years with object-oriented design (Smalltalk on workstations) — and this because of the farsighted view of Mel Berstein, Andersen Consulting’s head of Technical Services (I was consulting for Mel at this time, so I got to see what transpired first hand).\n\nMorgan and Davis decided to go all out. First, to solve the regulatory problem, but then to include a recasting of most of BUG’s information processing. The requirements were fluid. The target had to be the two IBM 3090 mainframes that were in-house and could not be replaced with anything more suitable.\n\nThe larger story can be found in Harvard Business School case studies and in several IEEE papers. Here I’ll just look at the part that helps with the Quora question.\n\nDesigning and developing on the IBM mainframe would be a terrible route (the languages available were COBOL, PL/1, and assembly).\n\nSo they decided they would first quickly build the entire system as a working prototype in Smalltalk to make sure they had the requirements and possible architectures running and vettable (non-debuggable “requirements” are not *requirements*). In a large room, they set up all the workstations, and used a version of the Smalltalk system tracer to graphically render the system and print it out on large tiled charts that could be put on the walls to show a large picture of the entire system.\n\nEvery night (late!) the system would print out its organization (using an enhanced kind of E-R structure), and the tiled printouts were pasted up on all the walls of the room. In the early morning, the team would “do rounds” (as in a hospital) to see how “the patient” was doing. Questions that needed more detailed answers could be immediately answered by using the live Smalltalk on the workstations.\n\nThey would take notes, then have different kinds of meetings to decide what needed to be changed, what needed to be added, etc. The extreme late-binding and “eternal lifetime” of Smalltalk allowed changes to take place in about 1/2 second (you don’t ever have to do a systems rebuild, etc.), and they would spend the day fixing and debugging. This allowed a very neat and sophisticated design to be rapidly evolved, programmed, debugged and vetted.\n\nMeanwhile, the underlying semantics of Smalltalk were programmed for the 3090s (in PL/1 !) and debugged. This was relatively easy because Smalltalk had a working model of its own semantics (called the “interpreter simulator” that served as a runnable model). The compromises taken here were interesting, worked well, and are out of the scope of this answer.\n\nAnd there was work to make DB/2 be the backing store for the new object-base (I will admit to helping with the design of the intermediate object-cache, which was modeled on the Smalltalk-76 OOZE virtual memory swapping system at PARC of 10+ years earlier).\n\nThe architecture that was finally arrived at was essentially a real-time simulation of the company itself (and they could run the simulation ahead in time for forecasting, in the manner of a super-spreadsheet but with graphics).\n\nWhy real-time? Because they decided to add radio tracking of their 1500 service vehicles to coordinate needs, especially gas leaks (“from the smell of gas to a fix in less than 15 minutes” was the motto they decided on). The control room for this system showed large screens for Brooklyn, the locations of the fix-it trucks, and many other kinds of info (it was like a NASA or NORAD command center).\n\nThe whole process from start to finish took about 18 months, winding up with 6 people to maintain the system, after about 130 were involved in the project at its peak.\n\nThe key idea here is that CAD<->SIM done well will allow FAB to be merely a lot of work (but close to the minimum, straightforward, and without a lot of additional bugs).\n\nWe could imagine a future system much better than Smalltalk at doing the CAD<->SIM part (for example, qualitatively better semantics for capturing and running requirements would be good, and much more comprehensive real-time displays and visualizations of the whole system on the fly, etc.). We could imagine a more automated route for taking the semantics from CAD<->SIM to FAB. And so forth.\n\nBut I think, more than 30 years later, the BUG/AAC system design and process to create it stands up very well compared to anything I’ve seen more recently in large companies.', 'aiModelVersion': '1'}",0.97125
Jake Morrison,6y,What is your favorite software bug/fault horror story?,"Years ago we were building an embedded vehicle tracker for commercial vehicles. The hardware used an ARM7 CPU, GPS and GPRS modem, running uClinux.

We ran into a tough bug in the initial application startup process. The program that read from the GPS and sent location updates to the network was failing. When it did the console stopped working, so we could not see what was going on. Writing to a log file gave the same results.

This is unfortunately common for embedded systems. For normal programmers, if your machine won't boot up, you are having a bad day. For embedded developers, that's just a normal Tuesday, and your only debugging option may be staring at the code and thinking hard.

This board had no Ethernet and only two serial ports, one for the console and one hard wired for the GPS. The ROM was almost full (it had a whopping 2 MB of flash, 1 MB for the Linux kernel, 750 KB for apps and 250 KB for storage). The lack of MMU meant no shared libraries, so every binary was statically linked and huge. We couldn't install much else to help us.

A colleague came up with the idea of running gdb (the text mode debugger) over the cellular network. It took multiple tries due to packet loss and high latency, but suddenly we got a stack backtrace. It turned out `printf()` was failing when it tried to print the latitude and longitude from the GPS, a floating point number.

One rule for normal programming is that if you think there is a compiler bug, you are wrong; it's a bug in your code. In this case, a few hours of debugging and scouring five-year-old mailing list posts turned up a patch to gcc (never applied), which fixed a bug on the ARM7 which affected uclibc.

This made me think of how the folks who make the space probes debug their problems. If you can't be an astronaut, at least you can be a programmer, right? :-)","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/s3zm2ackpxgfjwiy', 'title': 'What is your favorite software bug/fault horror story?', 'score': {'original': 0.9821, 'ai': 0.0179}, 'blocks': [{'text': ""Years ago we were building an embedded vehicle tracker for commercial vehicles. The hardware used an ARM7 CPU, GPS and GPRS modem, running uClinux.\n\nWe ran into a tough bug in the initial application startup process. The program that read from the GPS and sent location updates to the network was failing. When it did the console stopped working, so we could not see what was going on. Writing to a log file gave the same results.\n\nThis is unfortunately common for embedded systems. For normal programmers, if your machine won't boot up, you are having a bad day. For embedded developers, that's just a normal Tuesday, and your only debugging option may be staring at the code and thinking hard.\n\nThis board had no Ethernet and only two serial ports, one for the console and one hard wired for the GPS. The ROM was almost full (it had a whopping 2 MB of flash, 1 MB for the Linux kernel, 750 KB for apps and 250 KB for storage). The lack of MMU meant no shared libraries, so every binary was statically linked and huge. We couldn't install much else to help us.\n\nA colleague came up with the idea of running gdb (the text mode debugger) over the cellular network. It took multiple tries due to packet loss and high latency, but suddenly we got a stack backtrace. It turned out `printf()` was failing when it tried to print the latitude and longitude from the GPS, a floating point number.\n\nOne rule for normal programming is that if you think there is a compiler bug, you are wrong; it's a bug in your code. In this case, a few hours of debugging and scouring five-year-old mailing list posts turned up a patch to gcc (never applied), which fixed a bug on the ARM7 which affected uclibc.\n\nThis made me think of how the folks who make the space probes debug their problems. If you can't be an astronaut, at least you can be a programmer, right? :-)"", 'result': {'fake': 0.0179, 'real': 0.9821}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984119, 'subscription': 0, 'content': ""Years ago we were building an embedded vehicle tracker for commercial vehicles. The hardware used an ARM7 CPU, GPS and GPRS modem, running uClinux.\n\nWe ran into a tough bug in the initial application startup process. The program that read from the GPS and sent location updates to the network was failing. When it did the console stopped working, so we could not see what was going on. Writing to a log file gave the same results.\n\nThis is unfortunately common for embedded systems. For normal programmers, if your machine won't boot up, you are having a bad day. For embedded developers, that's just a normal Tuesday, and your only debugging option may be staring at the code and thinking hard.\n\nThis board had no Ethernet and only two serial ports, one for the console and one hard wired for the GPS. The ROM was almost full (it had a whopping 2 MB of flash, 1 MB for the Linux kernel, 750 KB for apps and 250 KB for storage). The lack of MMU meant no shared libraries, so every binary was statically linked and huge. We couldn't install much else to help us.\n\nA colleague came up with the idea of running gdb (the text mode debugger) over the cellular network. It took multiple tries due to packet loss and high latency, but suddenly we got a stack backtrace. It turned out `printf()` was failing when it tried to print the latitude and longitude from the GPS, a floating point number.\n\nOne rule for normal programming is that if you think there is a compiler bug, you are wrong; it's a bug in your code. In this case, a few hours of debugging and scouring five-year-old mailing list posts turned up a patch to gcc (never applied), which fixed a bug on the ARM7 which affected uclibc.\n\nThis made me think of how the folks who make the space probes debug their problems. If you can't be an astronaut, at least you can be a programmer, right? :-)"", 'aiModelVersion': '1'}",0.9821
Ishan Mishra,Jan 19,Is the 94.1 LPA salary in Bangalore too low for a 32-year-old software engineer?,"If you cant make 1cr in Bangalore as a software engineer then it means you come into the lowest bracket. Even a pani puri wala is making more than 1cr nowadays. the other day, our maid bought a new Toyota Vellfire and took us out for dinner at Leela where we met a 24 old software engineer making 1.31 cr working as a waiter to make ends meet.

So my advice is that you should study hard , learn new things and stop BS on quora.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/1gndry2olqzkfxj5', 'title': 'Is the 94.1 LPA salary in Bangalore too low for a 32-year-old software engineer?', 'score': {'original': 0.9925, 'ai': 0.0075}, 'blocks': [{'text': 'If you cant make 1cr in Bangalore as a software engineer then it means you come into the lowest bracket. Even a pani puri wala is making more than 1cr nowadays. the other day, our maid bought a new Toyota Vellfire and took us out for dinner at Leela where we met a 24 old software engineer making 1.31 cr working as a waiter to make ends meet.\n\nSo my advice is that you should study hard , learn new things and stop BS on quora.', 'result': {'fake': 0.0075, 'real': 0.9925}, 'status': 'success'}], 'credits_used': 1, 'credits': 1984118, 'subscription': 0, 'content': 'If you cant make 1cr in Bangalore as a software engineer then it means you come into the lowest bracket. Even a pani puri wala is making more than 1cr nowadays. the other day, our maid bought a new Toyota Vellfire and took us out for dinner at Leela where we met a 24 old software engineer making 1.31 cr working as a waiter to make ends meet.\n\nSo my advice is that you should study hard , learn new things and stop BS on quora.', 'aiModelVersion': '1'}",0.9925
Alan Kay,3y,I read somewhere that object-oriented programming was coined by Alan Kay circa 1966 or 1967 while he was at grad school. Has anyone influenced/contributed Alan to coin such a term?,"Since the question has been asked, it’s worth reading the detailed history I was asked to write by the ACM in 1992, that became one of the sections of the 2nd History Of Programming Languages conference. The Early History Of Smalltalk

In brief for here, I saw parts of the idea in various forms starting in the early 60s, and thought it useful, but stayed asleep until in 1966 I saw Ivan Sutherland’s Sketchpad system (which completely changed the ways I looked at computing), and within a week saw and learned the first Simula, which was less grand than Sketchpad, but showed how ordinary programming could be changed to take advantage of instantiations of processes.

This double whammy combination “rotated” me to see things from very different perspectives.

A key part of the “rotation” was that

(1) at that time multi-processing and time-sharing systems were using hardware modified to isolate separate processes in the form of “virtual versions of the hardware”

(2) ARPA was in the process of talking about doing the ARPAnet, that would allow many computers to intercommunicate

(3) my two main concentrations in college had been pure math and molecular biology

The form of the “rotation” was ridiculously simple. It was the simple realization that a computer could compute what any computer could compute, and thus you could represent anything computable at any scale using only intercommunicating computers (most would be virtual) as building blocks.

This was completely impractical (which I think was one of the reasons I didn’t think of it earlier). The molecular biology and the ARPAnet really helped, because it was known in the mid-60s roughly that each cell in our body contained billions of informationally interacting components, and we had 10 to 100 trillion cells in each of us. That kind of scaling actually worked, and was far beyond what computing could do.

I think that seeing Sketchpad shocked me into being able to use “pure math mode” as part of the thinking rather than just the “worry about efficiency” thinking I was used to doing when computing. If you allowed “infinitely fast and large” computing, then the idea made excellent sense: it was a universal building block for all scales, and what remained were the central problems of designing complex systems.

The nature of the intercommunications would allow schemes that were like algebras in pure math to be devised so that terms — like “+” or “sort” or “display” could have both general and specific meanings.

The huge potential got me to look at the “impractical” part, which looked much more doable than I’d thought (it still took about 5+ years and a great research group to do). LISP had already solved a number of the problems, and this proved to be a great set of ideas for context.

In the 1960s, software composites that were more complex than arrays, were often called “objects”, and all the schemes I had seen involved structures that included attached procedures. A month or so after the “rotation” someone asked me what I was doing, and I foolishly said “object-oriented programming”.

The foolish part is that “object” is a very bad word for what I had in mind — it is too inert and feels too much like “data”. Simula called its instances “processes” and that is better.

“Process-oriented programming” would have been much better, don’t you think?

In any case, I did not at all have “Abstract Data Types” in mind as a worthwhile goal, even though they were obvious — and this is because “Data” as an idea does not scale at all well.

You are much better off hiding how state is handled inside a “process”, only having processes, and treating processes as “servers” for each other.

That is what I had in mind back then.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/kic56xyh1qtrlw4b', 'title': 'I read somewhere that object-oriented programming was coined by Alan Kay circa 1966 or 1967 while he was at grad school. Has anyone influenced/contributed Alan to coin such a term?', 'score': {'original': 0.2058, 'ai': 0.7942}, 'blocks': [{'text': 'Since the question has been asked, it’s worth reading the detailed history I was asked to write by the ACM in 1992, that became one of the sections of the 2nd History Of Programming Languages conference. The Early History Of Smalltalk\n\nIn brief for here, I saw parts of the idea in various forms starting in the early 60s, and thought it useful, but stayed asleep until in 1966 I saw Ivan Sutherland’s Sketchpad system (which completely changed the ways I looked at computing), and within a week saw and learned the first Simula, which was less grand than Sketchpad, but showed how ordinary programming could be changed to take advantage of instantiations of processes.\n\nThis double whammy combination “rotated” me to see things from very different perspectives.\n\nA key part of the “rotation” was that\n\n(1) at that time multi-processing and time-sharing systems were using hardware modified to isolate separate processes in the form of “virtual versions of the hardware”\n\n(2) ARPA was in the process of talking about doing the ARPAnet, that would allow many computers to intercommunicate\n\n(3) my two main concentrations in college had been pure math and molecular biology\n\nThe form of the “rotation” was ridiculously simple. It was the simple realization that a computer could compute what any computer could compute, and thus you could represent anything computable at any scale using only intercommunicating computers (most would be virtual) as building blocks.\n\nThis was completely impractical (which I think was one of the reasons I didn’t think of it earlier). The molecular biology and the ARPAnet really helped, because it was known in the mid-60s roughly that each cell in our body contained billions of informationally interacting components, and we had 10 to 100 trillion cells in each of us. That kind of scaling actually worked, and was far beyond what computing could do.\n\nI think that seeing Sketchpad shocked me into being able to use “pure math mode” as part of the thinking rather than just the “worry about efficiency” thinking I was used to doing when computing. If you allowed “infinitely fast and large” computing, then the idea made excellent sense: it was a universal building block for all scales, and what remained were the central problems of designing complex systems.\n\nThe nature of the intercommunications would allow schemes that were like algebras in pure math to be devised so that terms — like “+” or “sort” or “display” could have both general and specific meanings.\n\nThe huge potential got me to look at the “impractical” part, which looked much more doable than I’d thought (it still took about 5+ years and a great research group to do). LISP had already solved a number of the problems, and this proved to be a great set of ideas for context.\n\nIn the 1960s, software composites that were more complex than arrays, were often called “objects”, and all the schemes I had seen involved structures that included attached procedures. A month or so after the “rotation” someone asked me what I was doing, and I foolishly said “object-oriented programming”.\n\nThe foolish part is that “object” is a very bad', 'result': {'fake': 0.5188, 'real': 0.4812}, 'status': 'success'}, {'text': 'word for what I had in mind — it is too inert and feels too much like “data”. Simula called its instances “processes” and that is better.\n\n“Process-oriented programming” would have been much better, don’t you think?\n\nIn any case, I did not at all have “Abstract Data Types” in mind as a worthwhile goal, even though they were obvious — and this is because “Data” as an idea does not scale at all well.\n\nYou are much better off hiding how state is handled inside a “process”, only having processes, and treating processes as “servers” for each other.\n\nThat is what I had in mind back then.', 'result': {'fake': 0.9991, 'real': 0.0009}, 'status': 'success'}], 'credits_used': 7, 'credits': 1984111, 'subscription': 0, 'content': 'Since the question has been asked, it’s worth reading the detailed history I was asked to write by the ACM in 1992, that became one of the sections of the 2nd History Of Programming Languages conference. The Early History Of Smalltalk\n\nIn brief for here, I saw parts of the idea in various forms starting in the early 60s, and thought it useful, but stayed asleep until in 1966 I saw Ivan Sutherland’s Sketchpad system (which completely changed the ways I looked at computing), and within a week saw and learned the first Simula, which was less grand than Sketchpad, but showed how ordinary programming could be changed to take advantage of instantiations of processes.\n\nThis double whammy combination “rotated” me to see things from very different perspectives.\n\nA key part of the “rotation” was that\n\n(1) at that time multi-processing and time-sharing systems were using hardware modified to isolate separate processes in the form of “virtual versions of the hardware”\n\n(2) ARPA was in the process of talking about doing the ARPAnet, that would allow many computers to intercommunicate\n\n(3) my two main concentrations in college had been pure math and molecular biology\n\nThe form of the “rotation” was ridiculously simple. It was the simple realization that a computer could compute what any computer could compute, and thus you could represent anything computable at any scale using only intercommunicating computers (most would be virtual) as building blocks.\n\nThis was completely impractical (which I think was one of the reasons I didn’t think of it earlier). The molecular biology and the ARPAnet really helped, because it was known in the mid-60s roughly that each cell in our body contained billions of informationally interacting components, and we had 10 to 100 trillion cells in each of us. That kind of scaling actually worked, and was far beyond what computing could do.\n\nI think that seeing Sketchpad shocked me into being able to use “pure math mode” as part of the thinking rather than just the “worry about efficiency” thinking I was used to doing when computing. If you allowed “infinitely fast and large” computing, then the idea made excellent sense: it was a universal building block for all scales, and what remained were the central problems of designing complex systems.\n\nThe nature of the intercommunications would allow schemes that were like algebras in pure math to be devised so that terms — like “+” or “sort” or “display” could have both general and specific meanings.\n\nThe huge potential got me to look at the “impractical” part, which looked much more doable than I’d thought (it still took about 5+ years and a great research group to do). LISP had already solved a number of the problems, and this proved to be a great set of ideas for context.\n\nIn the 1960s, software composites that were more complex than arrays, were often called “objects”, and all the schemes I had seen involved structures that included attached procedures. A month or so after the “rotation” someone asked me what I was doing, and I foolishly said “object-oriented programming”.\n\nThe foolish part is that “object” is a very bad word for what I had in mind — it is too inert and feels too much like “data”. Simula called its instances “processes” and that is better.\n\n“Process-oriented programming” would have been much better, don’t you think?\n\nIn any case, I did not at all have “Abstract Data Types” in mind as a worthwhile goal, even though they were obvious — and this is because “Data” as an idea does not scale at all well.\n\nYou are much better off hiding how state is handled inside a “process”, only having processes, and treating processes as “servers” for each other.\n\nThat is what I had in mind back then.', 'aiModelVersion': '1'}",0.2058
Scott Hannen,Updated 10mo,What problems are you tired of dealing with as a senior software engineer?,"These are all from past jobs:

They tell you the code isn’t perfect (that’s okay - it never is) and you’ll have the chance to improve it. But then it’s worse than you could have imagined, and they don’t want you to do anything different. “This is just how we do it.” Well, obviously, and that’s why the code is the way it is.

This goes hand-in-hand with complex processes that can only be manually tested. This is common when every action requires back-and-forth communication between several microservices, but it can also happen within a single application. You find yourself trying to configure multiple applications to run on your computer so you can test, but getting them to work is more complicated than whatever problem you were actually trying to solve.

Once this happens, the complexity horse has left the barn. You’re not going to get it back. Even then there are strategies for slowly making sense of it, but you’re not expected to operate at that level. They just want you to get into the mud and roll around with their filthy code while your skills go to waste and your dream of doing meaningful work to solve business problems dies.

I’ve only learned one answer to these problems: Be somewhere else. Yes, your company’s code and business are important. I don’t deny that. But the problem you’ve created isn’t the sort I want to solve. I’m tired of it. Don’t make a mess and then look for skilled developers to keep it alive. That’s living hell for skilled developers and they won’t do it. Somewhere out there someone is building a new application and has the chance to do it right. Or they’ve already done that and they need someone to continue developing it. That’s where I’ll be.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/gozx53psi71a60mt', 'title': 'What problems are you tired of dealing with as a senior software engineer?', 'score': {'original': 0.9989, 'ai': 0.0011}, 'blocks': [{'text': 'These are all from past jobs:\n\nThey tell you the code isn’t perfect (that’s okay - it never is) and you’ll have the chance to improve it. But then it’s worse than you could have imagined, and they don’t want you to do anything different. “This is just how we do it.” Well, obviously, and that’s why the code is the way it is.\n\nThis goes hand-in-hand with complex processes that can only be manually tested. This is common when every action requires back-and-forth communication between several microservices, but it can also happen within a single application. You find yourself trying to configure multiple applications to run on your computer so you can test, but getting them to work is more complicated than whatever problem you were actually trying to solve.\n\nOnce this happens, the complexity horse has left the barn. You’re not going to get it back. Even then there are strategies for slowly making sense of it, but you’re not expected to operate at that level. They just want you to get into the mud and roll around with their filthy code while your skills go to waste and your dream of doing meaningful work to solve business problems dies.\n\nI’ve only learned one answer to these problems: Be somewhere else. Yes, your company’s code and business are important. I don’t deny that. But the problem you’ve created isn’t the sort I want to solve. I’m tired of it. Don’t make a mess and then look for skilled developers to keep it alive. That’s living hell for skilled developers and they won’t do it. Somewhere out there someone is building a new application and has the chance to do it right. Or they’ve already done that and they need someone to continue developing it. That’s where I’ll be.', 'result': {'fake': 0.0011, 'real': 0.9989}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984107, 'subscription': 0, 'content': 'These are all from past jobs:\n\nThey tell you the code isn’t perfect (that’s okay - it never is) and you’ll have the chance to improve it. But then it’s worse than you could have imagined, and they don’t want you to do anything different. “This is just how we do it.” Well, obviously, and that’s why the code is the way it is.\n\nThis goes hand-in-hand with complex processes that can only be manually tested. This is common when every action requires back-and-forth communication between several microservices, but it can also happen within a single application. You find yourself trying to configure multiple applications to run on your computer so you can test, but getting them to work is more complicated than whatever problem you were actually trying to solve.\n\nOnce this happens, the complexity horse has left the barn. You’re not going to get it back. Even then there are strategies for slowly making sense of it, but you’re not expected to operate at that level. They just want you to get into the mud and roll around with their filthy code while your skills go to waste and your dream of doing meaningful work to solve business problems dies.\n\nI’ve only learned one answer to these problems: Be somewhere else. Yes, your company’s code and business are important. I don’t deny that. But the problem you’ve created isn’t the sort I want to solve. I’m tired of it. Don’t make a mess and then look for skilled developers to keep it alive. That’s living hell for skilled developers and they won’t do it. Somewhere out there someone is building a new application and has the chance to do it right. Or they’ve already done that and they need someone to continue developing it. That’s where I’ll be.', 'aiModelVersion': '1'}",0.9989
Li Pi,Updated 12y,How does garbage collection work in the JVM?,"This actually varies depending on the JVM implementation, but I'm assuming you're talking about Oracle (Sun) Version 6. Java itself does not specify a particular method of garbage collection.

The JVM uses a form of garbage collector called a tracing collector, which essentially operates by first stopping the world, marking all root objects, or objects that are referenced directly by running threads, and following references, marking each object it hits along the way.

Java 6 implements something called a generational garbage collector—based upon the generational hypothesis assumption, which states that the majority of objects that are created are quickly discarded, and that objects that are not quickly collected are likely to be around for some time.

Based upon these assumptions, Java therefore partitions objects into two different generations, and then operates differently upon them.

Visually, the generations look like this:



(Not quite to scale)

Young Generation: This is where objects start out. It has two subgenerations:


Eden - Objects start out here.
Survivor - Objects that survive Eden end up here. There are two of these, and only one is in use at any given time. One is designated as empty, and the other as live. This switched every GC cycle.


Tenured Generation: Older objects with longer lifetimes end up here.

Java is smart enough to apply different garbage collection methods to each generation. The young generation is handled using a tracing, copying collector called the Parallel New Collector. This collector stops the world, but because the young generation is generally small, the pause is short.

For the young generation:

When Eden fills up, the garbage collector stops the world, then traces through the objects in the young generation, starting with those referenced immediately by a running thread.

Those that are marked or ""alive"" are copied over to the empty survivor space. This survivor space is then marked as ""live"", and Eden, along with the other survivor space, is marked as empty. This has the side effect of compacting all the objects into a single survivor space, allowing for rather efficient memory usage. If an object has been copied between the two survivor places a certain amount of times, its designated as tenured, and moved to the tenured section.

Eden will now be overwritten by new objects, and the next garbage collection cycle will proceed to use the other survivor space.

This usage of a copying collector for the young generation is fast because the vast majority of objects are very quickly destroyed, and generally, very few objects must be moved around.

For the tenured generation:

I'm going to steal this section from this blog post by Todd Lipcon, http://www.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/

Tenured Generation – Concurrent Mark-Sweep

Every time the parallel new collector runs, it will tenure some objects into the tenured generation. So, of course, the old generation will eventually fill up, and we need a strategy for collecting it as well. The Concurrent-Mark-Sweep collector (CMS) is responsible for clearing dead objects in this generation.

The CMS collector operates in a series of phases. Some phases stop the world, and others run concurrently with the Java application. The major phases are:

initial-mark (stops the world). In this phase, the CMS collector places a mark on the rootobjects. A root object is something directly referenced from a live Thread – for example, the local variables in use by that thread. This phase is short because the number of roots is very small.
concurrent-mark (concurrent). The collector now follows every pointer starting from the root objects until it has marked all live objects in the system.
remark (stops the world). Since objects might have had references changed, and new objects might have been created during concurrent-mark, we need to go back and take those into account in this phase. This is short because a special data structure allows us to only inspect those objects that were modified during the prior phase.
concurrent-sweep (concurrent). Now, we proceed through all objects in the heap. Any object without a mark is collected and considered free space. New objects allocated during this time are marked as they are created so that they aren’t accidentally collected.


The important things to note here are:

The stop-the-world phases are made to be very short. The long work of scanning the whole heap and sweeping up the dead objects happens concurrently.
This collector does not relocate the live objects, so free space can be spread in different chunks throughout the heap. We’ll come back to this later!","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/5wogr7asypnj89x6', 'title': 'How does garbage collection work in the JVM?', 'score': {'original': 0.7865, 'ai': 0.2135}, 'blocks': [{'text': 'This actually varies depending on the JVM implementation, but I\'m assuming you\'re talking about Oracle (Sun) Version 6. Java itself does not specify a particular method of garbage collection.\n\nThe JVM uses a form of garbage collector called a tracing collector, which essentially operates by first stopping the world, marking all root objects, or objects that are referenced directly by running threads, and following references, marking each object it hits along the way.\n\nJava 6 implements something called a generational garbage collector—based upon the generational hypothesis assumption, which states that the majority of objects that are created are quickly discarded, and that objects that are not quickly collected are likely to be around for some time.\n\nBased upon these assumptions, Java therefore partitions objects into two different generations, and then operates differently upon them.\n\nVisually, the generations look like this:\n\n\n\n(Not quite to scale)\n\nYoung Generation: This is where objects start out. It has two subgenerations:\n\n\nEden - Objects start out here.\nSurvivor - Objects that survive Eden end up here. There are two of these, and only one is in use at any given time. One is designated as empty, and the other as live. This switched every GC cycle.\n\n\nTenured Generation: Older objects with longer lifetimes end up here.\n\nJava is smart enough to apply different garbage collection methods to each generation. The young generation is handled using a tracing, copying collector called the Parallel New Collector. This collector stops the world, but because the young generation is generally small, the pause is short.\n\nFor the young generation:\n\nWhen Eden fills up, the garbage collector stops the world, then traces through the objects in the young generation, starting with those referenced immediately by a running thread.\n\nThose that are marked or ""alive"" are copied over to the empty survivor space. This survivor space is then marked as ""live"", and Eden, along with the other survivor space, is marked as empty. This has the side effect of compacting all the objects into a single survivor space, allowing for rather efficient memory usage. If an object has been copied between the two survivor places a certain amount of times, its designated as tenured, and moved to the tenured section.\n\nEden will now be overwritten by new objects, and the next garbage collection cycle will proceed to use the other survivor space.\n\nThis usage of a copying collector for the young generation is fast because the vast majority of objects are very quickly destroyed, and generally, very few objects must be moved around.\n\nFor the tenured generation:\n\nI\'m going to steal this section from this blog post by Todd Lipcon, http://www.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/\n\nTenured Generation – Concurrent Mark-Sweep\n\nEvery time the parallel new collector runs, it will tenure some objects into the tenured generation. So, of course, the old generation will eventually fill up, and we need a strategy for collecting it as well. The Concurrent-Mark-Sweep collector (CMS) is responsible for clearing dead objects in this generation.\n\nThe CMS collector operates in a series of phases. Some phases stop the world, and others run concurrently with the Java application. The major phases are:\n\ninitial-mark (stops the world). In this phase, the CMS collector places a mark', 'result': {'fake': 0.007, 'real': 0.993}, 'status': 'success'}, {'text': 'on the rootobjects. A root object is something directly referenced from a live Thread – for example, the local variables in use by that thread. This phase is short because the number of roots is very small.\nconcurrent-mark (concurrent). The collector now follows every pointer starting from the root objects until it has marked all live objects in the system.\nremark (stops the world). Since objects might have had references changed, and new objects might have been created during concurrent-mark, we need to go back and take those into account in this phase. This is short because a special data structure allows us to only inspect those objects that were modified during the prior phase.\nconcurrent-sweep (concurrent). Now, we proceed through all objects in the heap. Any object without a mark is collected and considered free space. New objects allocated during this time are marked as they are created so that they aren’t accidentally collected.\n\n\nThe important things to note here are:\n\nThe stop-the-world phases are made to be very short. The long work of scanning the whole heap and sweeping up the dead objects happens concurrently.\nThis collector does not relocate the live objects, so free space can be spread in different chunks throughout the heap. We’ll come back to this later!', 'result': {'fake': 0.7234, 'real': 0.2766}, 'status': 'success'}], 'credits_used': 8, 'credits': 1984099, 'subscription': 0, 'content': 'This actually varies depending on the JVM implementation, but I\'m assuming you\'re talking about Oracle (Sun) Version 6. Java itself does not specify a particular method of garbage collection.\n\nThe JVM uses a form of garbage collector called a tracing collector, which essentially operates by first stopping the world, marking all root objects, or objects that are referenced directly by running threads, and following references, marking each object it hits along the way.\n\nJava 6 implements something called a generational garbage collector—based upon the generational hypothesis assumption, which states that the majority of objects that are created are quickly discarded, and that objects that are not quickly collected are likely to be around for some time.\n\nBased upon these assumptions, Java therefore partitions objects into two different generations, and then operates differently upon them.\n\nVisually, the generations look like this:\n\n\n\n(Not quite to scale)\n\nYoung Generation: This is where objects start out. It has two subgenerations:\n\n\nEden - Objects start out here.\nSurvivor - Objects that survive Eden end up here. There are two of these, and only one is in use at any given time. One is designated as empty, and the other as live. This switched every GC cycle.\n\n\nTenured Generation: Older objects with longer lifetimes end up here.\n\nJava is smart enough to apply different garbage collection methods to each generation. The young generation is handled using a tracing, copying collector called the Parallel New Collector. This collector stops the world, but because the young generation is generally small, the pause is short.\n\nFor the young generation:\n\nWhen Eden fills up, the garbage collector stops the world, then traces through the objects in the young generation, starting with those referenced immediately by a running thread.\n\nThose that are marked or ""alive"" are copied over to the empty survivor space. This survivor space is then marked as ""live"", and Eden, along with the other survivor space, is marked as empty. This has the side effect of compacting all the objects into a single survivor space, allowing for rather efficient memory usage. If an object has been copied between the two survivor places a certain amount of times, its designated as tenured, and moved to the tenured section.\n\nEden will now be overwritten by new objects, and the next garbage collection cycle will proceed to use the other survivor space.\n\nThis usage of a copying collector for the young generation is fast because the vast majority of objects are very quickly destroyed, and generally, very few objects must be moved around.\n\nFor the tenured generation:\n\nI\'m going to steal this section from this blog post by Todd Lipcon, http://www.cloudera.com/blog/2011/02/avoiding-full-gcs-in-hbase-with-memstore-local-allocation-buffers-part-1/\n\nTenured Generation – Concurrent Mark-Sweep\n\nEvery time the parallel new collector runs, it will tenure some objects into the tenured generation. So, of course, the old generation will eventually fill up, and we need a strategy for collecting it as well. The Concurrent-Mark-Sweep collector (CMS) is responsible for clearing dead objects in this generation.\n\nThe CMS collector operates in a series of phases. Some phases stop the world, and others run concurrently with the Java application. The major phases are:\n\ninitial-mark (stops the world). In this phase, the CMS collector places a mark on the rootobjects. A root object is something directly referenced from a live Thread – for example, the local variables in use by that thread. This phase is short because the number of roots is very small.\nconcurrent-mark (concurrent). The collector now follows every pointer starting from the root objects until it has marked all live objects in the system.\nremark (stops the world). Since objects might have had references changed, and new objects might have been created during concurrent-mark, we need to go back and take those into account in this phase. This is short because a special data structure allows us to only inspect those objects that were modified during the prior phase.\nconcurrent-sweep (concurrent). Now, we proceed through all objects in the heap. Any object without a mark is collected and considered free space. New objects allocated during this time are marked as they are created so that they aren’t accidentally collected.\n\n\nThe important things to note here are:\n\nThe stop-the-world phases are made to be very short. The long work of scanning the whole heap and sweeping up the dead objects happens concurrently.\nThis collector does not relocate the live objects, so free space can be spread in different chunks throughout the heap. We’ll come back to this later!', 'aiModelVersion': '1'}",0.7865
Anna Sharudenko,6y,"If almost everyone can learn programming for free, why is the salary relatively very high?","The majority of people doesn’t give a flying unicorn about programming. They can over romanticize the idea of sitting on your butt cheeks, sipping coffee, and pushing buttons. But sticking to it is harder than you think, unless you program for the joy of it.

You are capable of becoming a spectacular programmer with a few hundred bucks worth of books, an Internet connection, an old laptop, and hard work. If you are not passionate, debugging will flush your brain cells down the toilet.

Do you know why people try to do it? For money. That’s why they fail.

When you breathe in the code, and exhale functions and syntax, while genuinely enjoying the process, you have a good shot to become decent. But if it’s a torture in the rectum and 1 minute feels 5 hours long, just quit. Get your priorities straight.

Good programmers code because they don’t have a choice. They love doing it. It’s an addiction. Money is great, but loving your work is so gratifying.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/qrt3ugl1ej869wxz', 'title': 'If almost everyone can learn programming for free, why is the salary relatively very high?', 'score': {'original': 0.999, 'ai': 0.001}, 'blocks': [{'text': 'The majority of people doesn’t give a flying unicorn about programming. They can over romanticize the idea of sitting on your butt cheeks, sipping coffee, and pushing buttons. But sticking to it is harder than you think, unless you program for the joy of it.\n\nYou are capable of becoming a spectacular programmer with a few hundred bucks worth of books, an Internet connection, an old laptop, and hard work. If you are not passionate, debugging will flush your brain cells down the toilet.\n\nDo you know why people try to do it? For money. That’s why they fail.\n\nWhen you breathe in the code, and exhale functions and syntax, while genuinely enjoying the process, you have a good shot to become decent. But if it’s a torture in the rectum and 1 minute feels 5 hours long, just quit. Get your priorities straight.\n\nGood programmers code because they don’t have a choice. They love doing it. It’s an addiction. Money is great, but loving your work is so gratifying.', 'result': {'fake': 0.001, 'real': 0.999}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984097, 'subscription': 0, 'content': 'The majority of people doesn’t give a flying unicorn about programming. They can over romanticize the idea of sitting on your butt cheeks, sipping coffee, and pushing buttons. But sticking to it is harder than you think, unless you program for the joy of it.\n\nYou are capable of becoming a spectacular programmer with a few hundred bucks worth of books, an Internet connection, an old laptop, and hard work. If you are not passionate, debugging will flush your brain cells down the toilet.\n\nDo you know why people try to do it? For money. That’s why they fail.\n\nWhen you breathe in the code, and exhale functions and syntax, while genuinely enjoying the process, you have a good shot to become decent. But if it’s a torture in the rectum and 1 minute feels 5 hours long, just quit. Get your priorities straight.\n\nGood programmers code because they don’t have a choice. They love doing it. It’s an addiction. Money is great, but loving your work is so gratifying.', 'aiModelVersion': '1'}",0.999
Dennis J Frailey,Updated 3y,How do you deal with a very slow software developer on your team?,"We used to evaluate developers as follows: how much total effort does it take for what they produce. This includes all debugging, testing, and post-release maintenance and repair for the first year of customer use. The result of this method was that a number of “slow” developers came out near the top because their code was often rock solid and didn’t need a lot of expensive maintenance and debugging and repair time.

We also factored in the complexity of their application - the difficulty of writing the code - and the lack of complexity of the actual code they wrote in terms of how well structured their code was, its cyclomatic complexity (goal - low), its coupling (goal - low), its cohesion (goal - high), and various other measures of good structure.. Once again, this often resulted in the best developers being those who took the time to do it right the first time, not the ones who produced the greatest number of lines of code per week.

In our experience, organizations that measure developers only by the speed with which they develop code are generally quite amateurish in their methods and tend to produce code that has a high maintenance and support cost.

Of course we were responsible for code that had to be used in remote locations for long periods of time (decades) and was often safety critical. We would sometimes have to send developers to remote locations to fix code they had written, if the customer was having problems. These remote locations might be quite unappealing, such as a small ship that only reaches port once every three months or a military base in the middle of nowhere or an oil platform out in the ocean somewhere. This added to the incentive for them to get it right the first time. It slowed them down, but the results were very much what we wanted.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/8pbkzv57dgexf0rh', 'title': 'How do you deal with a very slow software developer on your team?', 'score': {'original': 0.989, 'ai': 0.011}, 'blocks': [{'text': 'We used to evaluate developers as follows: how much total effort does it take for what they produce. This includes all debugging, testing, and post-release maintenance and repair for the first year of customer use. The result of this method was that a number of “slow” developers came out near the top because their code was often rock solid and didn’t need a lot of expensive maintenance and debugging and repair time.\n\nWe also factored in the complexity of their application - the difficulty of writing the code - and the lack of complexity of the actual code they wrote in terms of how well structured their code was, its cyclomatic complexity (goal - low), its coupling (goal - low), its cohesion (goal - high), and various other measures of good structure.. Once again, this often resulted in the best developers being those who took the time to do it right the first time, not the ones who produced the greatest number of lines of code per week.\n\nIn our experience, organizations that measure developers only by the speed with which they develop code are generally quite amateurish in their methods and tend to produce code that has a high maintenance and support cost.\n\nOf course we were responsible for code that had to be used in remote locations for long periods of time (decades) and was often safety critical. We would sometimes have to send developers to remote locations to fix code they had written, if the customer was having problems. These remote locations might be quite unappealing, such as a small ship that only reaches port once every three months or a military base in the middle of nowhere or an oil platform out in the ocean somewhere. This added to the incentive for them to get it right the first time. It slowed them down, but the results were very much what we wanted.', 'result': {'fake': 0.011, 'real': 0.989}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984093, 'subscription': 0, 'content': 'We used to evaluate developers as follows: how much total effort does it take for what they produce. This includes all debugging, testing, and post-release maintenance and repair for the first year of customer use. The result of this method was that a number of “slow” developers came out near the top because their code was often rock solid and didn’t need a lot of expensive maintenance and debugging and repair time.\n\nWe also factored in the complexity of their application - the difficulty of writing the code - and the lack of complexity of the actual code they wrote in terms of how well structured their code was, its cyclomatic complexity (goal - low), its coupling (goal - low), its cohesion (goal - high), and various other measures of good structure.. Once again, this often resulted in the best developers being those who took the time to do it right the first time, not the ones who produced the greatest number of lines of code per week.\n\nIn our experience, organizations that measure developers only by the speed with which they develop code are generally quite amateurish in their methods and tend to produce code that has a high maintenance and support cost.\n\nOf course we were responsible for code that had to be used in remote locations for long periods of time (decades) and was often safety critical. We would sometimes have to send developers to remote locations to fix code they had written, if the customer was having problems. These remote locations might be quite unappealing, such as a small ship that only reaches port once every three months or a military base in the middle of nowhere or an oil platform out in the ocean somewhere. This added to the incentive for them to get it right the first time. It slowed them down, but the results were very much what we wanted.', 'aiModelVersion': '1'}",0.989
Jerry Rufener,Updated 3y,How was the first programming language created without an operating system?,"Computers don’t necessarily have to have operating systems!!!!

An extremely popular computer was the PDP8 series of computers introduced in 1965 and a development the earlier PDP5. They were made by Digital Equipment Corporation (DEC) of Maynard, MA. They were THE minicomputer for many years. It had several OS’s available but were often sold/used without an OS - in fact without a disk. I have personally used them that way.

Here is a picture of one of the more popular versions, the PDP8/e. (By Florian Schäffer - Own work, CC BY-SA 4.0, File:Digital pdp8-e2.jpg
)

Notice the switches. To use it you sat in front of it and, using those switches, toggled in the RIM (Read In Mode) loader which was (as I recall) about 20 instructions long. You entered the 12 bit address using the switches, you pressed LOAD ADDR, you entered your first 12 bit instruction, you pressed DEP - that instruction was loaded at the specified memory address and address was incremented. You loaded your next instruction, you pressed DEP again … repeated until all the instructions were loaded. Now you entered the starting address of the loader, pressed LOAD ADDR and then pressed RUN. The RIM loader would execute. Its job was to load the BIN (Binary) loader, on paper tape, from your ASR-33 teletype (33 character per second). The BIN loaded would then load a program from a binary paper tape from the ASR-33.

If it was a cold start you probably read in editor - which allowed you to enter your source code at the, again, ASR-33. The editor would then print out a listing of your program on the ASR-33 and a paper tape of the source code. The source code was most likely in assembler. You then loaded the assembly program using - you guessed it - the ASR33.

The assembler read the source code from the paper tape using the ASR33. If all went well, the assembler would punch out a paper tape in object format. More likely - the first few times - you got errors and had to go back to the editor to fix them. You goal was to produce a paper tape with object code on it.

You would then load the linker and link all of the object modules you produced together - along with any libraries. This could produce more errors which sent you back several steps.

Once you had a clean binary, you loaded in using the BIN loader and the debugging fun began! No symbolic debug - you put debugging instructions into your own code.

Fun huh???

There were disks available - very expensive - very small. Also available was “drum” memory - it is like a disk but built like an Edison cylindrical phonograph. More common were tapes - both 7 and 9 track IBM compatible mag-tapes could be had - if you had the money. More common was something called DECtape - which was actually pretty slick and found on, I think, most PPD8’s. You could get an high speed paper tape reader (100 cps). You could get a ROM loader with RIM on it, but it took and entire slot in the computer, to save the toggling in process. Why didn’t everyone get these items? The computer alone cost $10,000 - for a base model. A disk would at least double the price. You can see where that goes.

Now if you were with a large organization they would have one machine with all the bells and whistles for the developer. They then distributed their application (and updates) on paper tape to machines in the field that were bare bones. I worked on one veneer processing system that was exactly that way. I was with DEC - the OEM (the company that developed the software) bought PDP8s from DEC - they built the electrical/electronic interface to control the veneer manufacturing equipment. They sold it to the end user along with the software.

While you could buy a computer directly from DEC, most were sold via the OEM route. They were installed and used without an OS.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/k58mnehgpcilrfsa', 'title': 'How was the first programming language created without an operating system?', 'score': {'original': 0.99245, 'ai': 0.00755}, 'blocks': [{'text': 'Computers don’t necessarily have to have operating systems!!!!\n\nAn extremely popular computer was the PDP8 series of computers introduced in 1965 and a development the earlier PDP5. They were made by Digital Equipment Corporation (DEC) of Maynard, MA. They were THE minicomputer for many years. It had several OS’s available but were often sold/used without an OS - in fact without a disk. I have personally used them that way.\n\nHere is a picture of one of the more popular versions, the PDP8/e. (By Florian Schäffer - Own work, CC BY-SA 4.0, File:Digital pdp8-e2.jpg\n)\n\nNotice the switches. To use it you sat in front of it and, using those switches, toggled in the RIM (Read In Mode) loader which was (as I recall) about 20 instructions long. You entered the 12 bit address using the switches, you pressed LOAD ADDR, you entered your first 12 bit instruction, you pressed DEP - that instruction was loaded at the specified memory address and address was incremented. You loaded your next instruction, you pressed DEP again … repeated until all the instructions were loaded. Now you entered the starting address of the loader, pressed LOAD ADDR and then pressed RUN. The RIM loader would execute. Its job was to load the BIN (Binary) loader, on paper tape, from your ASR-33 teletype (33 character per second). The BIN loaded would then load a program from a binary paper tape from the ASR-33.\n\nIf it was a cold start you probably read in editor - which allowed you to enter your source code at the, again, ASR-33. The editor would then print out a listing of your program on the ASR-33 and a paper tape of the source code. The source code was most likely in assembler. You then loaded the assembly program using - you guessed it - the ASR33.\n\nThe assembler read the source code from the paper tape using the ASR33. If all went well, the assembler would punch out a paper tape in object format. More likely - the first few times - you got errors and had to go back to the editor to fix them. You goal was to produce a paper tape with object code on it.\n\nYou would then load the linker and link all of the object modules you produced together - along with any libraries. This could produce more errors which sent you back several steps.\n\nOnce you had a clean binary, you loaded in using the BIN loader and the debugging fun began! No symbolic debug - you put debugging instructions into your own code.\n\nFun huh???\n\nThere were disks available - very expensive - very small. Also available was “drum” memory - it is like a disk but built like an Edison cylindrical phonograph. More common were tapes - both 7 and 9 track IBM compatible mag-tapes could be had - if you had the money. More common was something called DECtape - which was actually pretty slick and found on, I think, most PPD8’s. You could get an high speed paper tape reader (100 cps). You could get a ROM loader with RIM', 'result': {'fake': 0.0167, 'real': 0.9833}, 'status': 'success'}, {'text': 'on it, but it took and entire slot in the computer, to save the toggling in process. Why didn’t everyone get these items? The computer alone cost $10,000 - for a base model. A disk would at least double the price. You can see where that goes.\n\nNow if you were with a large organization they would have one machine with all the bells and whistles for the developer. They then distributed their application (and updates) on paper tape to machines in the field that were bare bones. I worked on one veneer processing system that was exactly that way. I was with DEC - the OEM (the company that developed the software) bought PDP8s from DEC - they built the electrical/electronic interface to control the veneer manufacturing equipment. They sold it to the end user along with the software.\n\nWhile you could buy a computer directly from DEC, most were sold via the OEM route. They were installed and used without an OS.', 'result': {'fake': 0.0717, 'real': 0.9283}, 'status': 'success'}], 'credits_used': 7, 'credits': 1984086, 'subscription': 0, 'content': 'Computers don’t necessarily have to have operating systems!!!!\n\nAn extremely popular computer was the PDP8 series of computers introduced in 1965 and a development the earlier PDP5. They were made by Digital Equipment Corporation (DEC) of Maynard, MA. They were THE minicomputer for many years. It had several OS’s available but were often sold/used without an OS - in fact without a disk. I have personally used them that way.\n\nHere is a picture of one of the more popular versions, the PDP8/e. (By Florian Schäffer - Own work, CC BY-SA 4.0, File:Digital pdp8-e2.jpg\n)\n\nNotice the switches. To use it you sat in front of it and, using those switches, toggled in the RIM (Read In Mode) loader which was (as I recall) about 20 instructions long. You entered the 12 bit address using the switches, you pressed LOAD ADDR, you entered your first 12 bit instruction, you pressed DEP - that instruction was loaded at the specified memory address and address was incremented. You loaded your next instruction, you pressed DEP again … repeated until all the instructions were loaded. Now you entered the starting address of the loader, pressed LOAD ADDR and then pressed RUN. The RIM loader would execute. Its job was to load the BIN (Binary) loader, on paper tape, from your ASR-33 teletype (33 character per second). The BIN loaded would then load a program from a binary paper tape from the ASR-33.\n\nIf it was a cold start you probably read in editor - which allowed you to enter your source code at the, again, ASR-33. The editor would then print out a listing of your program on the ASR-33 and a paper tape of the source code. The source code was most likely in assembler. You then loaded the assembly program using - you guessed it - the ASR33.\n\nThe assembler read the source code from the paper tape using the ASR33. If all went well, the assembler would punch out a paper tape in object format. More likely - the first few times - you got errors and had to go back to the editor to fix them. You goal was to produce a paper tape with object code on it.\n\nYou would then load the linker and link all of the object modules you produced together - along with any libraries. This could produce more errors which sent you back several steps.\n\nOnce you had a clean binary, you loaded in using the BIN loader and the debugging fun began! No symbolic debug - you put debugging instructions into your own code.\n\nFun huh???\n\nThere were disks available - very expensive - very small. Also available was “drum” memory - it is like a disk but built like an Edison cylindrical phonograph. More common were tapes - both 7 and 9 track IBM compatible mag-tapes could be had - if you had the money. More common was something called DECtape - which was actually pretty slick and found on, I think, most PPD8’s. You could get an high speed paper tape reader (100 cps). You could get a ROM loader with RIM on it, but it took and entire slot in the computer, to save the toggling in process. Why didn’t everyone get these items? The computer alone cost $10,000 - for a base model. A disk would at least double the price. You can see where that goes.\n\nNow if you were with a large organization they would have one machine with all the bells and whistles for the developer. They then distributed their application (and updates) on paper tape to machines in the field that were bare bones. I worked on one veneer processing system that was exactly that way. I was with DEC - the OEM (the company that developed the software) bought PDP8s from DEC - they built the electrical/electronic interface to control the veneer manufacturing equipment. They sold it to the end user along with the software.\n\nWhile you could buy a computer directly from DEC, most were sold via the OEM route. They were installed and used without an OS.', 'aiModelVersion': '1'}",0.99245
Donald Duck,5y,"As a software engineer, developer, and/or programmer; what is the worst workplace related nightmare you have had?","My nightmare was realizing the first day on the job the catastrophic mistake I made leaving my previous employer and choosing to work for a new company. I left a job that I was extremely secure and comfortable where I was well respected for my contributions.

I thought the new job was the next step in my career, instead it was possibly the worst work environment I had ever seen or heard about. I came from a very successful small software engineering company that grew and was purchased by a bigger company.

I had been with my old company for about 6 years and decided I would take the leap and accept a software engineer position for a government contractor it was a good size pay bump (25% more salary).

The very first day I found out they hired about 80 people to start on the same day. I worked the room and walked around to find out who was who and what roles they had. I quickly find out they had everyone from secretaries to architects all in the same room waiting to go through HR indoctrination.

A gentleman eventually came to the front of the room and introduced himself as the man in charge. He was a high-ranking army officer, who just retired last week and carried himself as if he still wore the uniform. He began explaining that he is the head honcho. Whatever he says goes. If you don’t like that you can leave the room now.

He continued explaining that he didn’t care about your experience or resume. He didn’t care what you were hired for. You will accept whatever job you are given. They had a list of jobs that the government had contracted out to them. He will decide who gets a position. At this point I started to really worry about what the hell I had just done! This has to be a joke right!

About an hour goes by and the head-honcho guy comes in doesn’t say anything, he looks around the room, extends his arm straight as an arrow all the way out with his finger pointing, as if his arm had just become a rifle and starts scanning the room. His arm eventually stops aiming and is steady on a single individual. A single word comes out of his mouth “YOU!” and his index finger curls inward signaling to come here and without ever saying a word walks out of the room with the individual quickly following him.

One-by-one he does the exact same gesture for 5–6 hours. Each time the room is emptied one-by-one. I see some heading out to their cars, while others were transferred to a different room. I later found out they got rid of a few folks (on the same day they were hired…WTF!) and the ones transferred to the other room were the ones that got their position.

Close to the end of the day the head-honcho finally pointed at me, but immediately an older gentleman called the head-honcho by first name and said “sir, I’ve read this gentleman's resume and he would be valuable in my team”. I later found out the team-lead had already scoped out all the resumes and built a team he found suitable.

That job eventually turned out to be one of the most degrading and horrific workplaces I’d ever seen or heard about. If you have ever seen the comedy movie “The Dictator” you can imagine how the head-honcho would walk around through the cubicles and if you looked too relaxed or where doing something that he perceived as slacking-off you would get fired.

Seriously, if you happen to look at him the wrong way or at the wrong time, then a couple of hours later someone would come to your cubicle and say “your services are no longer needed in this contract, please collect your belongings, I’ll escort you out”. Anything short of looking at your screen and looking busy was cause for firing. This guy fired like 10 people the first 2 days after the room pointing episode. If you were running 5 minutes late and you happen to bump into him in the hallway, then you were done.

A co-worker of mine started taking his 1-hour lunch to go eat and escape the toxic environment for a while. On his fourth lunch outing he got a voicemail on his phone stating “your services are no longer needed in this contract…”

This guy would ruin your security clearance by not only firing you, but he would then file an security incident report to essentially black-list you from ever getting a job with a security clearance again. The security incident report was essentially for being fired, which BTW is common tactic government contractors do to easily ruin careers out of spite.

It was weird too, because here we are in a government secured area and there were these group of software engineers that were all Asian. They would spend all day speaking their native language, so you would hear loud Chinese arguments in a classified area, but that group of folks never got fired. Really odd.

After six-months I had been promoted and given my own team, but it was still horrible and I gave my two-weeks’ notice, only to have someone come to my desk the next day and say “your services are no longer needed in this contract, please collect your belongings...” I laughed and said let me say goodbye to my team, to which I was told “No! you need to leave immediately!” to which I responded, “calm down, I’ll be back in a minute, you can follow me if you want”.

After that nightmare, I vowed to never work in a government contract again.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/1wqtc0nfsaj7h4re', 'title': 'As a software engineer, developer, and/or programmer; what is the worst workplace related nightmare you have had?', 'score': {'original': 0.88075, 'ai': 0.11925}, 'blocks': [{'text': ""My nightmare was realizing the first day on the job the catastrophic mistake I made leaving my previous employer and choosing to work for a new company. I left a job that I was extremely secure and comfortable where I was well respected for my contributions.\n\nI thought the new job was the next step in my career, instead it was possibly the worst work environment I had ever seen or heard about. I came from a very successful small software engineering company that grew and was purchased by a bigger company.\n\nI had been with my old company for about 6 years and decided I would take the leap and accept a software engineer position for a government contractor it was a good size pay bump (25% more salary).\n\nThe very first day I found out they hired about 80 people to start on the same day. I worked the room and walked around to find out who was who and what roles they had. I quickly find out they had everyone from secretaries to architects all in the same room waiting to go through HR indoctrination.\n\nA gentleman eventually came to the front of the room and introduced himself as the man in charge. He was a high-ranking army officer, who just retired last week and carried himself as if he still wore the uniform. He began explaining that he is the head honcho. Whatever he says goes. If you don’t like that you can leave the room now.\n\nHe continued explaining that he didn’t care about your experience or resume. He didn’t care what you were hired for. You will accept whatever job you are given. They had a list of jobs that the government had contracted out to them. He will decide who gets a position. At this point I started to really worry about what the hell I had just done! This has to be a joke right!\n\nAbout an hour goes by and the head-honcho guy comes in doesn’t say anything, he looks around the room, extends his arm straight as an arrow all the way out with his finger pointing, as if his arm had just become a rifle and starts scanning the room. His arm eventually stops aiming and is steady on a single individual. A single word comes out of his mouth “YOU!” and his index finger curls inward signaling to come here and without ever saying a word walks out of the room with the individual quickly following him.\n\nOne-by-one he does the exact same gesture for 5–6 hours. Each time the room is emptied one-by-one. I see some heading out to their cars, while others were transferred to a different room. I later found out they got rid of a few folks (on the same day they were hired…WTF!) and the ones transferred to the other room were the ones that got their position.\n\nClose to the end of the day the head-honcho finally pointed at me, but immediately an older gentleman called the head-honcho by first name and said “sir, I’ve read this gentleman's resume and he would"", 'result': {'fake': 0.4053, 'real': 0.5947}, 'status': 'success'}, {'text': 'be valuable in my team”. I later found out the team-lead had already scoped out all the resumes and built a team he found suitable.\n\nThat job eventually turned out to be one of the most degrading and horrific workplaces I’d ever seen or heard about. If you have ever seen the comedy movie “The Dictator” you can imagine how the head-honcho would walk around through the cubicles and if you looked too relaxed or where doing something that he perceived as slacking-off you would get fired.\n\nSeriously, if you happen to look at him the wrong way or at the wrong time, then a couple of hours later someone would come to your cubicle and say “your services are no longer needed in this contract, please collect your belongings, I’ll escort you out”. Anything short of looking at your screen and looking busy was cause for firing. This guy fired like 10 people the first 2 days after the room pointing episode. If you were running 5 minutes late and you happen to bump into him in the hallway, then you were done.\n\nA co-worker of mine started taking his 1-hour lunch to go eat and escape the toxic environment for a while. On his fourth lunch outing he got a voicemail on his phone stating “your services are no longer needed in this contract…”\n\nThis guy would ruin your security clearance by not only firing you, but he would then file an security incident report to essentially black-list you from ever getting a job with a security clearance again. The security incident report was essentially for being fired, which BTW is common tactic government contractors do to easily ruin careers out of spite.\n\nIt was weird too, because here we are in a government secured area and there were these group of software engineers that were all Asian. They would spend all day speaking their native language, so you would hear loud Chinese arguments in a classified area, but that group of folks never got fired. Really odd.\n\nAfter six-months I had been promoted and given my own team, but it was still horrible and I gave my two-weeks’ notice, only to have someone come to my desk the next day and say “your services are no longer needed in this contract, please collect your belongings...” I laughed and said let me say goodbye to my team, to which I was told “No! you need to leave immediately!” to which I responded, “calm down, I’ll be back in a minute, you can follow me if you want”.\n\nAfter that nightmare, I vowed to never work in a government contract again.', 'result': {'fake': 0.3846, 'real': 0.6154}, 'status': 'success'}], 'credits_used': 10, 'credits': 1984076, 'subscription': 0, 'content': ""My nightmare was realizing the first day on the job the catastrophic mistake I made leaving my previous employer and choosing to work for a new company. I left a job that I was extremely secure and comfortable where I was well respected for my contributions.\n\nI thought the new job was the next step in my career, instead it was possibly the worst work environment I had ever seen or heard about. I came from a very successful small software engineering company that grew and was purchased by a bigger company.\n\nI had been with my old company for about 6 years and decided I would take the leap and accept a software engineer position for a government contractor it was a good size pay bump (25% more salary).\n\nThe very first day I found out they hired about 80 people to start on the same day. I worked the room and walked around to find out who was who and what roles they had. I quickly find out they had everyone from secretaries to architects all in the same room waiting to go through HR indoctrination.\n\nA gentleman eventually came to the front of the room and introduced himself as the man in charge. He was a high-ranking army officer, who just retired last week and carried himself as if he still wore the uniform. He began explaining that he is the head honcho. Whatever he says goes. If you don’t like that you can leave the room now.\n\nHe continued explaining that he didn’t care about your experience or resume. He didn’t care what you were hired for. You will accept whatever job you are given. They had a list of jobs that the government had contracted out to them. He will decide who gets a position. At this point I started to really worry about what the hell I had just done! This has to be a joke right!\n\nAbout an hour goes by and the head-honcho guy comes in doesn’t say anything, he looks around the room, extends his arm straight as an arrow all the way out with his finger pointing, as if his arm had just become a rifle and starts scanning the room. His arm eventually stops aiming and is steady on a single individual. A single word comes out of his mouth “YOU!” and his index finger curls inward signaling to come here and without ever saying a word walks out of the room with the individual quickly following him.\n\nOne-by-one he does the exact same gesture for 5–6 hours. Each time the room is emptied one-by-one. I see some heading out to their cars, while others were transferred to a different room. I later found out they got rid of a few folks (on the same day they were hired…WTF!) and the ones transferred to the other room were the ones that got their position.\n\nClose to the end of the day the head-honcho finally pointed at me, but immediately an older gentleman called the head-honcho by first name and said “sir, I’ve read this gentleman's resume and he would be valuable in my team”. I later found out the team-lead had already scoped out all the resumes and built a team he found suitable.\n\nThat job eventually turned out to be one of the most degrading and horrific workplaces I’d ever seen or heard about. If you have ever seen the comedy movie “The Dictator” you can imagine how the head-honcho would walk around through the cubicles and if you looked too relaxed or where doing something that he perceived as slacking-off you would get fired.\n\nSeriously, if you happen to look at him the wrong way or at the wrong time, then a couple of hours later someone would come to your cubicle and say “your services are no longer needed in this contract, please collect your belongings, I’ll escort you out”. Anything short of looking at your screen and looking busy was cause for firing. This guy fired like 10 people the first 2 days after the room pointing episode. If you were running 5 minutes late and you happen to bump into him in the hallway, then you were done.\n\nA co-worker of mine started taking his 1-hour lunch to go eat and escape the toxic environment for a while. On his fourth lunch outing he got a voicemail on his phone stating “your services are no longer needed in this contract…”\n\nThis guy would ruin your security clearance by not only firing you, but he would then file an security incident report to essentially black-list you from ever getting a job with a security clearance again. The security incident report was essentially for being fired, which BTW is common tactic government contractors do to easily ruin careers out of spite.\n\nIt was weird too, because here we are in a government secured area and there were these group of software engineers that were all Asian. They would spend all day speaking their native language, so you would hear loud Chinese arguments in a classified area, but that group of folks never got fired. Really odd.\n\nAfter six-months I had been promoted and given my own team, but it was still horrible and I gave my two-weeks’ notice, only to have someone come to my desk the next day and say “your services are no longer needed in this contract, please collect your belongings...” I laughed and said let me say goodbye to my team, to which I was told “No! you need to leave immediately!” to which I responded, “calm down, I’ll be back in a minute, you can follow me if you want”.\n\nAfter that nightmare, I vowed to never work in a government contract again."", 'aiModelVersion': '1'}",0.88075
Ravi Sundararaman,9mo,"India has about 50 lakh of “software engineers”, but not a single IT product that India can be proud of? Why so, what is wrong with Indian IT employees?","There are so many incorrect parts to this question! Where do I even start?

Where does the need to be ‘proud’ come from? How is that important? We should live with dignity and self-respect, not pride.

Let’s start with WhatsApp as an example to get over this sense of pride in some mass IT product. WhatsApp was created primarily by people of Ukrainian/Russian background living in Silicon Valley. It became a unicorn (billion dollar+ valuation) when it had barely 50 employees. A year later, it was acquired by Facebook for a whopping US$ 19 billion.

Of what use was this achievement to Ukrainians or Russians? Should they be proud of it? WhatsApp is 100% an American product. It hardly offered any employment opportunities. The entire value in the business was captured by a few Americans.

Similarly, our fellow Indian, Sabeer Bhatia, built Hotmail in the 1990s sitting in Silicon Valley. This was the largest mass email product in the world at that time. It was created before Gmail. Sabeer sold it for $400 million, which was a huge deal at that time. But all this was of no use to India or to Indians, other than feeling ‘proud’, whatever that means.

You can’t build a mass consumer product, whether in tech or movies or fashion, sitting in India and easily sell it to Americans. It will happen once in a blue moon.

Consumer products are a cultural thing. They flow from rich to poor, not the other way around. As India gets richer, mass consumer products (like the RRR movie) will increasingly find acceptance in the West.

What India can do well meanwhile is build Business IT products. Business buyers care less about culture and more about price and utility, although even there, trust via cultural affinity does play a strong part.

Indian tech entrepreneurs have been moving rapidly into the Business IT products space over the last 7-8 years. In many areas, ranging from mobile advertising routing to workplace applications to API development platforms, Indian products are well known to those who understand tech or buy corporate tech.

These products are not known to non-techies - they will not be mass consumer products that we can be ‘proud’ of.

Now, let’s come to the ‘50-lakh Indian software engineers’, or whatever the number is. Most of them work in services companies. To take an example, a company like TCS does not sell its own IT products (with rare exceptions in minor markets). TCS needs to partner with, and not compete with, product companies like Microsoft or Google. TCS competes with American consulting companies such as Accenture who also do not sell their own products.

If TCS becomes a product company, many of its partners and clients will become its competitors. It will be suicide.

IT Services work is extremely varied in complexity, from the very mundane to the very complex. These days, Indian IT services companies bid, and often win, billion dollar+ contracts competing against the largest American and European consulting companies, who too use Indian development centers for cost advantage.

If you were to read what is written in some of these contracts, you will be astounded at the amount of complexity involved in working with these clients and expectations. Most mass consumer IT products won’t come close to that level of complexity.

India should make what it has a competitive advantage in. We need money. We need mass employment. Pride can come later.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/mpjia9nh3z5fvr2k', 'title': 'India has about 50 lakh of “software engineers”, but not a single IT product that India can be proud of? Why so, what is wrong with Indian IT employees?', 'score': {'original': 0.98015, 'ai': 0.01985}, 'blocks': [{'text': 'There are so many incorrect parts to this question! Where do I even start?\n\nWhere does the need to be ‘proud’ come from? How is that important? We should live with dignity and self-respect, not pride.\n\nLet’s start with WhatsApp as an example to get over this sense of pride in some mass IT product. WhatsApp was created primarily by people of Ukrainian/Russian background living in Silicon Valley. It became a unicorn (billion dollar+ valuation) when it had barely 50 employees. A year later, it was acquired by Facebook for a whopping US$ 19 billion.\n\nOf what use was this achievement to Ukrainians or Russians? Should they be proud of it? WhatsApp is 100% an American product. It hardly offered any employment opportunities. The entire value in the business was captured by a few Americans.\n\nSimilarly, our fellow Indian, Sabeer Bhatia, built Hotmail in the 1990s sitting in Silicon Valley. This was the largest mass email product in the world at that time. It was created before Gmail. Sabeer sold it for $400 million, which was a huge deal at that time. But all this was of no use to India or to Indians, other than feeling ‘proud’, whatever that means.\n\nYou can’t build a mass consumer product, whether in tech or movies or fashion, sitting in India and easily sell it to Americans. It will happen once in a blue moon.\n\nConsumer products are a cultural thing. They flow from rich to poor, not the other way around. As India gets richer, mass consumer products (like the RRR movie) will increasingly find acceptance in the West.\n\nWhat India can do well meanwhile is build Business IT products. Business buyers care less about culture and more about price and utility, although even there, trust via cultural affinity does play a strong part.\n\nIndian tech entrepreneurs have been moving rapidly into the Business IT products space over the last 7-8 years. In many areas, ranging from mobile advertising routing to workplace applications to API development platforms, Indian products are well known to those who understand tech or buy corporate tech.\n\nThese products are not known to non-techies - they will not be mass consumer products that we can be ‘proud’ of.\n\nNow, let’s come to the ‘50-lakh Indian software engineers’, or whatever the number is. Most of them work in services companies. To take an example, a company like TCS does not sell its own IT products (with rare exceptions in minor markets). TCS needs to partner with, and not compete with, product companies like Microsoft or Google. TCS competes with American consulting companies such as Accenture who also do not sell their own products.\n\nIf TCS becomes a product company, many of its partners and clients will become its competitors. It will be suicide.\n\nIT Services work is extremely varied in complexity, from the very mundane to the very complex. These days, Indian IT services companies bid, and often win, billion dollar+ contracts competing against the largest American and European consulting companies, who too use Indian development centers for cost advantage.\n\nIf you were to read what is written in some of these contracts, you', 'result': {'fake': 0.014, 'real': 0.986}, 'status': 'success'}, {'text': 'will be astounded at the amount of complexity involved in working with these clients and expectations. Most mass consumer IT products won’t come close to that level of complexity.\n\nIndia should make what it has a competitive advantage in. We need money. We need mass employment. Pride can come later.', 'result': {'fake': 0.1022, 'real': 0.8978}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984070, 'subscription': 0, 'content': 'There are so many incorrect parts to this question! Where do I even start?\n\nWhere does the need to be ‘proud’ come from? How is that important? We should live with dignity and self-respect, not pride.\n\nLet’s start with WhatsApp as an example to get over this sense of pride in some mass IT product. WhatsApp was created primarily by people of Ukrainian/Russian background living in Silicon Valley. It became a unicorn (billion dollar+ valuation) when it had barely 50 employees. A year later, it was acquired by Facebook for a whopping US$ 19 billion.\n\nOf what use was this achievement to Ukrainians or Russians? Should they be proud of it? WhatsApp is 100% an American product. It hardly offered any employment opportunities. The entire value in the business was captured by a few Americans.\n\nSimilarly, our fellow Indian, Sabeer Bhatia, built Hotmail in the 1990s sitting in Silicon Valley. This was the largest mass email product in the world at that time. It was created before Gmail. Sabeer sold it for $400 million, which was a huge deal at that time. But all this was of no use to India or to Indians, other than feeling ‘proud’, whatever that means.\n\nYou can’t build a mass consumer product, whether in tech or movies or fashion, sitting in India and easily sell it to Americans. It will happen once in a blue moon.\n\nConsumer products are a cultural thing. They flow from rich to poor, not the other way around. As India gets richer, mass consumer products (like the RRR movie) will increasingly find acceptance in the West.\n\nWhat India can do well meanwhile is build Business IT products. Business buyers care less about culture and more about price and utility, although even there, trust via cultural affinity does play a strong part.\n\nIndian tech entrepreneurs have been moving rapidly into the Business IT products space over the last 7-8 years. In many areas, ranging from mobile advertising routing to workplace applications to API development platforms, Indian products are well known to those who understand tech or buy corporate tech.\n\nThese products are not known to non-techies - they will not be mass consumer products that we can be ‘proud’ of.\n\nNow, let’s come to the ‘50-lakh Indian software engineers’, or whatever the number is. Most of them work in services companies. To take an example, a company like TCS does not sell its own IT products (with rare exceptions in minor markets). TCS needs to partner with, and not compete with, product companies like Microsoft or Google. TCS competes with American consulting companies such as Accenture who also do not sell their own products.\n\nIf TCS becomes a product company, many of its partners and clients will become its competitors. It will be suicide.\n\nIT Services work is extremely varied in complexity, from the very mundane to the very complex. These days, Indian IT services companies bid, and often win, billion dollar+ contracts competing against the largest American and European consulting companies, who too use Indian development centers for cost advantage.\n\nIf you were to read what is written in some of these contracts, you will be astounded at the amount of complexity involved in working with these clients and expectations. Most mass consumer IT products won’t come close to that level of complexity.\n\nIndia should make what it has a competitive advantage in. We need money. We need mass employment. Pride can come later.', 'aiModelVersion': '1'}",0.98015
Dan Herd,6y,What is your favorite software bug/fault horror story?,"My favourite story involves the MMO game EverQuest. A dragon called Kerafyrm, “The Sleeper” had an interesting purpose in the game: he was an unkillable monster that should not be disturbed.

The game had multiple servers and on those servers where he was awoken - he went around killing every player in his path. What was most unusual about this dragon is that he could change zones. He wouldn’t simply wipe out the party in his cave, he would move to the next zone, then the next, slaughtering everyone in his path.

Onto the bug, or perhaps a miscalculation. Eventually players become so powerful that this previously immortal dragon could be defeated. He reportedly had billions of health points and very strong armour - yet eventually, players were able to deal 2 or 3 damage to him per attack. So a group of hundreds of players set out to defeat him.

In a battle that took many hours, players eventually chipped away at this dragons life… he reportedly reached around 25% of his total life and then… he vanished. Disappeared from the game.

It turns out that the game developers, who had programmed him to be unkillable, thought the players were cheating… and simply made him despawn! Funnily enough, after player - developer correspondence, it was agreed they would re-add him into the game so they could attempt to kill him proper. After yet another enormous battle he was defeated, and the rewards he dropped? Absolutely nothing. He was not meant to die, why would he have any loot?!

Never underestimate your users! :)","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/guoq6i9t0jkn2e5a', 'title': 'What is your favorite software bug/fault horror story?', 'score': {'original': 0.9998, 'ai': 0.0002}, 'blocks': [{'text': 'My favourite story involves the MMO game EverQuest. A dragon called Kerafyrm, “The Sleeper” had an interesting purpose in the game: he was an unkillable monster that should not be disturbed.\n\nThe game had multiple servers and on those servers where he was awoken - he went around killing every player in his path. What was most unusual about this dragon is that he could change zones. He wouldn’t simply wipe out the party in his cave, he would move to the next zone, then the next, slaughtering everyone in his path.\n\nOnto the bug, or perhaps a miscalculation. Eventually players become so powerful that this previously immortal dragon could be defeated. He reportedly had billions of health points and very strong armour - yet eventually, players were able to deal 2 or 3 damage to him per attack. So a group of hundreds of players set out to defeat him.\n\nIn a battle that took many hours, players eventually chipped away at this dragons life… he reportedly reached around 25% of his total life and then… he vanished. Disappeared from the game.\n\nIt turns out that the game developers, who had programmed him to be unkillable, thought the players were cheating… and simply made him despawn! Funnily enough, after player - developer correspondence, it was agreed they would re-add him into the game so they could attempt to kill him proper. After yet another enormous battle he was defeated, and the rewards he dropped? Absolutely nothing. He was not meant to die, why would he have any loot?!\n\nNever underestimate your users! :)', 'result': {'fake': 0.0002, 'real': 0.9998}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984067, 'subscription': 0, 'content': 'My favourite story involves the MMO game EverQuest. A dragon called Kerafyrm, “The Sleeper” had an interesting purpose in the game: he was an unkillable monster that should not be disturbed.\n\nThe game had multiple servers and on those servers where he was awoken - he went around killing every player in his path. What was most unusual about this dragon is that he could change zones. He wouldn’t simply wipe out the party in his cave, he would move to the next zone, then the next, slaughtering everyone in his path.\n\nOnto the bug, or perhaps a miscalculation. Eventually players become so powerful that this previously immortal dragon could be defeated. He reportedly had billions of health points and very strong armour - yet eventually, players were able to deal 2 or 3 damage to him per attack. So a group of hundreds of players set out to defeat him.\n\nIn a battle that took many hours, players eventually chipped away at this dragons life… he reportedly reached around 25% of his total life and then… he vanished. Disappeared from the game.\n\nIt turns out that the game developers, who had programmed him to be unkillable, thought the players were cheating… and simply made him despawn! Funnily enough, after player - developer correspondence, it was agreed they would re-add him into the game so they could attempt to kill him proper. After yet another enormous battle he was defeated, and the rewards he dropped? Absolutely nothing. He was not meant to die, why would he have any loot?!\n\nNever underestimate your users! :)', 'aiModelVersion': '1'}",0.9998
Staffan Sandström,1y,The Y2K bug was blamed on lack of foresight. Should we start storing the year in 5 digits to avoid the Y10K bug?,"We, don’t do that any more. But there is a problem coming up that’s called the Y2K38 problem. It haven’t gotten as much publicity as the Y2K problem as it’s further away and 3:14:07 UTC on 19 January 2038 isn’t as interesting as a new years eve. That problem is probably a bit harder to understand for laymen. In many systems the time is stored as seconds from 1970. And it’s stored as a 32-bit integer so we’re running out of seconds. Some have switched to using a 64-bit integer instead and that should work for 292 billion years.

In 2108 the timestamps for DOS files will not work. But that’s hardly a major issue.

JavaScript uses milliseconds since 1 January 1970 and they will not work past 3 September, 275,760. But that gives some time to come up with something.

So there are some other issues that are more relevant than the Y10K bug.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/r95sq17v4mdctf0p', 'title': 'The Y2K bug was blamed on lack of foresight. Should we start storing the year in 5 digits to avoid the Y10K bug?', 'score': {'original': 0.9231, 'ai': 0.0769}, 'blocks': [{'text': 'We, don’t do that any more. But there is a problem coming up that’s called the Y2K38 problem. It haven’t gotten as much publicity as the Y2K problem as it’s further away and 3:14:07 UTC on 19 January 2038 isn’t as interesting as a new years eve. That problem is probably a bit harder to understand for laymen. In many systems the time is stored as seconds from 1970. And it’s stored as a 32-bit integer so we’re running out of seconds. Some have switched to using a 64-bit integer instead and that should work for 292 billion years.\n\nIn 2108 the timestamps for DOS files will not work. But that’s hardly a major issue.\n\nJavaScript uses milliseconds since 1 January 1970 and they will not work past 3 September, 275,760. But that gives some time to come up with something.\n\nSo there are some other issues that are more relevant than the Y10K bug.', 'result': {'fake': 0.0769, 'real': 0.9231}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984065, 'subscription': 0, 'content': 'We, don’t do that any more. But there is a problem coming up that’s called the Y2K38 problem. It haven’t gotten as much publicity as the Y2K problem as it’s further away and 3:14:07 UTC on 19 January 2038 isn’t as interesting as a new years eve. That problem is probably a bit harder to understand for laymen. In many systems the time is stored as seconds from 1970. And it’s stored as a 32-bit integer so we’re running out of seconds. Some have switched to using a 64-bit integer instead and that should work for 292 billion years.\n\nIn 2108 the timestamps for DOS files will not work. But that’s hardly a major issue.\n\nJavaScript uses milliseconds since 1 January 1970 and they will not work past 3 September, 275,760. But that gives some time to come up with something.\n\nSo there are some other issues that are more relevant than the Y10K bug.', 'aiModelVersion': '1'}",0.9231
Jeffrey Naujok,Updated 4y,"Is it true that code works, but no one knows why in some cases?","This used to be absolutely false, since all code was, more or less, written by human beings, and even code that was generated was based on snippets that any human being can work through and understand.

(Algorithmic complexity, courtesy of https://xkcd.com
)

However, in the last decade or so, we have seen the rise of Neural Networks and machine learning algorithms, that lead to rather unique cases.

During their talk on the autonomous driving system for the Tesla, Elon Musk admitted that the Neural Network generated for driving the car is so complex, and composed of so many layers and individual neurons, that it is, effectively, completely beyond human comprehension. That’s a heck of a statement — basically, “It works, but we can’t actually understand how it works.”

So, in that respect, the operation of the neural network code is intractable to the human intellect. We cannot understand, in any reasonable amount of time, the basis by which it reaches decisions.

But, we do know exactly how the underlying code behind the neural network itself works. This is sort of a weird hybrid of understanding and not understanding that develops in any complex system.

For example, understanding a simple power relay switch is simple. Integrate a few million of them into the United States Power Grid, and suddenly it’s, “beyond any single human being’s comprehension.”

There is, of course, one exception to even that hybrid knowledge, and it lies in Genetic Algorithms.

(A flowchart for how to generate Genetic Algorithms.)

A Genetic Algorithm is basically a random program. You generate it, with a few dozen mutated copies, and then apply it to the problem. The individual programs that get closest to the answer are kept, “cross-bred” and then used to generate a new line of mutants. Repeat for thousands of generations, and you can get a program that no human being wrote, that solves problems in a way that may be totally unexpected, or even incomprehensible.

The best example of this that I know of was a FPGA (Field Programmable Gate Array) that was driven by a genetic algorithm to find the smallest circuit that could distinguish between two frequencies fed into an input pin. The best a human had done used about 1000 gates.

After many generations, they had a version that was 100% correct, and used a mere 37 logic gates. No one could understand how it worked. So, they connected it to a debugger circuit…

… and it stopped working.

They reconnected it to the original circuit, and it produced a 100% correct solution. Even connecting it to a copy of the original circuit didn’t work.

Apparently, it relied on some effect in the circuitry of the original board that didn’t exist in any other copy. It had learned so well, that it was using a signal that shouldn’t have existed to get the right answer.

No human can comprehend how or why it worked. Just that it did. In that one case, on that one piece of hardware.

Now that’s inscrutable.

Update: This article came out today on a website I peruse. They used an AI to generate a simulator — and they have no idea how the simulator works, but it’s faster, and more accurate than any human programmed one. The first AI universe sim is fast and accurate - and its creators don't know how it works","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/win48m5xalb20r7h', 'title': 'Is it true that code works, but no one knows why in some cases?', 'score': {'original': 0.91665, 'ai': 0.08335}, 'blocks': [{'text': 'This used to be absolutely false, since all code was, more or less, written by human beings, and even code that was generated was based on snippets that any human being can work through and understand.\n\n(Algorithmic complexity, courtesy of https://xkcd.com\n)\n\nHowever, in the last decade or so, we have seen the rise of Neural Networks and machine learning algorithms, that lead to rather unique cases.\n\nDuring their talk on the autonomous driving system for the Tesla, Elon Musk admitted that the Neural Network generated for driving the car is so complex, and composed of so many layers and individual neurons, that it is, effectively, completely beyond human comprehension. That’s a heck of a statement — basically, “It works, but we can’t actually understand how it works.”\n\nSo, in that respect, the operation of the neural network code is intractable to the human intellect. We cannot understand, in any reasonable amount of time, the basis by which it reaches decisions.\n\nBut, we do know exactly how the underlying code behind the neural network itself works. This is sort of a weird hybrid of understanding and not understanding that develops in any complex system.\n\nFor example, understanding a simple power relay switch is simple. Integrate a few million of them into the United States Power Grid, and suddenly it’s, “beyond any single human being’s comprehension.”\n\nThere is, of course, one exception to even that hybrid knowledge, and it lies in Genetic Algorithms.\n\n(A flowchart for how to generate Genetic Algorithms.)\n\nA Genetic Algorithm is basically a random program. You generate it, with a few dozen mutated copies, and then apply it to the problem. The individual programs that get closest to the answer are kept, “cross-bred” and then used to generate a new line of mutants. Repeat for thousands of generations, and you can get a program that no human being wrote, that solves problems in a way that may be totally unexpected, or even incomprehensible.\n\nThe best example of this that I know of was a FPGA (Field Programmable Gate Array) that was driven by a genetic algorithm to find the smallest circuit that could distinguish between two frequencies fed into an input pin. The best a human had done used about 1000 gates.\n\nAfter many generations, they had a version that was 100% correct, and used a mere 37 logic gates. No one could understand how it worked. So, they connected it to a debugger circuit…\n\n… and it stopped working.\n\nThey reconnected it to the original circuit, and it produced a 100% correct solution. Even connecting it to a copy of the original circuit didn’t work.\n\nApparently, it relied on some effect in the circuitry of the original board that didn’t exist in any other copy. It had learned so well, that it was using a signal that shouldn’t have existed to get the right answer.\n\nNo human can comprehend how or why it worked. Just that it did. In that one case, on that one piece of hardware.\n\nNow that’s inscrutable.\n\nUpdate: This article came out today on a website I peruse. They used an AI to generate a simulator — and they have no idea', 'result': {'fake': 0.0125, 'real': 0.9875}, 'status': 'success'}, {'text': ""how the simulator works, but it’s faster, and more accurate than any human programmed one. The first AI universe sim is fast and accurate - and its creators don't know how it works"", 'result': {'fake': 0.3862, 'real': 0.6138}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984059, 'subscription': 0, 'content': ""This used to be absolutely false, since all code was, more or less, written by human beings, and even code that was generated was based on snippets that any human being can work through and understand.\n\n(Algorithmic complexity, courtesy of https://xkcd.com\n)\n\nHowever, in the last decade or so, we have seen the rise of Neural Networks and machine learning algorithms, that lead to rather unique cases.\n\nDuring their talk on the autonomous driving system for the Tesla, Elon Musk admitted that the Neural Network generated for driving the car is so complex, and composed of so many layers and individual neurons, that it is, effectively, completely beyond human comprehension. That’s a heck of a statement — basically, “It works, but we can’t actually understand how it works.”\n\nSo, in that respect, the operation of the neural network code is intractable to the human intellect. We cannot understand, in any reasonable amount of time, the basis by which it reaches decisions.\n\nBut, we do know exactly how the underlying code behind the neural network itself works. This is sort of a weird hybrid of understanding and not understanding that develops in any complex system.\n\nFor example, understanding a simple power relay switch is simple. Integrate a few million of them into the United States Power Grid, and suddenly it’s, “beyond any single human being’s comprehension.”\n\nThere is, of course, one exception to even that hybrid knowledge, and it lies in Genetic Algorithms.\n\n(A flowchart for how to generate Genetic Algorithms.)\n\nA Genetic Algorithm is basically a random program. You generate it, with a few dozen mutated copies, and then apply it to the problem. The individual programs that get closest to the answer are kept, “cross-bred” and then used to generate a new line of mutants. Repeat for thousands of generations, and you can get a program that no human being wrote, that solves problems in a way that may be totally unexpected, or even incomprehensible.\n\nThe best example of this that I know of was a FPGA (Field Programmable Gate Array) that was driven by a genetic algorithm to find the smallest circuit that could distinguish between two frequencies fed into an input pin. The best a human had done used about 1000 gates.\n\nAfter many generations, they had a version that was 100% correct, and used a mere 37 logic gates. No one could understand how it worked. So, they connected it to a debugger circuit…\n\n… and it stopped working.\n\nThey reconnected it to the original circuit, and it produced a 100% correct solution. Even connecting it to a copy of the original circuit didn’t work.\n\nApparently, it relied on some effect in the circuitry of the original board that didn’t exist in any other copy. It had learned so well, that it was using a signal that shouldn’t have existed to get the right answer.\n\nNo human can comprehend how or why it worked. Just that it did. In that one case, on that one piece of hardware.\n\nNow that’s inscrutable.\n\nUpdate: This article came out today on a website I peruse. They used an AI to generate a simulator — and they have no idea how the simulator works, but it’s faster, and more accurate than any human programmed one. The first AI universe sim is fast and accurate - and its creators don't know how it works"", 'aiModelVersion': '1'}",0.91665
Robert L Hill,Updated 3y,"As a software engineer, do you believe in the theory that ""If the code works, don't fix it""?","I remember when we were doing a port of a GIANT logistics program (3.5 million lines of COBOL code!) from mainframe computers to PC workstations in about 1990. 99.9% of it directly ported once we had re-written the frameworks that drove it.

But ONE central program just didn’t port properly. It just seemingly wouldn’t execute to completion…

I enabled debugging on it - and watched it run. It was a complex loop, with many variants and branches.

And a counter. One central counter that did all the scheduling of the system - that seemingly was never getting to zero on the PC, but it DID execute on the mainframe. Very curious…

Watching it, our team of programmers realized that YES, it was still working the same way on the PC - but on the mainframe, in the original code (that was shipping to HUGE customers like Tropicana, Caterpillar, IBM, lol!) the loop was never being reset to zero properly, and running 4 orders of magnitude too long!!! The mainframe just had more OOOOPH behind it, so no one ever realized how INCREDIBLY INEFFICIENT it was!!!

A simple change that took 10 minutes - that sped everything up brilliantly.

Code should be checked… and rechecked if possible - even if it works!","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/bfqv257pewr8h4ot', 'title': 'As a software engineer, do you believe in the theory that ""If the code works, don\'t fix it""?', 'score': {'original': 0.9993, 'ai': 0.0007}, 'blocks': [{'text': 'I remember when we were doing a port of a GIANT logistics program (3.5 million lines of COBOL code!) from mainframe computers to PC workstations in about 1990. 99.9% of it directly ported once we had re-written the frameworks that drove it.\n\nBut ONE central program just didn’t port properly. It just seemingly wouldn’t execute to completion…\n\nI enabled debugging on it - and watched it run. It was a complex loop, with many variants and branches.\n\nAnd a counter. One central counter that did all the scheduling of the system - that seemingly was never getting to zero on the PC, but it DID execute on the mainframe. Very curious…\n\nWatching it, our team of programmers realized that YES, it was still working the same way on the PC - but on the mainframe, in the original code (that was shipping to HUGE customers like Tropicana, Caterpillar, IBM, lol!) the loop was never being reset to zero properly, and running 4 orders of magnitude too long!!! The mainframe just had more OOOOPH behind it, so no one ever realized how INCREDIBLY INEFFICIENT it was!!!\n\nA simple change that took 10 minutes - that sped everything up brilliantly.\n\nCode should be checked… and rechecked if possible - even if it works!', 'result': {'fake': 0.0007, 'real': 0.9993}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984056, 'subscription': 0, 'content': 'I remember when we were doing a port of a GIANT logistics program (3.5 million lines of COBOL code!) from mainframe computers to PC workstations in about 1990. 99.9% of it directly ported once we had re-written the frameworks that drove it.\n\nBut ONE central program just didn’t port properly. It just seemingly wouldn’t execute to completion…\n\nI enabled debugging on it - and watched it run. It was a complex loop, with many variants and branches.\n\nAnd a counter. One central counter that did all the scheduling of the system - that seemingly was never getting to zero on the PC, but it DID execute on the mainframe. Very curious…\n\nWatching it, our team of programmers realized that YES, it was still working the same way on the PC - but on the mainframe, in the original code (that was shipping to HUGE customers like Tropicana, Caterpillar, IBM, lol!) the loop was never being reset to zero properly, and running 4 orders of magnitude too long!!! The mainframe just had more OOOOPH behind it, so no one ever realized how INCREDIBLY INEFFICIENT it was!!!\n\nA simple change that took 10 minutes - that sped everything up brilliantly.\n\nCode should be checked… and rechecked if possible - even if it works!', 'aiModelVersion': '1'}",0.9993
Michael Veksler,Updated 6y,What is your favorite software bug/fault horror story?,"A fellow developer called me after working for a week on a bug. He managed to narrow it down to one line, but still could not manage to figure it out:

for (i=0; i< LIMIT; i += l)  
{ 
..... 

Being a very sceptical person, I ended up verifying each and every character. The bug is trivial, by the way. Can you spot it?

It's a lower case L, and not a 1 (one). Conclusion — never declare a variable named l or O.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/z8e26wynf3huxjid', 'title': 'What is your favorite software bug/fault horror story?', 'score': {'original': 0.9674, 'ai': 0.0326}, 'blocks': [{'text': ""A fellow developer called me after working for a week on a bug. He managed to narrow it down to one line, but still could not manage to figure it out:\n\nfor (i=0; i< LIMIT; i += l) \xa0\n{\xa0\n.....\xa0\n\nBeing a very sceptical person, I ended up verifying each and every character. The bug is trivial, by the way. Can you spot it?\n\nIt's a lower case L, and not a 1 (one). Conclusion — never declare a variable named l or O."", 'result': {'fake': 0.035, 'real': 0.965}, 'status': 'success'}], 'credits_used': 1, 'credits': 1984055, 'subscription': 0, 'content': ""A fellow developer called me after working for a week on a bug. He managed to narrow it down to one line, but still could not manage to figure it out:\n\nfor (i=0; i< LIMIT; i += l) \xa0\n{\xa0\n.....\xa0\n\nBeing a very sceptical person, I ended up verifying each and every character. The bug is trivial, by the way. Can you spot it?\n\nIt's a lower case L, and not a 1 (one). Conclusion — never declare a variable named l or O."", 'aiModelVersion': '1'}",0.9674
Alan Mellor,4y,Is it a bad idea to improve the code base after hours through refactoring if you're not given time for during working hours?,"Great, nuanced question. I have done this a lot in my early career and a little bit recently. It is both good and bad.

Early on, I did this to practice the new ideas I was learning from books about structure. I previously wrote unstructured code that was a real mess. I started learning from software engineering books.

So I was happy to practice on my real project. It was both a true workout and the results made my next day a bit easier. It felt good.

More recently, a client had a problem in transferring international data from a React/UTF8 app to an IBM/EBCDIC system over a fixed byte record channel. That took a lot longer than we thought and needed me to replace an unsuitable library.

I wanted to do a really good job on that for essentially political reasons. So that felt like the right thing to do.

But both are bad things to do because this unplanned, unmeasured work throws out project tracking. This leads to you looking like you can deliver faster than you can. Great - but the next plan will assume the same toxic speed.

You end up making a rod for your own back if you’re not careful.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/aftzni7ylx1oum9q', 'title': ""Is it a bad idea to improve the code base after hours through refactoring if you're not given time for during working hours?"", 'score': {'original': 0.9992, 'ai': 0.0008}, 'blocks': [{'text': 'Great, nuanced question. I have done this a lot in my early career and a little bit recently. It is both good and bad.\n\nEarly on, I did this to practice the new ideas I was learning from books about structure. I previously wrote unstructured code that was a real mess. I started learning from software engineering books.\n\nSo I was happy to practice on my real project. It was both a true workout and the results made my next day a bit easier. It felt good.\n\nMore recently, a client had a problem in transferring international data from a React/UTF8 app to an IBM/EBCDIC system over a fixed byte record channel. That took a lot longer than we thought and needed me to replace an unsuitable library.\n\nI wanted to do a really good job on that for essentially political reasons. So that felt like the right thing to do.\n\nBut both are bad things to do because this unplanned, unmeasured work throws out project tracking. This leads to you looking like you can deliver faster than you can. Great - but the next plan will assume the same toxic speed.\n\nYou end up making a rod for your own back if you’re not careful.', 'result': {'fake': 0.0008, 'real': 0.9992}, 'status': 'success'}], 'credits_used': 3, 'credits': 1984052, 'subscription': 0, 'content': 'Great, nuanced question. I have done this a lot in my early career and a little bit recently. It is both good and bad.\n\nEarly on, I did this to practice the new ideas I was learning from books about structure. I previously wrote unstructured code that was a real mess. I started learning from software engineering books.\n\nSo I was happy to practice on my real project. It was both a true workout and the results made my next day a bit easier. It felt good.\n\nMore recently, a client had a problem in transferring international data from a React/UTF8 app to an IBM/EBCDIC system over a fixed byte record channel. That took a lot longer than we thought and needed me to replace an unsuitable library.\n\nI wanted to do a really good job on that for essentially political reasons. So that felt like the right thing to do.\n\nBut both are bad things to do because this unplanned, unmeasured work throws out project tracking. This leads to you looking like you can deliver faster than you can. Great - but the next plan will assume the same toxic speed.\n\nYou end up making a rod for your own back if you’re not careful.', 'aiModelVersion': '1'}",0.9992
Alan Mellor,5y,"What is considered good code to rookie programmers, but mediocre to professionals?","Anything terse and/or hard to read, for me.

As a rookie, I used to enjoy it when friends read my code and I had to explain to them how it worked. I enjoyed telling the tale of how I’d shaved a cycle off and saved a byte by using this loophole I’d found.

It made me feel terribly clever and accomplished.

Now, I just feel a failure.

I have not captured my thoughts in the code, which is all there is for the rest of the team to see.

Clever, to me, is putting the effort into writing your code so that it is self-explanatory. So I can see the essence of the problem you solved, why and then how.

That’s the biggest change for me.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/30ydjmvnz7rtokfi', 'title': 'What is considered good code to rookie programmers, but mediocre to professionals?', 'score': {'original': 0.9984, 'ai': 0.0016}, 'blocks': [{'text': 'Anything terse and/or hard to read, for me.\n\nAs a rookie, I used to enjoy it when friends read my code and I had to explain to them how it worked. I enjoyed telling the tale of how I’d shaved a cycle off and saved a byte by using this loophole I’d found.\n\nIt made me feel terribly clever and accomplished.\n\nNow, I just feel a failure.\n\nI have not captured my thoughts in the code, which is all there is for the rest of the team to see.\n\nClever, to me, is putting the effort into writing your code so that it is self-explanatory. So I can see the essence of the problem you solved, why and then how.\n\nThat’s the biggest change for me.', 'result': {'fake': 0.0016, 'real': 0.9984}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984050, 'subscription': 0, 'content': 'Anything terse and/or hard to read, for me.\n\nAs a rookie, I used to enjoy it when friends read my code and I had to explain to them how it worked. I enjoyed telling the tale of how I’d shaved a cycle off and saved a byte by using this loophole I’d found.\n\nIt made me feel terribly clever and accomplished.\n\nNow, I just feel a failure.\n\nI have not captured my thoughts in the code, which is all there is for the rest of the team to see.\n\nClever, to me, is putting the effort into writing your code so that it is self-explanatory. So I can see the essence of the problem you solved, why and then how.\n\nThat’s the biggest change for me.', 'aiModelVersion': '1'}",0.9984
Alan Kay,3y,What thought process would lead one to invent object-oriented programming?,"(Per Paul Hudson: “Maybe Alan Kay would answer. Since he did!”)

Well, OK.

In 1992, I was asked to write a history of what I actually did by the ACM for their second “History Of Programming Languages” conference. There are several versions online, including at Bret Victor’s site: “The Early History Of Smalltalk
”. This should satisfy those who want more detail.

For the purposes here for Quora, (a) I did coin the phrase “object oriented programming” for what I was working on in 1966, but (b) I thought of what I was doing was a kind of “rotation” and generalization of an idea I had seen in a variety of forms since my days as:

a biologist
then as a programmer in the Air Force starting in 1961: a way to make a “semantic file system”
then in the hardware of the B5000 computer
in the large, as processes in “multi-programmed” and “time-shared” operating systems
most startlingly in Ivan Sutherland’s Sketchpad
in a more prosaic practical form in Simula
and as done with entire computers on networks (as in the upcoming ARPAnet by my research community).

What hit me in Nov 1966 was ridiculously, absurdly simple: “that, if you can have enough computers which can intercommunicate, this is all you need to define anything that can be done on a computer by any other means”. This is because each computer is universal, etc.

Putting aside the practical difficulties — I was basically a lazy mathematician, so it was fairly easy to detach from the industrious pragmatist I had to be as a programmer — this was very attractive as an idea, because it scaled much better than the traditional ideas of procedures and data structures as building blocks.

And it was so much cleaner, and so much more amenable to whole systems designs.

And so amenable to thinking in terms of “designing and programming simulations”. This last was from the two systems I saw within a week of each other that pushed me over the edge: Sketchpad and the first Simula — both of which were essentially set up to simulate complex entities containing many interrelated processes.

Another very attractive feature of having everything being made from “semantic software computers intercommunicating via messaging” is that some ugly properties of “data” could not only be fixed, but even eliminated. For example, standard hardware and programming languages which map closely to them can give rise to simple arrays, but not to “data structures” that are just a little more complicated — like sparse matrices — and stacks and queues, etc. These are easy to do if these are instead “processes” and get to decide internally what the “assignment arrow” should mean.

And this can lead to something much nicer than “data” that still has state but no race conditions on it. For example, inside the object it can decide to version the histories if it wants, it can do “atomic transactions”, it can only allow viewing when all of its relationships are consistent. And many more. The data idea was always a bad one, and this new semantic building block would allow objects to progress through time — and “learn” etc. — but would be much safer.

And then there is the idea of simulation itself, where the whole idea of “data” and “state” starts to get eclipsed by “competent objects” that can cooperate, much more like biological cells and human societies can.

So, the thought processes that led to this were basically “systems thought processes” that were about being able to easily define systems of processes: any kinds of systems of any kinds of processes.

This will not resemble much of what most readers will associate with OOP — in the sense of language like C++, Java, etc.

Quite a bit of the disconnect is in point of view/perspective. C++ and Java etc. use objects mainly to define new things that are very like data structures, and the programming that is done is generally very data structure like (e.g. “setters” turn any kind of entity back into a data structure that can be imperatively munged by anyone). Technically, this is actually “Abstract Data Structures” and though a subset of what can be done with objects, is a divergence from the intent.

The picture I delineated above allows a good systems designer to design a good system and make it, even if very large. It’s obviously that much of the benefit of the idea will be lost if skilled systems design is not employed.

An important side point is that the strength and generality of the definitional aspects of this paradigm can be quite independent of programming style (this is the central key of what “simulation of systems” means).

An object can perfectly simulate a function, procedure, a data structure, etc., so everything old can be covered completely, but it can also simulate very smart agencies and agents, to provide much stronger ways of doing things.

The flaw in how things have played out is that very few in computing actually put in the effort to grok the implications of “universal scalable systems of processes”, and instead have clung to very old and poorly scalable ways to program.

At Parc, we got a tremendous boost in what we could conceive and write in very few lines of code because we tried to use as much as possible about what we understood about this new way to organize and program complex systems. (Today, there is more understood about this, but even the first time around, we were constantly amazed at what was possible.)","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/8qengb360ktwi1s5', 'title': 'What thought process would lead one to invent object-oriented programming?', 'score': {'original': 0.3594, 'ai': 0.6406}, 'blocks': [{'text': '(Per Paul Hudson: “Maybe Alan Kay would answer. Since he did!”)\n\nWell, OK.\n\nIn 1992, I was asked to write a history of what I actually did by the ACM for their second “History Of Programming Languages” conference. There are several versions online, including at Bret Victor’s site: “The Early History Of Smalltalk\n”. This should satisfy those who want more detail.\n\nFor the purposes here for Quora, (a) I did coin the phrase “object oriented programming” for what I was working on in 1966, but (b) I thought of what I was doing was a kind of “rotation” and generalization of an idea I had seen in a variety of forms since my days as:\n\na biologist\nthen as a programmer in the Air Force starting in 1961: a way to make a “semantic file system”\nthen in the hardware of the B5000 computer\nin the large, as processes in “multi-programmed” and “time-shared” operating systems\nmost startlingly in Ivan Sutherland’s Sketchpad\nin a more prosaic practical form in Simula\nand as done with entire computers on networks (as in the upcoming ARPAnet by my research community).\n\nWhat hit me in Nov 1966 was ridiculously, absurdly simple: “that, if you can have enough computers which can intercommunicate, this is all you need to define anything that can be done on a computer by any other means”. This is because each computer is universal, etc.\n\nPutting aside the practical difficulties — I was basically a lazy mathematician, so it was fairly easy to detach from the industrious pragmatist I had to be as a programmer — this was very attractive as an idea, because it scaled much better than the traditional ideas of procedures and data structures as building blocks.\n\nAnd it was so much cleaner, and so much more amenable to whole systems designs.\n\nAnd so amenable to thinking in terms of “designing and programming simulations”. This last was from the two systems I saw within a week of each other that pushed me over the edge: Sketchpad and the first Simula — both of which were essentially set up to simulate complex entities containing many interrelated processes.\n\nAnother very attractive feature of having everything being made from “semantic software computers intercommunicating via messaging” is that some ugly properties of “data” could not only be fixed, but even eliminated. For example, standard hardware and programming languages which map closely to them can give rise to simple arrays, but not to “data structures” that are just a little more complicated — like sparse matrices — and stacks and queues, etc. These are easy to do if these are instead “processes” and get to decide internally what the “assignment arrow” should mean.\n\nAnd this can lead to something much nicer than “data” that still has state but no race conditions on it. For example, inside the object it can decide to version the histories if it wants, it can do “atomic transactions”, it can only allow viewing when all of its relationships are consistent. And many more. The data idea was always a bad one, and this new semantic building block would allow objects to progress through time — and “learn”', 'result': {'fake': 0.0384, 'real': 0.9616}, 'status': 'success'}, {'text': 'etc. — but would be much safer.\n\nAnd then there is the idea of simulation itself, where the whole idea of “data” and “state” starts to get eclipsed by “competent objects” that can cooperate, much more like biological cells and human societies can.\n\nSo, the thought processes that led to this were basically “systems thought processes” that were about being able to easily define systems of processes: any kinds of systems of any kinds of processes.\n\nThis will not resemble much of what most readers will associate with OOP — in the sense of language like C++, Java, etc.\n\nQuite a bit of the disconnect is in point of view/perspective. C++ and Java etc. use objects mainly to define new things that are very like data structures, and the programming that is done is generally very data structure like (e.g. “setters” turn any kind of entity back into a data structure that can be imperatively munged by anyone). Technically, this is actually “Abstract Data Structures” and though a subset of what can be done with objects, is a divergence from the intent.\n\nThe picture I delineated above allows a good systems designer to design a good system and make it, even if very large. It’s obviously that much of the benefit of the idea will be lost if skilled systems design is not employed.\n\nAn important side point is that the strength and generality of the definitional aspects of this paradigm can be quite independent of programming style (this is the central key of what “simulation of systems” means).\n\nAn object can perfectly simulate a function, procedure, a data structure, etc., so everything old can be covered completely, but it can also simulate very smart agencies and agents, to provide much stronger ways of doing things.\n\nThe flaw in how things have played out is that very few in computing actually put in the effort to grok the implications of “universal scalable systems of processes”, and instead have clung to very old and poorly scalable ways to program.\n\nAt Parc, we got a tremendous boost in what we could conceive and write in very few lines of code because we tried to use as much as possible about what we understood about this new way to organize and program complex systems. (Today, there is more understood about this, but even the first time around, we were constantly amazed at what was possible.)', 'result': {'fake': 0.3078, 'real': 0.6922}, 'status': 'success'}], 'credits_used': 10, 'credits': 1984040, 'subscription': 0, 'content': '(Per Paul Hudson: “Maybe Alan Kay would answer. Since he did!”)\n\nWell, OK.\n\nIn 1992, I was asked to write a history of what I actually did by the ACM for their second “History Of Programming Languages” conference. There are several versions online, including at Bret Victor’s site: “The Early History Of Smalltalk\n”. This should satisfy those who want more detail.\n\nFor the purposes here for Quora, (a) I did coin the phrase “object oriented programming” for what I was working on in 1966, but (b) I thought of what I was doing was a kind of “rotation” and generalization of an idea I had seen in a variety of forms since my days as:\n\na biologist\nthen as a programmer in the Air Force starting in 1961: a way to make a “semantic file system”\nthen in the hardware of the B5000 computer\nin the large, as processes in “multi-programmed” and “time-shared” operating systems\nmost startlingly in Ivan Sutherland’s Sketchpad\nin a more prosaic practical form in Simula\nand as done with entire computers on networks (as in the upcoming ARPAnet by my research community).\n\nWhat hit me in Nov 1966 was ridiculously, absurdly simple: “that, if you can have enough computers which can intercommunicate, this is all you need to define anything that can be done on a computer by any other means”. This is because each computer is universal, etc.\n\nPutting aside the practical difficulties — I was basically a lazy mathematician, so it was fairly easy to detach from the industrious pragmatist I had to be as a programmer — this was very attractive as an idea, because it scaled much better than the traditional ideas of procedures and data structures as building blocks.\n\nAnd it was so much cleaner, and so much more amenable to whole systems designs.\n\nAnd so amenable to thinking in terms of “designing and programming simulations”. This last was from the two systems I saw within a week of each other that pushed me over the edge: Sketchpad and the first Simula — both of which were essentially set up to simulate complex entities containing many interrelated processes.\n\nAnother very attractive feature of having everything being made from “semantic software computers intercommunicating via messaging” is that some ugly properties of “data” could not only be fixed, but even eliminated. For example, standard hardware and programming languages which map closely to them can give rise to simple arrays, but not to “data structures” that are just a little more complicated — like sparse matrices — and stacks and queues, etc. These are easy to do if these are instead “processes” and get to decide internally what the “assignment arrow” should mean.\n\nAnd this can lead to something much nicer than “data” that still has state but no race conditions on it. For example, inside the object it can decide to version the histories if it wants, it can do “atomic transactions”, it can only allow viewing when all of its relationships are consistent. And many more. The data idea was always a bad one, and this new semantic building block would allow objects to progress through time — and “learn” etc. — but would be much safer.\n\nAnd then there is the idea of simulation itself, where the whole idea of “data” and “state” starts to get eclipsed by “competent objects” that can cooperate, much more like biological cells and human societies can.\n\nSo, the thought processes that led to this were basically “systems thought processes” that were about being able to easily define systems of processes: any kinds of systems of any kinds of processes.\n\nThis will not resemble much of what most readers will associate with OOP — in the sense of language like C++, Java, etc.\n\nQuite a bit of the disconnect is in point of view/perspective. C++ and Java etc. use objects mainly to define new things that are very like data structures, and the programming that is done is generally very data structure like (e.g. “setters” turn any kind of entity back into a data structure that can be imperatively munged by anyone). Technically, this is actually “Abstract Data Structures” and though a subset of what can be done with objects, is a divergence from the intent.\n\nThe picture I delineated above allows a good systems designer to design a good system and make it, even if very large. It’s obviously that much of the benefit of the idea will be lost if skilled systems design is not employed.\n\nAn important side point is that the strength and generality of the definitional aspects of this paradigm can be quite independent of programming style (this is the central key of what “simulation of systems” means).\n\nAn object can perfectly simulate a function, procedure, a data structure, etc., so everything old can be covered completely, but it can also simulate very smart agencies and agents, to provide much stronger ways of doing things.\n\nThe flaw in how things have played out is that very few in computing actually put in the effort to grok the implications of “universal scalable systems of processes”, and instead have clung to very old and poorly scalable ways to program.\n\nAt Parc, we got a tremendous boost in what we could conceive and write in very few lines of code because we tried to use as much as possible about what we understood about this new way to organize and program complex systems. (Today, there is more understood about this, but even the first time around, we were constantly amazed at what was possible.)', 'aiModelVersion': '1'}",0.3594
Victor Volkman,Updated 4y,Who is the best programmer of our time?,"Donald Knuth
, hands down.

He is such a geek that he took 10 years off from writing his six volume work The Art of Computer Programming to create a typesetting language capable of displaying the formulas he needed to demonstrate the principles in the book. It’s not a stretch to say that he single-handedly helped define Computer Science as a real thing.

If your best programmer hasn’t written a six-volume treatise on the Art of Computer Programming, please take two steps back.

Knuth's impact is far-reaching. Literate programming, attributed to Knuth, essentially holds that computer programs should be developed with an eye toward human comprehension more than computer readability. He maintains that the very act of communicating one's work clearly to other people will improve the work itself.

Here’s a story about a famous programming contest[1] in which Knuth beat the legendary John McCarthy (AI proponent and inventor of LISP)

Andrew: A story states that you once entered a programming contest at Stanford (I believe) and you submitted the winning entry, which worked correctly after a single compilation. Is this story true? In that vein, today’s developers frequently build programs writing small code increments followed by immediate compilation and the creation and running of unit tests. What are your thoughts on this approach to software development?

Donald: The story you heard is typical of legends that are based on only a small kernel of truth. Here’s what actually happened: John McCarthy
 decided in 1971 to have a Memorial Day Programming Race. All of the contestants except me worked at his AI Lab up in the hills above Stanford, using the WAITS time-sharing system; I was down on the main campus, where the only computer available to me was a mainframe for which I had to punch cards and submit them for processing in batch mode. I used Wirth’s ALGOL W
 system (the predecessor of Pascal). My program didn’t work the first time, but fortunately I could use Ed Satterthwaite
’s excellent offline debugging system for ALGOL W, so I needed only two runs. Meanwhile, the folks using WAITS couldn’t get enough machine cycles because their machine was so overloaded. (I think that the second-place finisher, using that ""modern"" approach, came in about an hour after I had submitted the winning entry with old-fangled methods.) It wasn’t a fair contest.

Here are some links to papers
 he has written. To view them, you’ll need a copy of his typesetting program TeX
.

Also, he has a giant pipe-organ installed in his house, a must-have for any mad scientist’s lair.

Donald Knuth’s organ is bigger than yours: “This sixteen-rank organ was designed and built for our home by Abbott and Sieker of Los Angeles, California, as their `Opus 67.[2] ’' It has 812 pipes, separated into three divisions.

Props to Phillip Remaker
 for pointing me to the best XKCD

Now here’s the part where I grovel for upvotes to break the 4096 barrier. If you know what 2 to the 12th power is, please upvote for the love of G-d.
EDIT: we just passed 4096 upvotes on 02–10–2020, praise be to von Neumann!

Footnotes

[1] Interview with Donald Knuth
[2] Abbott & Sieker, Organ Builders, Los Angeles, California Opus List","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/jzqie3p72cm54v8y', 'title': 'Who is the best programmer of our time?', 'score': {'original': 0.66465, 'ai': 0.33535}, 'blocks': [{'text': 'Donald Knuth\n, hands down.\n\nHe is such a geek that he took 10 years off from writing his six volume work The Art of Computer Programming to create a typesetting language capable of displaying the formulas he needed to demonstrate the principles in the book. It’s not a stretch to say that he single-handedly helped define Computer Science as a real thing.\n\nIf your best programmer hasn’t written a six-volume treatise on the Art of Computer Programming, please take two steps back.\n\nKnuth\'s impact is far-reaching. Literate programming, attributed to Knuth, essentially holds that computer programs should be developed with an eye toward human comprehension more than computer readability. He maintains that the very act of communicating one\'s work clearly to other people will improve the work itself.\n\nHere’s a story about a famous programming contest[1] in which Knuth beat the legendary John McCarthy (AI proponent and inventor of LISP)\n\nAndrew: A story states that you once entered a programming contest at Stanford (I believe) and you submitted the winning entry, which worked correctly after a single compilation. Is this story true? In that vein, today’s developers frequently build programs writing small code increments followed by immediate compilation and the creation and running of unit tests. What are your thoughts on this approach to software development?\n\nDonald: The story you heard is typical of legends that are based on only a small kernel of truth. Here’s what actually happened: John McCarthy\n decided in 1971 to have a Memorial Day Programming Race. All of the contestants except me worked at his AI Lab up in the hills above Stanford, using the WAITS time-sharing system; I was down on the main campus, where the only computer available to me was a mainframe for which I had to punch cards and submit them for processing in batch mode. I used Wirth’s ALGOL W\n system (the predecessor of Pascal). My program didn’t work the first time, but fortunately I could use Ed Satterthwaite\n’s excellent offline debugging system for ALGOL W, so I needed only two runs. Meanwhile, the folks using WAITS couldn’t get enough machine cycles because their machine was so overloaded. (I think that the second-place finisher, using that ""modern"" approach, came in about an hour after I had submitted the winning entry with old-fangled methods.) It wasn’t a fair contest.\n\nHere are some links to papers\n he has written. To view them, you’ll need a copy of his typesetting program TeX\n.\n\nAlso, he has a giant pipe-organ installed in his house, a must-have for any mad scientist’s lair.\n\nDonald Knuth’s organ is bigger than yours: “This sixteen-rank organ was designed and built for our home by Abbott and Sieker of Los Angeles, California, as their `Opus 67.[2] ’\' It has 812 pipes, separated into three divisions.\n\nProps to Phillip Remaker\n for pointing me to the best XKCD\n\nNow here’s the part where I grovel for upvotes to break the 4096 barrier. If you know what 2 to the 12th power is, please upvote for the love of G-d.\nEDIT: we just passed 4096 upvotes on 02–10–2020, praise be to von Neumann!\n\nFootnotes\n\n[1] Interview with Donald Knuth\n[2] Abbott', 'result': {'fake': 0.0014, 'real': 0.9986}, 'status': 'success'}, {'text': '& Sieker, Organ Builders, Los Angeles, California Opus List', 'result': {'fake': 0.9968, 'real': 0.0032}, 'status': 'success'}], 'credits_used': 6, 'credits': 1984034, 'subscription': 0, 'content': 'Donald Knuth\n, hands down.\n\nHe is such a geek that he took 10 years off from writing his six volume work The Art of Computer Programming to create a typesetting language capable of displaying the formulas he needed to demonstrate the principles in the book. It’s not a stretch to say that he single-handedly helped define Computer Science as a real thing.\n\nIf your best programmer hasn’t written a six-volume treatise on the Art of Computer Programming, please take two steps back.\n\nKnuth\'s impact is far-reaching. Literate programming, attributed to Knuth, essentially holds that computer programs should be developed with an eye toward human comprehension more than computer readability. He maintains that the very act of communicating one\'s work clearly to other people will improve the work itself.\n\nHere’s a story about a famous programming contest[1] in which Knuth beat the legendary John McCarthy (AI proponent and inventor of LISP)\n\nAndrew: A story states that you once entered a programming contest at Stanford (I believe) and you submitted the winning entry, which worked correctly after a single compilation. Is this story true? In that vein, today’s developers frequently build programs writing small code increments followed by immediate compilation and the creation and running of unit tests. What are your thoughts on this approach to software development?\n\nDonald: The story you heard is typical of legends that are based on only a small kernel of truth. Here’s what actually happened: John McCarthy\n decided in 1971 to have a Memorial Day Programming Race. All of the contestants except me worked at his AI Lab up in the hills above Stanford, using the WAITS time-sharing system; I was down on the main campus, where the only computer available to me was a mainframe for which I had to punch cards and submit them for processing in batch mode. I used Wirth’s ALGOL W\n system (the predecessor of Pascal). My program didn’t work the first time, but fortunately I could use Ed Satterthwaite\n’s excellent offline debugging system for ALGOL W, so I needed only two runs. Meanwhile, the folks using WAITS couldn’t get enough machine cycles because their machine was so overloaded. (I think that the second-place finisher, using that ""modern"" approach, came in about an hour after I had submitted the winning entry with old-fangled methods.) It wasn’t a fair contest.\n\nHere are some links to papers\n he has written. To view them, you’ll need a copy of his typesetting program TeX\n.\n\nAlso, he has a giant pipe-organ installed in his house, a must-have for any mad scientist’s lair.\n\nDonald Knuth’s organ is bigger than yours: “This sixteen-rank organ was designed and built for our home by Abbott and Sieker of Los Angeles, California, as their `Opus 67.[2] ’\' It has 812 pipes, separated into three divisions.\n\nProps to Phillip Remaker\n for pointing me to the best XKCD\n\nNow here’s the part where I grovel for upvotes to break the 4096 barrier. If you know what 2 to the 12th power is, please upvote for the love of G-d.\nEDIT: we just passed 4096 upvotes on 02–10–2020, praise be to von Neumann!\n\nFootnotes\n\n[1] Interview with Donald Knuth\n[2] Abbott & Sieker, Organ Builders, Los Angeles, California Opus List', 'aiModelVersion': '1'}",0.66465
Sam Park,Updated 5y,"What is the best way to self-teach the skills and knowledge gained in a typical computer science degree, assuming a person only has functional working knowledge of computers?","I think starting by thoroughly learning a programming language is a good idea. It is often said that CS is more than programming or a particular language, but much of CS is done through programming, and is a way for you to pick up good fundamentals. Languages such as C/C++, Python, and Java are popular starters. Some are probably bad choice for starters (ex. Javascript, imo). I started with Java (as my first CS class happened to be taught in this), and Java has its merits over C/C++ and Python, especially as a first language. I prefer Java's static typing, though I also enjoy Python's brevity and readability. C++ is a bit messy for starters, and C is a bit too low-level for your first language, but it has its benefits. It doesn't matter too much what you happen to pick.

Once you have picked a language, grab an introductory book (or find resources online); work through the exercises (preferably by actually compiling and running your programs on a real computer) and learn basic programming constructs (if-else, loops, variables, Arrays, Input/Output). This might take a while if you have never programmed before, but you will get used to it.

Once you got the basics down and can write simple programs, try building a larger OOP-style project involving multiple classes. This could be from an assignment online, from the back of the textbook, or something simple you wanted to build (some ideas: maybe a simple game with a GUI).

You don't have to master the language, but just learn enough basics so that you can code up simple things when you want to (and also begin to think like a computer scientist). In fact, to master a language in all its depth takes quite a bit of time and experience.

From this point on, what I describe follows more or less a standard college CS curriculum, which means that it has a substantial theoretical component to it. If you want to just practice programming or are interested in more direct applications such as web design, this may not apply to you, but some of these skills are fundamental to all of CS (and problem solving) , and even if you're writing a web application or a new smartphone app, knowing basic algorithms and data structures (and in general understanding the thought processes of a computer scientist) will help you a lot not only directly with what you're producing/coding, but allow you to have a greater appreciation for the kind of problem solving, design considerations, and analysis that computer scientists practice everyday.

Typically, after the introductory CS course, one picks up a little more foundation for mathematical tools in CS: discrete math and basic data structures and algorithms. For this, I also recommend grabbing a textbook or looking for resources online (many colleges have their course notes and problem sets available online; MOOC's are becoming more popular too). Some basic data structures/algorithms that you should become familiar with: arrays, linked lists, Binary Search Trees, balanced Binary Search Trees (ex. Red-black trees, AVL trees), heaps, sorting algorithms (insertion sort, merge sort, quick sort), and a plenty more.

As for discrete math, you should be familiar with basic probability, logic, proof techniques (induction), basic number theory, set theory, automata theory/finite state machines, and basic graph theory. These are more or less tools to help you reason about computation in its various forms. They might seem a little dry/pointless if it's your first time seeing it, so it's important see motivations for certain concepts. For example, basic number theory becomes useful in constructing basic cryptographic primitives. As another example, logic becomes necessary when you reason about how programming languages are compiled.

By now, you've explored most of the basics. You can write up simple programs that do what you want, and you are familiar with basic data structures to make your programs efficient, and some basic mathematics to reason about them.

Some deeper topics now. None of these are required, but they are part of standard CS curriculums and as a whole instrumental to your understanding of CS.

- Algorithms. Using similar resources, learn more advanced algorithms and design principles such as greedy algorithms, dynamic programming, divide and conquer, and standard graph algorithms (shortest path, max flow, MST). In learning these, it is just as important to develop your intuition for problem solving (and rigorously reasoning about their properties) as to learn the algorithms themselves (you will probably forget the exact details of an algorithm over time). For textbooks, see Introduction to Algorithm Design by Jon Kleinberg and Eva Tardos, or Introduction to Algorithms CLRS (MIT).

- Computer Organization. Even if you are not so interested on the hardware side of things, it is good (and fun!) to build up your understanding of how a computer works starting all the way down from transistors and logic gates, going up to a basic CPU, picking up concepts along the way like caches, memory hierarchy, virtual memory, synchronization primitives, assembly languages, and more. Understanding this lower level will make you a better programmer and abstraction-er (and give you intellectual satisfaction). Though it is often emphasized that CS is not really about computers, it is still important to understand how a computer works.

- Operating Systems. Could be as an extension of above. Usually the undergrad class on OS is infamous for the amount of coding, so this is a good place to learn good software engineering skills and experiencing bigger projects. You will learn valuable lessons in concurrency, memory management, networking, file system, and even things like security. The best way to get used to concurrency is by coding few of the classic synchronization problems (single reader multiple writer, barrier, dining philosophers) yourself in language with good concurrency support (Python, Java are okay from my experience; Go is very clean in particular). People often put up course projects from their OS on github, so you can probably use one of those if you want to build an mini OS from scratch; but this isn't necessary to move on.

From this point on, you have enough basics to start exploring your specific interests. The only thing limiting you is time! Brief overview of some subareas of CS. (Note that my coverage of certain areas is more in-depth and longer only because I happened to learned about them.):

More algorithms/data structures: Plenty to learn more beyond the intro class. Some suggested topics: graph theory, linear programming, convex optimization, advanced data structures (ex. persistent data structures), approximation algorithms, distributed algorithms. Not particularly relevant to practice, but many of the mathematical ideas and analysis techniques are beautiful.
Theory of Computation. You learn and reason about what computation can and cannot do (mostly the latter). From more traditional topics such as (various) automata, context-free languages, complexity classes (P, NP, #P, BPP, PSPACE), PCPs, connection to randomness, to more recent topics including circuit lower bounds, arithmetic complexity, quantum complexity, communication complexity, various hardness conjectures (ex. Unique Games Conjecture and its relation to optimality of approximation algorithms). Also has many connections to cryptography.
Distributed Systems: You learn about how to design large computer systems that are distributed that can deliver some goal (ex. key-value store). Definitely on the more practical side, but the theory behind is interesting as well. Turns out both in real world and in theory, it is hard to guarantee every desirable criteria such as correctness, low latency, robustness, etc. Building real systems is sort of like real life; there are many tradeoffs.
Databases
Machine learning/Artificial Intelligence: Its importance andrelevance goes without saying. ML in particular (note that there isn't a sharp boundary between ML, AI, statistics, and data mining) has become increasingly popular in the past decade due to ""Big Data"" and its success in many different domains (from more traditional areas like computer vision or natural language processing, to newer applications like fraud detection, spam filtering, and content recommendation). There are a lot of interesting theory behind ML, with heavy connections to more classical fields like statistics. AI will be an interesting and open field for as long as there are robots aren't as good as humans.
Subareas of above that are more focused on a particular niche: computer vision, natural language processing (NLP), robotics, computational biology
Programming Languages (PL): This field is more than what you might guess from the name. A good place to start is to explore new paradigms such as functional programming. The theoretical foundations of PL are fascinating, and is closely related to logic. If you are more of an algebraist than an analyst in terms of mathematical preference, you might find PL theory more suited to your tastes than algorithms/complexity. Even areas of math that are traditionally known to be very abstract such as category theory surprisingly has its use in PL Some of the numerous applications of PL theory include theorem provers, verified computation, compilers, type systems, concurrency, language based security, software defined networking, and even foundations of mathematics (see HTT)--pretty much any application where you can benefit from having more well-defined semantics.
Compilers. With an application of lot of neat technical ideas in well-defined stages, you can turn a program in a high-level language into machine code that can executed by your computer--how cool is that? It is best to learn compilers by building one; I think this is an invaluable experience if you are considering careers involving software engineering.
Computer Graphics. You can build things that you can actually show to your friends. Interesting sub-topics: physically based animations (ex. simulating fluids), computational geometry, computational photography
Cryptography: the more mathematical side of building secure systems. It is interesting to see how to rigorously define various notions of security, how to base cryptographic primitives on computationally hard problems.
Security: the more practical side of above.
Human Computer Interaction: the name says it

For additional resources such as Coursera, edX, MIT OpenCourseWare, and course websites from top CS departments (Stanford, MIT, CMU, UC Berkeley, Cornell, UW, etc.)

Most of the topics I mentioned so far, though important for foundations, are very academic. I recommend having this academic background because it is often missing in self-taught programmers, and more importantly it exposes to you a lot of fundamental design and problem solving choices in Computer Science. If you want more practical experience (ie. the kind of skills more directly applicable to traditional software engineering role), explore the following (I'm not an expert here so please be forgiving if my list lacks coverage or is outdated, and feel free suggest edits in the comments):
- UNIX. Download Ubuntu (or any distro) and start playing around with it. There are also free courses online (ex. edX) to learn more about it.
- web development. I don't have much to say here from lack of experience but explore Javascript, HTML, CSS, php, Ruby on Rails etc.
- mobile development (iOS, Android)
- backend technologies (MySQL, MongoDB, Hadoop, etc.)
- various open source projects
- various other new web technologies hot at the time
- anything else that intrigues you

Though learning on your own will miss out on some aspects of a college curriculum (having professors/TAs to talk to, peers to share ideas with, a more organization, feedback through exams), I think it's certainly doable nowadays if you have sufficient self-motivation, given the amount of resources available online. Learning on your own is probably harder for more purely theoretical subjects (you have to force yourself to work through problems to really learn) than the more programming/building oriented areas, but I guess that also depends on your background and strengths. Make sure you also get a lot interaction with other people (through online forums), and to work on big projects and assignments instead of just learning the material in your head. Like they say, learn by doing it. Also, it often helps to discuss your problems with others.

Push yourself to work on challenging (but doable) problems (if you're stuck, reach out to people on StackExchange/Overflow or Quora, they are nice (usually) and very knowledgable) and collaborating with others on larger projects since those are the experiences that self-schooled people will miss out on.

Some additional notes:
- Start with an imperative language, but you should experience a functional language (Haskell, Lisp, ML family including OCaml) at some point, as it is a paradigm shift in the way you think about programs and data structures.

- I definitely agree with Chris's remark that ""underneath many languages are similar."" As you learn and write programs more and more, you will come to the understanding that they are all similar in some way. In that sense, it doesn't really matter which language you learn first, but it's just that some are easier than others for starters and for establishing solid foundations. As you get more specialized however, you will find that some more more suited for certain tasks.

- If you want to get further with/spice up learning basic data structures and algorithms, competitive programming might be fun to try. I learned most common data structures and algorithms in high school through USACO Training gateway, after reading a competitive programming problem online and finding it intriguing. Most involve solving an algorithmic or mathematical puzzle using an efficient algorithm, usually codeable within one page in length, to produce correct outputs in limited time. Topcoder, Codeforces, Project Euler, IOI, Google Code Jam, ACM ICPC and others are all very good places to start.

That was a bit long, but hopefully you can find something you like in there. If you need any clarification, comment below.

Source: based on my experiences as a CS major","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/lsknxe4bf2t9d76a', 'title': 'What is the best way to self-teach the skills and knowledge gained in a typical computer science degree, assuming a person only has functional working knowledge of computers?', 'score': {'original': 0.85672, 'ai': 0.14328}, 'blocks': [{'text': ""I think starting by thoroughly learning a programming language is a good idea. It is often said that CS is more than programming or a particular language, but much of CS is done through programming, and is a way for you to pick up good fundamentals. Languages such as C/C++, Python, and Java are popular starters. Some are probably bad choice for starters (ex. Javascript, imo). I started with Java (as my first CS class happened to be taught in this), and Java has its merits over C/C++ and Python, especially as a first language. I prefer Java's static typing, though I also enjoy Python's brevity and readability. C++ is a bit messy for starters, and C is a bit too low-level for your first language, but it has its benefits. It doesn't matter too much what you happen to pick.\n\nOnce you have picked a language, grab an introductory book (or find resources online); work through the exercises (preferably by actually compiling and running your programs on a real computer) and learn basic programming constructs (if-else, loops, variables, Arrays, Input/Output). This might take a while if you have never programmed before, but you will get used to it.\n\nOnce you got the basics down and can write simple programs, try building a larger OOP-style project involving multiple classes. This could be from an assignment online, from the back of the textbook, or something simple you wanted to build (some ideas: maybe a simple game with a GUI).\n\nYou don't have to master the language, but just learn enough basics so that you can code up simple things when you want to (and also begin to think like a computer scientist). In fact, to master a language in all its depth takes quite a bit of time and experience.\n\nFrom this point on, what I describe follows more or less a standard college CS curriculum, which means that it has a substantial theoretical component to it. If you want to just practice programming or are interested in more direct applications such as web design, this may not apply to you, but some of these skills are fundamental to all of CS (and problem solving) , and even if you're writing a web application or a new smartphone app, knowing basic algorithms and data structures (and in general understanding the thought processes of a computer scientist) will help you a lot not only directly with what you're producing/coding, but allow you to have a greater appreciation for the kind of problem solving, design considerations, and analysis that computer scientists practice everyday.\n\nTypically, after the introductory CS course, one picks up a little more foundation for mathematical tools in CS: discrete math and basic data structures and algorithms. For this, I also recommend grabbing a textbook or looking for resources online (many colleges have their course notes and problem sets available online; MOOC's are becoming more popular too). Some basic data structures/algorithms that you should become familiar with: arrays, linked lists, Binary Search Trees, balanced Binary Search Trees (ex. Red-black trees, AVL trees), heaps, sorting algorithms (insertion sort, merge"", 'result': {'fake': 0.3242, 'real': 0.6758}, 'status': 'success'}, {'text': ""sort, quick sort), and a plenty more.\n\nAs for discrete math, you should be familiar with basic probability, logic, proof techniques (induction), basic number theory, set theory, automata theory/finite state machines, and basic graph theory. These are more or less tools to help you reason about computation in its various forms. They might seem a little dry/pointless if it's your first time seeing it, so it's important see motivations for certain concepts. For example, basic number theory becomes useful in constructing basic cryptographic primitives. As another example, logic becomes necessary when you reason about how programming languages are compiled.\n\nBy now, you've explored most of the basics. You can write up simple programs that do what you want, and you are familiar with basic data structures to make your programs efficient, and some basic mathematics to reason about them.\n\nSome deeper topics now. None of these are required, but they are part of standard CS curriculums and as a whole instrumental to your understanding of CS.\n\n- Algorithms. Using similar resources, learn more advanced algorithms and design principles such as greedy algorithms, dynamic programming, divide and conquer, and standard graph algorithms (shortest path, max flow, MST). In learning these, it is just as important to develop your intuition for problem solving (and rigorously reasoning about their properties) as to learn the algorithms themselves (you will probably forget the exact details of an algorithm over time). For textbooks, see Introduction to Algorithm Design by Jon Kleinberg and Eva Tardos, or Introduction to Algorithms CLRS (MIT).\n\n- Computer Organization. Even if you are not so interested on the hardware side of things, it is good (and fun!) to build up your understanding of how a computer works starting all the way down from transistors and logic gates, going up to a basic CPU, picking up concepts along the way like caches, memory hierarchy, virtual memory, synchronization primitives, assembly languages, and more. Understanding this lower level will make you a better programmer and abstraction-er (and give you intellectual satisfaction). Though it is often emphasized that CS is not really about computers, it is still important to understand how a computer works.\n\n- Operating Systems. Could be as an extension of above. Usually the undergrad class on OS is infamous for the amount of coding, so this is a good place to learn good software engineering skills and experiencing bigger projects. You will learn valuable lessons in concurrency, memory management, networking, file system, and even things like security. The best way to get used to concurrency is by coding few of the classic synchronization problems (single reader multiple writer, barrier, dining philosophers) yourself in language with good concurrency support (Python, Java are okay from my experience; Go is very clean in particular). People often put up course projects from their OS on github, so you can probably use one of those if you want to build an mini OS from scratch; but this isn't necessary to move on.\n\nFrom this point on, you have enough basics to start exploring your specific interests. The only thing limiting you is time! Brief overview of some"", 'result': {'fake': 0.6164, 'real': 0.3836}, 'status': 'success'}, {'text': 'subareas of CS. (Note that my coverage of certain areas is more in-depth and longer only because I happened to learned about them.):\n\nMore algorithms/data structures: Plenty to learn more beyond the intro class. Some suggested topics: graph theory, linear programming, convex optimization, advanced data structures (ex. persistent data structures), approximation algorithms, distributed algorithms. Not particularly relevant to practice, but many of the mathematical ideas and analysis techniques are beautiful.\nTheory of Computation. You learn and reason about what computation can and cannot do (mostly the latter). From more traditional topics such as (various) automata, context-free languages, complexity classes (P, NP, #P, BPP, PSPACE), PCPs, connection to randomness, to more recent topics including circuit lower bounds, arithmetic complexity, quantum complexity, communication complexity, various hardness conjectures (ex. Unique Games Conjecture and its relation to optimality of approximation algorithms). Also has many connections to cryptography.\nDistributed Systems: You learn about how to design large computer systems that are distributed that can deliver some goal (ex. key-value store). Definitely on the more practical side, but the theory behind is interesting as well. Turns out both in real world and in theory, it is hard to guarantee every desirable criteria such as correctness, low latency, robustness, etc. Building real systems is sort of like real life; there are many tradeoffs.\nDatabases\nMachine learning/Artificial Intelligence: Its importance andrelevance goes without saying. ML in particular (note that there isn\'t a sharp boundary between ML, AI, statistics, and data mining) has become increasingly popular in the past decade due to ""Big Data"" and its success in many different domains (from more traditional areas like computer vision or natural language processing, to newer applications like fraud detection, spam filtering, and content recommendation). There are a lot of interesting theory behind ML, with heavy connections to more classical fields like statistics. AI will be an interesting and open field for as long as there are robots aren\'t as good as humans.\nSubareas of above that are more focused on a particular niche: computer vision, natural language processing (NLP), robotics, computational biology\nProgramming Languages (PL): This field is more than what you might guess from the name. A good place to start is to explore new paradigms such as functional programming. The theoretical foundations of PL are fascinating, and is closely related to logic. If you are more of an algebraist than an analyst in terms of mathematical preference, you might find PL theory more suited to your tastes than algorithms/complexity. Even areas of math that are traditionally known to be very abstract such as category theory surprisingly has its use in PL Some of the numerous applications of PL theory include theorem provers, verified computation, compilers, type systems, concurrency, language based security, software defined networking, and even foundations of mathematics (see HTT)--pretty much any application where you can benefit from having more well-defined semantics.\nCompilers. With an application of lot of neat technical ideas in well-defined stages, you can turn a program in a high-level language into machine code that can executed by your computer--how cool is that? It is best to learn compilers by building one; I think', 'result': {'fake': 0.0514, 'real': 0.9486}, 'status': 'success'}, {'text': 'this is an invaluable experience if you are considering careers involving software engineering.\nComputer Graphics. You can build things that you can actually show to your friends. Interesting sub-topics: physically based animations (ex. simulating fluids), computational geometry, computational photography\nCryptography: the more mathematical side of building secure systems. It is interesting to see how to rigorously define various notions of security, how to base cryptographic primitives on computationally hard problems.\nSecurity: the more practical side of above.\nHuman Computer Interaction: the name says it\n\nFor additional resources such as Coursera, edX, MIT OpenCourseWare, and course websites from top CS departments (Stanford, MIT, CMU, UC Berkeley, Cornell, UW, etc.)\n\nMost of the topics I mentioned so far, though important for foundations, are very academic. I recommend having this academic background because it is often missing in self-taught programmers, and more importantly it exposes to you a lot of fundamental design and problem solving choices in Computer Science. If you want more practical experience (ie. the kind of skills more directly applicable to traditional software engineering role), explore the following (I\'m not an expert here so please be forgiving if my list lacks coverage or is outdated, and feel free suggest edits in the comments):\n- UNIX. Download Ubuntu (or any distro) and start playing around with it. There are also free courses online (ex. edX) to learn more about it.\n- web development. I don\'t have much to say here from lack of experience but explore Javascript, HTML, CSS, php, Ruby on Rails etc.\n- mobile development (iOS, Android)\n- backend technologies (MySQL, MongoDB, Hadoop, etc.)\n- various open source projects\n- various other new web technologies hot at the time\n- anything else that intrigues you\n\nThough learning on your own will miss out on some aspects of a college curriculum (having professors/TAs to talk to, peers to share ideas with, a more organization, feedback through exams), I think it\'s certainly doable nowadays if you have sufficient self-motivation, given the amount of resources available online. Learning on your own is probably harder for more purely theoretical subjects (you have to force yourself to work through problems to really learn) than the more programming/building oriented areas, but I guess that also depends on your background and strengths. Make sure you also get a lot interaction with other people (through online forums), and to work on big projects and assignments instead of just learning the material in your head. Like they say, learn by doing it. Also, it often helps to discuss your problems with others.\n\nPush yourself to work on challenging (but doable) problems (if you\'re stuck, reach out to people on StackExchange/Overflow or Quora, they are nice (usually) and very knowledgable) and collaborating with others on larger projects since those are the experiences that self-schooled people will miss out on.\n\nSome additional notes:\n- Start with an imperative language, but you should experience a functional language (Haskell, Lisp, ML family including OCaml) at some point, as it is a paradigm shift in the way you think about programs and data structures.\n\n- I definitely agree with Chris\'s remark that ""underneath many languages are similar."" As you learn and write programs', 'result': {'fake': 0.0328, 'real': 0.9672}, 'status': 'success'}, {'text': ""more and more, you will come to the understanding that they are all similar in some way. In that sense, it doesn't really matter which language you learn first, but it's just that some are easier than others for starters and for establishing solid foundations. As you get more specialized however, you will find that some more more suited for certain tasks.\n\n- If you want to get further with/spice up learning basic data structures and algorithms, competitive programming might be fun to try. I learned most common data structures and algorithms in high school through USACO Training gateway, after reading a competitive programming problem online and finding it intriguing. Most involve solving an algorithmic or mathematical puzzle using an efficient algorithm, usually codeable within one page in length, to produce correct outputs in limited time. Topcoder, Codeforces, Project Euler, IOI, Google Code Jam, ACM ICPC and others are all very good places to start.\n\nThat was a bit long, but hopefully you can find something you like in there. If you need any clarification, comment below.\n\nSource: based on my experiences as a CS major"", 'result': {'fake': 0.3512, 'real': 0.6488}, 'status': 'success'}], 'credits_used': 23, 'credits': 1984011, 'subscription': 0, 'content': 'I think starting by thoroughly learning a programming language is a good idea. It is often said that CS is more than programming or a particular language, but much of CS is done through programming, and is a way for you to pick up good fundamentals. Languages such as C/C++, Python, and Java are popular starters. Some are probably bad choice for starters (ex. Javascript, imo). I started with Java (as my first CS class happened to be taught in this), and Java has its merits over C/C++ and Python, especially as a first language. I prefer Java\'s static typing, though I also enjoy Python\'s brevity and readability. C++ is a bit messy for starters, and C is a bit too low-level for your first language, but it has its benefits. It doesn\'t matter too much what you happen to pick.\n\nOnce you have picked a language, grab an introductory book (or find resources online); work through the exercises (preferably by actually compiling and running your programs on a real computer) and learn basic programming constructs (if-else, loops, variables, Arrays, Input/Output). This might take a while if you have never programmed before, but you will get used to it.\n\nOnce you got the basics down and can write simple programs, try building a larger OOP-style project involving multiple classes. This could be from an assignment online, from the back of the textbook, or something simple you wanted to build (some ideas: maybe a simple game with a GUI).\n\nYou don\'t have to master the language, but just learn enough basics so that you can code up simple things when you want to (and also begin to think like a computer scientist). In fact, to master a language in all its depth takes quite a bit of time and experience.\n\nFrom this point on, what I describe follows more or less a standard college CS curriculum, which means that it has a substantial theoretical component to it. If you want to just practice programming or are interested in more direct applications such as web design, this may not apply to you, but some of these skills are fundamental to all of CS (and problem solving) , and even if you\'re writing a web application or a new smartphone app, knowing basic algorithms and data structures (and in general understanding the thought processes of a computer scientist) will help you a lot not only directly with what you\'re producing/coding, but allow you to have a greater appreciation for the kind of problem solving, design considerations, and analysis that computer scientists practice everyday.\n\nTypically, after the introductory CS course, one picks up a little more foundation for mathematical tools in CS: discrete math and basic data structures and algorithms. For this, I also recommend grabbing a textbook or looking for resources online (many colleges have their course notes and problem sets available online; MOOC\'s are becoming more popular too). Some basic data structures/algorithms that you should become familiar with: arrays, linked lists, Binary Search Trees, balanced Binary Search Trees (ex. Red-black trees, AVL trees), heaps, sorting algorithms (insertion sort, merge sort, quick sort), and a plenty more.\n\nAs for discrete math, you should be familiar with basic probability, logic, proof techniques (induction), basic number theory, set theory, automata theory/finite state machines, and basic graph theory. These are more or less tools to help you reason about computation in its various forms. They might seem a little dry/pointless if it\'s your first time seeing it, so it\'s important see motivations for certain concepts. For example, basic number theory becomes useful in constructing basic cryptographic primitives. As another example, logic becomes necessary when you reason about how programming languages are compiled.\n\nBy now, you\'ve explored most of the basics. You can write up simple programs that do what you want, and you are familiar with basic data structures to make your programs efficient, and some basic mathematics to reason about them.\n\nSome deeper topics now. None of these are required, but they are part of standard CS curriculums and as a whole instrumental to your understanding of CS.\n\n- Algorithms. Using similar resources, learn more advanced algorithms and design principles such as greedy algorithms, dynamic programming, divide and conquer, and standard graph algorithms (shortest path, max flow, MST). In learning these, it is just as important to develop your intuition for problem solving (and rigorously reasoning about their properties) as to learn the algorithms themselves (you will probably forget the exact details of an algorithm over time). For textbooks, see Introduction to Algorithm Design by Jon Kleinberg and Eva Tardos, or Introduction to Algorithms CLRS (MIT).\n\n- Computer Organization. Even if you are not so interested on the hardware side of things, it is good (and fun!) to build up your understanding of how a computer works starting all the way down from transistors and logic gates, going up to a basic CPU, picking up concepts along the way like caches, memory hierarchy, virtual memory, synchronization primitives, assembly languages, and more. Understanding this lower level will make you a better programmer and abstraction-er (and give you intellectual satisfaction). Though it is often emphasized that CS is not really about computers, it is still important to understand how a computer works.\n\n- Operating Systems. Could be as an extension of above. Usually the undergrad class on OS is infamous for the amount of coding, so this is a good place to learn good software engineering skills and experiencing bigger projects. You will learn valuable lessons in concurrency, memory management, networking, file system, and even things like security. The best way to get used to concurrency is by coding few of the classic synchronization problems (single reader multiple writer, barrier, dining philosophers) yourself in language with good concurrency support (Python, Java are okay from my experience; Go is very clean in particular). People often put up course projects from their OS on github, so you can probably use one of those if you want to build an mini OS from scratch; but this isn\'t necessary to move on.\n\nFrom this point on, you have enough basics to start exploring your specific interests. The only thing limiting you is time! Brief overview of some subareas of CS. (Note that my coverage of certain areas is more in-depth and longer only because I happened to learned about them.):\n\nMore algorithms/data structures: Plenty to learn more beyond the intro class. Some suggested topics: graph theory, linear programming, convex optimization, advanced data structures (ex. persistent data structures), approximation algorithms, distributed algorithms. Not particularly relevant to practice, but many of the mathematical ideas and analysis techniques are beautiful.\nTheory of Computation. You learn and reason about what computation can and cannot do (mostly the latter). From more traditional topics such as (various) automata, context-free languages, complexity classes (P, NP, #P, BPP, PSPACE), PCPs, connection to randomness, to more recent topics including circuit lower bounds, arithmetic complexity, quantum complexity, communication complexity, various hardness conjectures (ex. Unique Games Conjecture and its relation to optimality of approximation algorithms). Also has many connections to cryptography.\nDistributed Systems: You learn about how to design large computer systems that are distributed that can deliver some goal (ex. key-value store). Definitely on the more practical side, but the theory behind is interesting as well. Turns out both in real world and in theory, it is hard to guarantee every desirable criteria such as correctness, low latency, robustness, etc. Building real systems is sort of like real life; there are many tradeoffs.\nDatabases\nMachine learning/Artificial Intelligence: Its importance andrelevance goes without saying. ML in particular (note that there isn\'t a sharp boundary between ML, AI, statistics, and data mining) has become increasingly popular in the past decade due to ""Big Data"" and its success in many different domains (from more traditional areas like computer vision or natural language processing, to newer applications like fraud detection, spam filtering, and content recommendation). There are a lot of interesting theory behind ML, with heavy connections to more classical fields like statistics. AI will be an interesting and open field for as long as there are robots aren\'t as good as humans.\nSubareas of above that are more focused on a particular niche: computer vision, natural language processing (NLP), robotics, computational biology\nProgramming Languages (PL): This field is more than what you might guess from the name. A good place to start is to explore new paradigms such as functional programming. The theoretical foundations of PL are fascinating, and is closely related to logic. If you are more of an algebraist than an analyst in terms of mathematical preference, you might find PL theory more suited to your tastes than algorithms/complexity. Even areas of math that are traditionally known to be very abstract such as category theory surprisingly has its use in PL Some of the numerous applications of PL theory include theorem provers, verified computation, compilers, type systems, concurrency, language based security, software defined networking, and even foundations of mathematics (see HTT)--pretty much any application where you can benefit from having more well-defined semantics.\nCompilers. With an application of lot of neat technical ideas in well-defined stages, you can turn a program in a high-level language into machine code that can executed by your computer--how cool is that? It is best to learn compilers by building one; I think this is an invaluable experience if you are considering careers involving software engineering.\nComputer Graphics. You can build things that you can actually show to your friends. Interesting sub-topics: physically based animations (ex. simulating fluids), computational geometry, computational photography\nCryptography: the more mathematical side of building secure systems. It is interesting to see how to rigorously define various notions of security, how to base cryptographic primitives on computationally hard problems.\nSecurity: the more practical side of above.\nHuman Computer Interaction: the name says it\n\nFor additional resources such as Coursera, edX, MIT OpenCourseWare, and course websites from top CS departments (Stanford, MIT, CMU, UC Berkeley, Cornell, UW, etc.)\n\nMost of the topics I mentioned so far, though important for foundations, are very academic. I recommend having this academic background because it is often missing in self-taught programmers, and more importantly it exposes to you a lot of fundamental design and problem solving choices in Computer Science. If you want more practical experience (ie. the kind of skills more directly applicable to traditional software engineering role), explore the following (I\'m not an expert here so please be forgiving if my list lacks coverage or is outdated, and feel free suggest edits in the comments):\n- UNIX. Download Ubuntu (or any distro) and start playing around with it. There are also free courses online (ex. edX) to learn more about it.\n- web development. I don\'t have much to say here from lack of experience but explore Javascript, HTML, CSS, php, Ruby on Rails etc.\n- mobile development (iOS, Android)\n- backend technologies (MySQL, MongoDB, Hadoop, etc.)\n- various open source projects\n- various other new web technologies hot at the time\n- anything else that intrigues you\n\nThough learning on your own will miss out on some aspects of a college curriculum (having professors/TAs to talk to, peers to share ideas with, a more organization, feedback through exams), I think it\'s certainly doable nowadays if you have sufficient self-motivation, given the amount of resources available online. Learning on your own is probably harder for more purely theoretical subjects (you have to force yourself to work through problems to really learn) than the more programming/building oriented areas, but I guess that also depends on your background and strengths. Make sure you also get a lot interaction with other people (through online forums), and to work on big projects and assignments instead of just learning the material in your head. Like they say, learn by doing it. Also, it often helps to discuss your problems with others.\n\nPush yourself to work on challenging (but doable) problems (if you\'re stuck, reach out to people on StackExchange/Overflow or Quora, they are nice (usually) and very knowledgable) and collaborating with others on larger projects since those are the experiences that self-schooled people will miss out on.\n\nSome additional notes:\n- Start with an imperative language, but you should experience a functional language (Haskell, Lisp, ML family including OCaml) at some point, as it is a paradigm shift in the way you think about programs and data structures.\n\n- I definitely agree with Chris\'s remark that ""underneath many languages are similar."" As you learn and write programs more and more, you will come to the understanding that they are all similar in some way. In that sense, it doesn\'t really matter which language you learn first, but it\'s just that some are easier than others for starters and for establishing solid foundations. As you get more specialized however, you will find that some more more suited for certain tasks.\n\n- If you want to get further with/spice up learning basic data structures and algorithms, competitive programming might be fun to try. I learned most common data structures and algorithms in high school through USACO Training gateway, after reading a competitive programming problem online and finding it intriguing. Most involve solving an algorithmic or mathematical puzzle using an efficient algorithm, usually codeable within one page in length, to produce correct outputs in limited time. Topcoder, Codeforces, Project Euler, IOI, Google Code Jam, ACM ICPC and others are all very good places to start.\n\nThat was a bit long, but hopefully you can find something you like in there. If you need any clarification, comment below.\n\nSource: based on my experiences as a CS major', 'aiModelVersion': '1'}",0.85672
Kurt Guntheroth,Updated 3y,What should a computer programmer/software developer never say to their team lead?,"Q: What should a software developer never say to their team lead?
A: “This task is not possible to complete given the schedule constraints.”

(I’ve written this before, but for those of you who haven’t heard it…)

Our team was way late on a project. We’d estimated a schedule for the project using a good technique, but management didn’t want the project to take that long, so they made us take out all the iterations, all the integration tests, and accept unreasonably optimistic schedule estimates. We went to work on the project, and not surprisingly, a year or two later, we were way behind.

The VP brought the whole team of twelve into his office, fixed us with his steely gaze, and said to the first engineer, “Will you do absolutely whatever it takes to get the project done on time?” This meant not only no more delays, but to make up for lost time already.

What could a lowly dev do against the intense gaze of the VP. There was a clear threat in the air. One by one, we all said, “Yes, I’ll do it.”

I was the team lead. Due to random chance, I was asked last. “Will you do absolutely whatever it takes to finish on schedule?” asked the VP. I said, “I cannot promise to be done on the current schedule, because I believe the current schedule is impossible. We spec’d out the schedule using our best estimation techniques, but someone made us take out all the slack. It is clear at this point in the project that the schedule is not achievable. I promise to come in every day ready to do my very best work, but that’s all I can promise, because I believe the schedule is impossible.”

I was removed as lead about a week later, “because we needed our senior people to focus on writing code”.

The project dragged on for another year or 18 months. It was not complete when we started shipping, and did not satisfy its users, mostly in terms of price. Our only consolation as software developers was that the hardware team had been even more optimistic in their scheduling, so the code was done before the hardware.

The steely-eyed VP wisely left the company a few months later, before the shit really hit the fan.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/z83rgsiwd45y0atq', 'title': 'What should a computer programmer/software developer never say to their team lead?', 'score': {'original': 0.9996, 'ai': 0.0004}, 'blocks': [{'text': 'Q: What should a software developer never say to their team lead?\nA: “This task is not possible to complete given the schedule constraints.”\n\n(I’ve written this before, but for those of you who haven’t heard it…)\n\nOur team was way late on a project. We’d estimated a schedule for the project using a good technique, but management didn’t want the project to take that long, so they made us take out all the iterations, all the integration tests, and accept unreasonably optimistic schedule estimates. We went to work on the project, and not surprisingly, a year or two later, we were way behind.\n\nThe VP brought the whole team of twelve into his office, fixed us with his steely gaze, and said to the first engineer, “Will you do absolutely whatever it takes to get the project done on time?” This meant not only no more delays, but to make up for lost time already.\n\nWhat could a lowly dev do against the intense gaze of the VP. There was a clear threat in the air. One by one, we all said, “Yes, I’ll do it.”\n\nI was the team lead. Due to random chance, I was asked last. “Will you do absolutely whatever it takes to finish on schedule?” asked the VP. I said, “I cannot promise to be done on the current schedule, because I believe the current schedule is impossible. We spec’d out the schedule using our best estimation techniques, but someone made us take out all the slack. It is clear at this point in the project that the schedule is not achievable. I promise to come in every day ready to do my very best work, but that’s all I can promise, because I believe the schedule is impossible.”\n\nI was removed as lead about a week later, “because we needed our senior people to focus on writing code”.\n\nThe project dragged on for another year or 18 months. It was not complete when we started shipping, and did not satisfy its users, mostly in terms of price. Our only consolation as software developers was that the hardware team had been even more optimistic in their scheduling, so the code was done before the hardware.\n\nThe steely-eyed VP wisely left the company a few months later, before the shit really hit the fan.', 'result': {'fake': 0.0004, 'real': 0.9996}, 'status': 'success'}], 'credits_used': 4, 'credits': 1984007, 'subscription': 0, 'content': 'Q: What should a software developer never say to their team lead?\nA: “This task is not possible to complete given the schedule constraints.”\n\n(I’ve written this before, but for those of you who haven’t heard it…)\n\nOur team was way late on a project. We’d estimated a schedule for the project using a good technique, but management didn’t want the project to take that long, so they made us take out all the iterations, all the integration tests, and accept unreasonably optimistic schedule estimates. We went to work on the project, and not surprisingly, a year or two later, we were way behind.\n\nThe VP brought the whole team of twelve into his office, fixed us with his steely gaze, and said to the first engineer, “Will you do absolutely whatever it takes to get the project done on time?” This meant not only no more delays, but to make up for lost time already.\n\nWhat could a lowly dev do against the intense gaze of the VP. There was a clear threat in the air. One by one, we all said, “Yes, I’ll do it.”\n\nI was the team lead. Due to random chance, I was asked last. “Will you do absolutely whatever it takes to finish on schedule?” asked the VP. I said, “I cannot promise to be done on the current schedule, because I believe the current schedule is impossible. We spec’d out the schedule using our best estimation techniques, but someone made us take out all the slack. It is clear at this point in the project that the schedule is not achievable. I promise to come in every day ready to do my very best work, but that’s all I can promise, because I believe the schedule is impossible.”\n\nI was removed as lead about a week later, “because we needed our senior people to focus on writing code”.\n\nThe project dragged on for another year or 18 months. It was not complete when we started shipping, and did not satisfy its users, mostly in terms of price. Our only consolation as software developers was that the hardware team had been even more optimistic in their scheduling, so the code was done before the hardware.\n\nThe steely-eyed VP wisely left the company a few months later, before the shit really hit the fan.', 'aiModelVersion': '1'}",0.9996
Dipt Chaudhary,8y,"Why do some computer programmers develop amazing software or new concepts, while some are stuck with basic programming work?","This is a lego block


We all played with it, but what is the most amazing structure you have made out of it?
Was it like



Or


or


So let's simplify your question to ""Why do some people develop amazing lego structures or new concepts, while some are stuck with basic building?""

It's because one requires a clear and concise plan to make complex object out of simple things. Everyone gets stuck at the basic building phase at some point, but they should make sure they learn from their mistakes and plan better the next time.

Imagine making something(like a building) with 10 lego blocks.

Now imagine the same thing a bit greater in size and detail(a building with windows and balconies) with 20 lego blocks

Try 40(add a garden in front of the building), 80, 160 ......

You start seeing your amazing structure after 10240, but always strive to go further. The sky is not the limit, your imagination is.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/pz7rs1niqcb5x3yv', 'title': 'Why do some computer programmers develop amazing software or new concepts, while some are stuck with basic programming work?', 'score': {'original': 0.9989, 'ai': 0.0011}, 'blocks': [{'text': 'This is a lego block\n\n\nWe all played with it, but what is the most amazing structure you have made out of it?\nWas it like\n\n\n\nOr\n\n\nor\n\n\nSo let\'s simplify your question to ""Why do some people develop amazing lego structures or new concepts, while some are stuck with basic building?""\n\nIt\'s because one requires a clear and concise plan to make complex object out of simple things. Everyone gets stuck at the basic building phase at some point, but they should make sure they learn from their mistakes and plan better the next time.\n\nImagine making something(like a building) with 10 lego blocks.\n\nNow imagine the same thing a bit greater in size and detail(a building with windows and balconies) with 20 lego blocks\n\nTry 40(add a garden in front of the building), 80, 160 ......\n\nYou start seeing your amazing structure after 10240, but always strive to go further. The sky is not the limit, your imagination is.', 'result': {'fake': 0.0024, 'real': 0.9976}, 'status': 'success'}], 'credits_used': 2, 'credits': 1984005, 'subscription': 0, 'content': 'This is a lego block\n\n\nWe all played with it, but what is the most amazing structure you have made out of it?\nWas it like\n\n\n\nOr\n\n\nor\n\n\nSo let\'s simplify your question to ""Why do some people develop amazing lego structures or new concepts, while some are stuck with basic building?""\n\nIt\'s because one requires a clear and concise plan to make complex object out of simple things. Everyone gets stuck at the basic building phase at some point, but they should make sure they learn from their mistakes and plan better the next time.\n\nImagine making something(like a building) with 10 lego blocks.\n\nNow imagine the same thing a bit greater in size and detail(a building with windows and balconies) with 20 lego blocks\n\nTry 40(add a garden in front of the building), 80, 160 ......\n\nYou start seeing your amazing structure after 10240, but always strive to go further. The sky is not the limit, your imagination is.', 'aiModelVersion': '1'}",0.9989
John L. Miller,2y,How do you deal with a very slow software developer on your team?,"Developers work at all kinds of speeds. Sometimes you get a good (or bad!) bonus along with that speed.

At Microsoft I had a colleague who was incredibly prolific. In a world where 50 lines a day was an alright day, he could put out a thousand. And finish his assignments more quickly. But when it came to debugging and maintaining that code, it was a nightmare. He cut-and-pasted like mad, and didn’t necessarily clean up the comments, variable name mis-spellings (e.g. “lenth”) structure, and so on. He also took algorithmic shortcuts which made the code brittle. So, fast and quick to production isn’t necessarily good.

I had another colleague who was a deep thinker. He’d take a first stab at a problem and deliver a result slower than typical. It would be clean code, reasonably put together, but not perfect. In my team, he worked on a component whose value was based on accuracy of the heuristics - sensor interpretation. He kept making it better and better, enabled by his nature and by his thoughtful approach to design and development. By the end of the project we had much better recognition quality and faster code than another approach could possibly have yielded. In other words, a huge benefit to the product for him being slow but methodical.

As a manager, I used to think you should treat everyone equally. Now I realize you treat them according to their needs and talents.

If you have a very slow developer, dig a little into WHY they’re slow, and see if there are easy fixes you can recommend to them. If you’re not getting anything good for that extra time they’re spending, it’s a problem and one you’ll need to work on fixing. But if they ARE delivering something extra, leverage it to make your product better.

For a slow, untalented developer, given them work which is not in the critical path. Make sure they understand they need to learn to work faster, and partner with them to identify reasonable ways they can. If they’re meeting the bar in everything except speed, it can be worth putting a lot of effort - months or years - into this. On the other hand, if they’re behind the curve across the board, and they’re not improving, you need to start the performance improvement (PIP) plan, possibly culminating in encouraging them to find a different job.

Summing it up, slow isn’t necessarily bad, but you need to choose assignments to accommodate. Make sure they’re not blocking a critical path for development. Give frequent constructive feedback on their slow speed - if needed - and help them improve.","{'success': True, 'disclaimer': 'If you are trying to scan content that is under 50 words in length, you will run into AI accuracy issues.', 'public_link': 'https://app.originality.ai/share/1syitvnemq5f2u6r', 'title': 'How do you deal with a very slow software developer on your team?', 'score': {'original': 0.9973, 'ai': 0.0027}, 'blocks': [{'text': 'Developers work at all kinds of speeds. Sometimes you get a good (or bad!) bonus along with that speed.\n\nAt Microsoft I had a colleague who was incredibly prolific. In a world where 50 lines a day was an alright day, he could put out a thousand. And finish his assignments more quickly. But when it came to debugging and maintaining that code, it was a nightmare. He cut-and-pasted like mad, and didn’t necessarily clean up the comments, variable name mis-spellings (e.g. “lenth”) structure, and so on. He also took algorithmic shortcuts which made the code brittle. So, fast and quick to production isn’t necessarily good.\n\nI had another colleague who was a deep thinker. He’d take a first stab at a problem and deliver a result slower than typical. It would be clean code, reasonably put together, but not perfect. In my team, he worked on a component whose value was based on accuracy of the heuristics - sensor interpretation. He kept making it better and better, enabled by his nature and by his thoughtful approach to design and development. By the end of the project we had much better recognition quality and faster code than another approach could possibly have yielded. In other words, a huge benefit to the product for him being slow but methodical.\n\nAs a manager, I used to think you should treat everyone equally. Now I realize you treat them according to their needs and talents.\n\nIf you have a very slow developer, dig a little into WHY they’re slow, and see if there are easy fixes you can recommend to them. If you’re not getting anything good for that extra time they’re spending, it’s a problem and one you’ll need to work on fixing. But if they ARE delivering something extra, leverage it to make your product better.\n\nFor a slow, untalented developer, given them work which is not in the critical path. Make sure they understand they need to learn to work faster, and partner with them to identify reasonable ways they can. If they’re meeting the bar in everything except speed, it can be worth putting a lot of effort - months or years - into this. On the other hand, if they’re behind the curve across the board, and they’re not improving, you need to start the performance improvement (PIP) plan, possibly culminating in encouraging them to find a different job.\n\nSumming it up, slow isn’t necessarily bad, but you need to choose assignments to accommodate. Make sure they’re not blocking a critical path for development. Give frequent constructive feedback on their slow speed - if needed - and help them improve.', 'result': {'fake': 0.0027, 'real': 0.9973}, 'status': 'success'}], 'credits_used': 5, 'credits': 1984000, 'subscription': 0, 'content': 'Developers work at all kinds of speeds. Sometimes you get a good (or bad!) bonus along with that speed.\n\nAt Microsoft I had a colleague who was incredibly prolific. In a world where 50 lines a day was an alright day, he could put out a thousand. And finish his assignments more quickly. But when it came to debugging and maintaining that code, it was a nightmare. He cut-and-pasted like mad, and didn’t necessarily clean up the comments, variable name mis-spellings (e.g. “lenth”) structure, and so on. He also took algorithmic shortcuts which made the code brittle. So, fast and quick to production isn’t necessarily good.\n\nI had another colleague who was a deep thinker. He’d take a first stab at a problem and deliver a result slower than typical. It would be clean code, reasonably put together, but not perfect. In my team, he worked on a component whose value was based on accuracy of the heuristics - sensor interpretation. He kept making it better and better, enabled by his nature and by his thoughtful approach to design and development. By the end of the project we had much better recognition quality and faster code than another approach could possibly have yielded. In other words, a huge benefit to the product for him being slow but methodical.\n\nAs a manager, I used to think you should treat everyone equally. Now I realize you treat them according to their needs and talents.\n\nIf you have a very slow developer, dig a little into WHY they’re slow, and see if there are easy fixes you can recommend to them. If you’re not getting anything good for that extra time they’re spending, it’s a problem and one you’ll need to work on fixing. But if they ARE delivering something extra, leverage it to make your product better.\n\nFor a slow, untalented developer, given them work which is not in the critical path. Make sure they understand they need to learn to work faster, and partner with them to identify reasonable ways they can. If they’re meeting the bar in everything except speed, it can be worth putting a lot of effort - months or years - into this. On the other hand, if they’re behind the curve across the board, and they’re not improving, you need to start the performance improvement (PIP) plan, possibly culminating in encouraging them to find a different job.\n\nSumming it up, slow isn’t necessarily bad, but you need to choose assignments to accommodate. Make sure they’re not blocking a critical path for development. Give frequent constructive feedback on their slow speed - if needed - and help them improve.', 'aiModelVersion': '1'}",0.9973
